// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API Pretty both 1`] = `
[
  "import {
  CellChange,
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  ValueChange,
} from 'tinybase';

/**
 * Represents the 't1' Table.
 */
export type T1Table = {[rowId: Id]: T1Row};

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = {c1: number; c2: string; c3: string; ''?: string};

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = {c1?: number; c2?: string; c3?: string; ''?: string};

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = 'c1' | 'c2' | 'c3' | '';

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = (
  ...[cellId, cell]:
    | [cellId: 'c1', cell: number]
    | [cellId: 'c2', cell: string]
    | [cellId: 'c3', cell: string]
    | [cellId: '', cell: string]
) => void;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = (
  rowId: Id,
  forEachCell: (cellCallback: T1CellCallback) => void,
) => void;

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {t1?: T1Table};

/**
 * A Table Id in the Store.
 */
export type TableId = 't1';

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, rowCallback]: [
    tableId: 't1',
    forEachRow: (rowCallback: T1RowCallback) => void,
  ]
) => void;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]
) => CellChange;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]:
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c1',
        newCell: number | undefined,
        oldCell: number | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c2',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c3',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: '',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when set.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
    | [valueId: 'v3', value: string]
    | [valueId: '', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v3',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: '',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: Tables): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1Table): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  InvalidValueListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const store = createStore()
    .setTablesSchema({
      [T1]: {
        [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
        [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
        [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
        [_]: {[TYPE]: STRING},
      },
    })
    .setValuesSchema({
      [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string): S => fluent(() => store.setValue(V3, value)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string): S => fluent(() => store.setValue(_, value)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {Id, Ids} from 'tinybase';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {ComponentReturnType} from 'tinybase/ui-react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): Ids;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  useCreateS as useCreateSDecl,
  useS as useSDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1Table as useT1TableDecl,
  useTableIds as useTableIdsDecl,
  useTables as useTablesDecl,
} from './s-ui-react.d';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {
  useCell as useCellCore,
  useCellIds as useCellIdsCore,
  useRow as useRowCore,
  useRowIds as useRowIdsCore,
  useSortedRowIds as useSortedRowIdsCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTables as useTablesCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...args: any[]) => any,
  ...args: any[]
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...args,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
  );
};

const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId =>
  useHook(sOrSId, useTableIdsCore);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, T1);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, T1);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, T1, cellId, descending, offset, limit);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, T1, rowId);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): Ids => useHook(sOrSId, useCellIdsCore, T1, rowId);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, T1, rowId, C1);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, T1, rowId, C2);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, T1, rowId, C3);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, T1, rowId, _);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty keyed value 1`] = `
[
  "import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  ValueChange,
} from 'tinybase';

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when set.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
    | [valueId: 'v3', value: string]
    | [valueId: '', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v3',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: '',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';
import {
  InvalidValueListener,
  S,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';

export const createS: typeof createSDecl = () => {
  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setValuesSchema({
    [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
    [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
    [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
    [_]: {[TYPE]: STRING},
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string): S => fluent(() => store.setValue(V3, value)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string): S => fluent(() => store.setValue(_, value)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {Id, Ids} from 'tinybase';
import {ComponentReturnType} from 'tinybase/ui-react';
import {S} from './s.d';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  useCreateS as useCreateSDecl,
  useS as useSDecl,
} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...args: any[]) => any,
  ...args: any[]
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...args,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
  );
};

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/**
 * Represents the 't1' Table.
 */
export type T1Table = {[rowId: Id]: T1Row};

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = {c1: number; c2: string; c3: string; ''?: string};

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = {c1?: number; c2?: string; c3?: string; ''?: string};

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = 'c1' | 'c2' | 'c3' | '';

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = (
  ...[cellId, cell]:
    | [cellId: 'c1', cell: number]
    | [cellId: 'c2', cell: string]
    | [cellId: 'c3', cell: string]
    | [cellId: '', cell: string]
) => void;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = (
  rowId: Id,
  forEachCell: (cellCallback: T1CellCallback) => void,
) => void;

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {t1?: T1Table};

/**
 * A Table Id in the Store.
 */
export type TableId = 't1';

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, rowCallback]: [
    tableId: 't1',
    forEachRow: (rowCallback: T1RowCallback) => void,
  ]
) => void;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]
) => CellChange;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]:
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c1',
        newCell: number | undefined,
        oldCell: number | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c2',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c3',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: '',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: Tables): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1Table): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TransactionListener,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setTablesSchema({
    [T1]: {
      [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    },
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {Id, Ids} from 'tinybase';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {ComponentReturnType} from 'tinybase/ui-react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): Ids;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  useCreateS as useCreateSDecl,
  useS as useSDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1Table as useT1TableDecl,
  useTableIds as useTableIdsDecl,
  useTables as useTablesDecl,
} from './s-ui-react.d';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {
  useCell as useCellCore,
  useCellIds as useCellIdsCore,
  useRow as useRowCore,
  useRowIds as useRowIdsCore,
  useSortedRowIds as useSortedRowIdsCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTables as useTablesCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...args: any[]) => any,
  ...args: any[]
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...args,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
  );
};

const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId =>
  useHook(sOrSId, useTableIdsCore);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, T1);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, T1);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, T1, cellId, descending, offset, limit);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, T1, rowId);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): Ids => useHook(sOrSId, useCellIdsCore, T1, rowId);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, T1, rowId, C1);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, T1, rowId, C2);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, T1, rowId, C3);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, T1, rowId, _);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Unpretty both 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store, ValueChange} from 'tinybase';

/** Represents the 't1' Table. */
export type T1Table = {[rowId: Id]: T1Row};

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = {'c1': number; 'c2': string; 'c3': string; ''?: string;};

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string;};

/** A Cell Id for the 't1' Table. */
export type T1CellId = 'c1' | 'c2' | 'c3' | '';

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = (...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string] | [cellId: 'c3', cell: string] | [cellId: '', cell: string]) => void;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = (rowId: Id, forEachCell: (cellCallback: T1CellCallback) => void) => void;

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: T1Table;};

/** A Table Id in the Store. */
export type TableId = 't1';

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, rowCallback]: [tableId: 't1', forEachRow: (rowCallback: T1RowCallback) => void]) => void;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]) => CellChange;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: [s: S, tableId: 't1', rowId: Id, cellId: 'c1', newCell: number | undefined, oldCell: number | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c2', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c3', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: '', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined]) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string;};

/** Represents the keyed value content of the Store when set. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string;};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string] | [valueId: 'v3', value: string] | [valueId: '', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v3', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: '', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: Tables): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1Table): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, InvalidValueListener, MapNumber, MapString, RowIdsListener, RowListener, S, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
})
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string): S => fluent(() => store.setValue(V3, value)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string): S => fluent(() => store.setValue(_, value)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Id, Ids} from 'tinybase';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {ComponentReturnType} from 'tinybase/ui-react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): Ids;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {Provider as ProviderDecl, ProviderProps, SOrSId, useCreateS as useCreateSDecl, useS as useSDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1Table as useT1TableDecl, useTableIds as useTableIdsDecl, useTables as useTablesDecl} from './s-ui-react.d';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {useCell as useCellCore, useCellIds as useCellIdsCore, useRow as useRowCore, useRowIds as useRowIdsCore, useSortedRowIds as useSortedRowIdsCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTables as useTablesCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...args: any[]) => any, ...args: any[]) => {
const s = useS(sOrSId as Id);
return hook(...args, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore())
};

const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore)

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId =>
useHook(sOrSId, useTableIdsCore)

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, T1)

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, T1)

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, T1, cellId, descending, offset, limit)

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, T1, rowId)

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useCellIdsCore, T1, rowId)

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, T1, rowId, C1)

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, T1, rowId, C2)

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, T1, rowId, C3)

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, T1, rowId, _)

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty keyed value 1`] = `
[
  "import {DoRollback, Id, IdOrNull, Ids, Json, Store, ValueChange} from 'tinybase';

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string;};

/** Represents the keyed value content of the Store when set. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string;};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string] | [valueId: 'v3', value: string] | [valueId: '', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v3', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: '', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';
import {InvalidValueListener, S, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';

export const createS: typeof createSDecl = () => {
const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string): S => fluent(() => store.setValue(V3, value)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string): S => fluent(() => store.setValue(_, value)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Id, Ids} from 'tinybase';
import {ComponentReturnType} from 'tinybase/ui-react';
import {S} from './s.d';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {Provider as ProviderDecl, ProviderProps, SOrSId, useCreateS as useCreateSDecl, useS as useSDecl} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...args: any[]) => any, ...args: any[]) => {
const s = useS(sOrSId as Id);
return hook(...args, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore())
};

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/** Represents the 't1' Table. */
export type T1Table = {[rowId: Id]: T1Row};

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = {'c1': number; 'c2': string; 'c3': string; ''?: string;};

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string;};

/** A Cell Id for the 't1' Table. */
export type T1CellId = 'c1' | 'c2' | 'c3' | '';

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = (...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string] | [cellId: 'c3', cell: string] | [cellId: '', cell: string]) => void;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = (rowId: Id, forEachCell: (cellCallback: T1CellCallback) => void) => void;

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: T1Table;};

/** A Table Id in the Store. */
export type TableId = 't1';

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, rowCallback]: [tableId: 't1', forEachRow: (rowCallback: T1RowCallback) => void]) => void;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]) => CellChange;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: [s: S, tableId: 't1', rowId: Id, cellId: 'c1', newCell: number | undefined, oldCell: number | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c2', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c3', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: '', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined]) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: Tables): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1Table): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, MapNumber, MapString, RowIdsListener, RowListener, S, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TransactionListener, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Id, Ids} from 'tinybase';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {ComponentReturnType} from 'tinybase/ui-react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): Ids;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Id, Ids} from 'tinybase';
import {Provider as ProviderDecl, ProviderProps, SOrSId, useCreateS as useCreateSDecl, useS as useSDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1Table as useT1TableDecl, useTableIds as useTableIdsDecl, useTables as useTablesDecl} from './s-ui-react.d';
import {S, T1CellId, T1Row, T1Table, TableId, Tables} from './s.d';
import {useCell as useCellCore, useCellIds as useCellIdsCore, useRow as useRowCore, useRowIds as useRowIdsCore, useSortedRowIds as useSortedRowIdsCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTables as useTablesCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...args: any[]) => any, ...args: any[]) => {
const s = useS(sOrSId as Id);
return hook(...args, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore())
};

const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore)

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId =>
useHook(sOrSId, useTableIdsCore)

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, T1)

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, T1)

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, T1, cellId, descending, offset, limit)

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, T1, rowId)

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useCellIdsCore, T1, rowId)

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, T1, rowId, C1)

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, T1, rowId, C2)

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, T1, rowId, C3)

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, T1, rowId, _)

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;
