// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API Pretty both 1`] = `
[
  "import {
  CellChange,
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  ValueChange,
} from 'tinybase';

/**
 * Represents the 't1' Table.
 */
export type T1Table = {[rowId: Id]: T1Row};

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = {c1: number; c2?: string};

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = {c1?: number; c2?: string};

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = 'c1' | 'c2';

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = (
  ...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string]
) => void;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = (
  rowId: Id,
  forEachCell: (cellCallback: T1CellCallback) => void,
) => void;

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {t1?: T1Table};

/**
 * A Table Id in the Store.
 */
export type TableId = 't1';

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, rowCallback]: [
    tableId: 't1',
    forEachRow: (rowCallback: T1RowCallback) => void,
  ]
) => void;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]
) => CellChange;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]:
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c1',
        newCell: number | undefined,
        oldCell: number | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c2',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2?: string};

/**
 * Represents the keyed value content of the Store when set.
 */
export type ValuesWhenSet = {v1?: number; v2?: string};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets whether any Table exists in the Store.
   */
  hasTables(): boolean;

  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: Tables): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets whether the 't1' Table exists in the Store.
   */
  hasT1Table(): boolean;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1Table): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets whether the specified Row exists in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets whether the 'c1' Cell exists in the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets whether the 'c2' Cell exists in the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string | undefined;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets whether any Value exists in the Store.
   */
  hasValues(): boolean;

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets whether the 'v1' Value exists in the Store.
   */
  hasV1Value(): boolean;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets whether the 'v2' Value exists in the Store.
   */
  hasV2Value(): boolean;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  InvalidValueListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const C1 = 'c1';

  const C2 = 'c2';

  const T1 = 't1';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const V1 = 'v1';

  const V2 = 'v2';

  const store = createStore()
    .setTablesSchema({
      [T1]: {
        [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
        [C2]: {[TYPE]: STRING},
      },
    })
    .setValuesSchema({
      [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [V2]: {[TYPE]: STRING},
    });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    hasTables: (): boolean => store.hasTables(),

    getTables: (): Tables => store.getTables(),

    setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    hasT1Table: (): boolean => store.hasTable(T1),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1),

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit),

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    getT1C2Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, C2) as string | undefined,

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getTablesJson: (): Json => store.getTablesJson(),

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    hasValues: (): boolean => store.hasValues(),

    getValues: (): Values => store.getValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    delValues: (): S => fluent(() => store.delValues()),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    hasV1Value: (): boolean => store.hasValue(V1),

    getV1Value: (): number => store.getValue(V1) as number,

    setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    hasV2Value: (): boolean => store.hasValue(V2),

    getV2Value: (): string => store.getValue(V2) as string,

    setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getValuesJson: (): Json => store.getValuesJson(),

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson(),

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
]
`;

exports[`API Pretty keyed value 1`] = `
[
  "import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  ValueChange,
} from 'tinybase';

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2?: string};

/**
 * Represents the keyed value content of the Store when set.
 */
export type ValuesWhenSet = {v1?: number; v2?: string};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets whether any Value exists in the Store.
   */
  hasValues(): boolean;

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets whether the 'v1' Value exists in the Store.
   */
  hasV1Value(): boolean;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets whether the 'v2' Value exists in the Store.
   */
  hasV2Value(): boolean;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';
import {
  InvalidValueListener,
  S,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  createS as createSDecl,
} from './s.d';

export const createS: typeof createSDecl = () => {
  const V1 = 'v1';

  const V2 = 'v2';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const store = createStore().setValuesSchema({
    [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
    [V2]: {[TYPE]: STRING},
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    hasValues: (): boolean => store.hasValues(),

    getValues: (): Values => store.getValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    delValues: (): S => fluent(() => store.delValues()),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    hasV1Value: (): boolean => store.hasValue(V1),

    getV1Value: (): number => store.getValue(V1) as number,

    setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    hasV2Value: (): boolean => store.hasValue(V2),

    getV2Value: (): string => store.getValue(V2) as string,

    setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getValuesJson: (): Json => store.getValuesJson(),

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson(),

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
]
`;

exports[`API Pretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/**
 * Represents the 't1' Table.
 */
export type T1Table = {[rowId: Id]: T1Row};

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = {c1: number; c2?: string};

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = {c1?: number; c2?: string};

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = 'c1' | 'c2';

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = (
  ...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string]
) => void;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = (
  rowId: Id,
  forEachCell: (cellCallback: T1CellCallback) => void,
) => void;

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {t1?: T1Table};

/**
 * A Table Id in the Store.
 */
export type TableId = 't1';

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, rowCallback]: [
    tableId: 't1',
    forEachRow: (rowCallback: T1RowCallback) => void,
  ]
) => void;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]
) => CellChange;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]:
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c1',
        newCell: number | undefined,
        oldCell: number | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    | [
        s: S,
        tableId: 't1',
        rowId: Id,
        cellId: 'c2',
        newCell: string | undefined,
        oldCell: string | undefined,
        getCellChange: GetCellChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets whether any Table exists in the Store.
   */
  hasTables(): boolean;

  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: Tables): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets whether the 't1' Table exists in the Store.
   */
  hasT1Table(): boolean;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1Table): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets whether the specified Row exists in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets whether the 'c1' Cell exists in the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets whether the 'c2' Cell exists in the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string | undefined;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TransactionListener,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const C1 = 'c1';

  const C2 = 'c2';

  const T1 = 't1';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const store = createStore().setTablesSchema({
    [T1]: {
      [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [C2]: {[TYPE]: STRING},
    },
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...args: any[]) =>
      listener(s, ...args);

  const s = {
    hasTables: (): boolean => store.hasTables(),

    getTables: (): Tables => store.getTables(),

    setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    hasT1Table: (): boolean => store.hasTable(T1),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1),

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit),

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    getT1C2Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, C2) as string | undefined,

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getTablesJson: (): Json => store.getTablesJson(),

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getJson: (): Json => store.getJson(),

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
]
`;

exports[`API Unpretty both 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store, ValueChange} from 'tinybase';

/** Represents the 't1' Table. */
export type T1Table = {[rowId: Id]: T1Row};

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = {'c1': number; 'c2'?: string;};

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = {'c1'?: number; 'c2'?: string;};

/** A Cell Id for the 't1' Table. */
export type T1CellId = 'c1' | 'c2';

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = (...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string]) => void;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = (rowId: Id, forEachCell: (cellCallback: T1CellCallback) => void) => void;

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: T1Table;};

/** A Table Id in the Store. */
export type TableId = 't1';

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, rowCallback]: [tableId: 't1', forEachRow: (rowCallback: T1RowCallback) => void]) => void;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]) => CellChange;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: [s: S, tableId: 't1', rowId: Id, cellId: 'c1', newCell: number | undefined, oldCell: number | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c2', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined]) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2'?: string;};

/** Represents the keyed value content of the Store when set. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string;};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets whether any Table exists in the Store. */
hasTables(): boolean;

/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Sets the tabular content of the Store. */
setTables(tables: Tables): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets whether the 't1' Table exists in the Store. */
hasT1Table(): boolean;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1Table): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets whether the specified Row exists in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets whether the 'c1' Cell exists in the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets whether the 'c2' Cell exists in the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string | undefined;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets whether any Value exists in the Store. */
hasValues(): boolean;

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets whether the 'v1' Value exists in the Store. */
hasV1Value(): boolean;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Sets the 'v1' Value. */
setV1Value(value: number): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets whether the 'v2' Value exists in the Store. */
hasV2Value(): boolean;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Sets the 'v2' Value. */
setV2Value(value: string): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, InvalidValueListener, MapNumber, MapString, RowIdsListener, RowListener, S, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const C1 = 'c1';

const C2 = 'c2';

const T1 = 't1';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const V1 = 'v1';

const V2 = 'v2';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING},
},
})
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
hasTables: (): boolean => store.hasTables(),

getTables: (): Tables => store.getTables(),

setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

hasT1Table: (): boolean => store.hasTable(T1),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1),

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit),

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

getT1C2Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, C2) as string | undefined,

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getTablesJson: (): Json => store.getTablesJson(),

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

hasValues: (): boolean => store.hasValues(),

getValues: (): Values => store.getValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

delValues: (): S => fluent(() => store.delValues()),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

hasV1Value: (): boolean => store.hasValue(V1),

getV1Value: (): number => store.getValue(V1) as number,

setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

hasV2Value: (): boolean => store.hasValue(V2),

getV2Value: (): string => store.getValue(V2) as string,

setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getValuesJson: (): Json => store.getValuesJson(),

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson(),

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
]
`;

exports[`API Unpretty keyed value 1`] = `
[
  "import {DoRollback, Id, IdOrNull, Ids, Json, Store, ValueChange} from 'tinybase';

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2'?: string;};

/** Represents the keyed value content of the Store when set. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string;};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets whether any Value exists in the Store. */
hasValues(): boolean;

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets whether the 'v1' Value exists in the Store. */
hasV1Value(): boolean;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Sets the 'v1' Value. */
setV1Value(value: number): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets whether the 'v2' Value exists in the Store. */
hasV2Value(): boolean;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Sets the 'v2' Value. */
setV2Value(value: string): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';
import {InvalidValueListener, S, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, createS as createSDecl} from './s.d';

export const createS: typeof createSDecl = () => {
const V1 = 'v1';

const V2 = 'v2';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const store = createStore()
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
hasValues: (): boolean => store.hasValues(),

getValues: (): Values => store.getValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

delValues: (): S => fluent(() => store.delValues()),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

hasV1Value: (): boolean => store.hasValue(V1),

getV1Value: (): number => store.getValue(V1) as number,

setV1Value: (value: number): S => fluent(() => store.setValue(V1, value)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

hasV2Value: (): boolean => store.hasValue(V2),

getV2Value: (): string => store.getValue(V2) as string,

setV2Value: (value: string): S => fluent(() => store.setValue(V2, value)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getValuesJson: (): Json => store.getValuesJson(),

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson(),

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
]
`;

exports[`API Unpretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/** Represents the 't1' Table. */
export type T1Table = {[rowId: Id]: T1Row};

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = {'c1': number; 'c2'?: string;};

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = {'c1'?: number; 'c2'?: string;};

/** A Cell Id for the 't1' Table. */
export type T1CellId = 'c1' | 'c2';

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = (...[cellId, cell]: [cellId: 'c1', cell: number] | [cellId: 'c2', cell: string]) => void;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = (rowId: Id, forEachCell: (cellCallback: T1CellCallback) => void) => void;

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: T1Table;};

/** A Table Id in the Store. */
export type TableId = 't1';

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, rowCallback]: [tableId: 't1', forEachRow: (rowCallback: T1RowCallback) => void]) => void;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: [tableId: 't1', rowId: Id, cellId: T1CellId]) => CellChange;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: [s: S, tableId: 't1', rowId: Id, cellId: 'c1', newCell: number | undefined, oldCell: number | undefined, getCellChange: GetCellChange | undefined] | [s: S, tableId: 't1', rowId: Id, cellId: 'c2', newCell: string | undefined, oldCell: string | undefined, getCellChange: GetCellChange | undefined]) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets whether any Table exists in the Store. */
hasTables(): boolean;

/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Sets the tabular content of the Store. */
setTables(tables: Tables): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets whether the 't1' Table exists in the Store. */
hasT1Table(): boolean;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1Table): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets whether the specified Row exists in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets whether the 'c1' Cell exists in the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets whether the 'c2' Cell exists in the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string | undefined;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, MapNumber, MapString, RowIdsListener, RowListener, S, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TransactionListener, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const C1 = 'c1';

const C2 = 'c2';

const T1 = 't1';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING},
},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...args: any[]) => listener(s, ...args);

const s = {
hasTables: (): boolean => store.hasTables(),

getTables: (): Tables => store.getTables(),

setTables: (tables: Tables): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

hasT1Table: (): boolean => store.hasTable(T1),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

setT1Table: (table: T1Table): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1),

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit),

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

getT1C2Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, C2) as string | undefined,

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getTablesJson: (): Json => store.getTablesJson(),

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getJson: (): Json => store.getJson(),

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
]
`;
