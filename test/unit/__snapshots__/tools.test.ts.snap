// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API Pretty both 1`] = `
[
  "import {
  CellChange,
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  ValueChange,
} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table Id in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table Id in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

/**
 * Represents the 't1' Table.
 */
export type T1Table = Table<'t1'>;

/**
 * Represents the 't1' Table when setting it.
 */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = Row<'t1'>;

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = CellId<'t1'>;

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = CellCallback<'t1'>;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = RowCallback<'t1'>;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the sorted Row Ids in a Table.
 */
export type SortedRowIdsListener = (
  s: S,
  tableId: TableId,
  cellId: Id | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  sortedRowIds: Ids,
) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * Cell args for CellListener.
 */
type CellListenerArgsArrayInner<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId>
  ? [
      s: S,
      tableId: TId,
      rowId: Id,
      cellId: CId,
      newCell: Cell<TId, CId> | undefined,
      oldCell: Cell<TId, CId> | undefined,
      getCellChange: GetCellChange | undefined,
    ]
  : never;

/**
 * Table args for CellListener.
 */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? CellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[
    s,
    tableId,
    rowId,
    cellId,
    newCell,
    oldCell,
    getCellChange,
  ]: CellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
    | [valueId: 'v3', value: string]
    | [valueId: '', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v3',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: '',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1TableWhenSet): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the sorted Row Ids in a
   * Table change.
   */
  addSortedRowIdsListener(
    tableId: TableId,
    cellId: Id | undefined,
    descending: boolean,
    offset: number,
    limit: number | undefined,
    listener: SortedRowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number | MapNumber): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string | MapString): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string | MapString): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string | MapString): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  InvalidValueListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const store = createStore()
    .setTablesSchema({
      [T1]: {
        [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
        [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
        [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
        [_]: {[TYPE]: STRING},
      },
    })
    .setValuesSchema({
      [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: TablesWhenSet): S =>
      fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1TableWhenSet): S =>
      fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addSortedRowIdsListener: (
      tableId: TableId,
      cellId: Id | undefined,
      descending: boolean,
      offset: number,
      limit: number | undefined,
      listener: SortedRowIdsListener,
      mutator?: boolean,
    ): Id =>
      store.addSortedRowIdsListener(
        tableId,
        cellId,
        descending,
        offset,
        limit,
        proxy(listener),
        mutator,
      ),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number | MapNumber): S =>
      fluent(() => store.setValue(V1, value as any)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V2, value as any)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V3, value as any)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string | MapString): S =>
      fluent(() => store.setValue(_, value as any)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders the tabular content of the
 * Store.
 */
export type TablesProps = {
  readonly s?: S;
  readonly tableComponents?: {t1?: ComponentType<T1TableProps>};
  readonly getTableComponentProps?: (tableId: TableId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Cell.
 */
export type CellProps = {
  readonly rowId: Id;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the specified Row in the 't1'
 * Table.
 */
export type T1RowProps = {
  readonly rowId: Id;
  readonly s?: S;
  readonly cellComponents?: {
    c1?: ComponentType<CellProps>;
    c2?: ComponentType<CellProps>;
    c3?: ComponentType<CellProps>;
    ''?: ComponentType<CellProps>;
  };
  readonly getCellComponentProps?: (cellId: T1CellId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the 't1' Table.
 */
export type T1TableProps = {
  readonly s?: S;
  readonly rowComponent?: ComponentType<T1RowProps>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the 't1' Table, sorted.
 */
export type T1SortedTableProps = {
  readonly cellId?: T1CellId;
  readonly descending?: boolean;
  readonly offset?: number;
  readonly limit?: number;
  readonly s?: S;
  readonly rowComponent?: ComponentType<T1RowProps>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Value.
 */
export type ValueProps = {readonly s?: S; readonly debugIds?: boolean};

/**
 * The props passed to a component that renders the keyed value content of the
 * Store.
 */
export type ValuesProps = {
  readonly s?: S;
  readonly valueComponents?: {
    v1?: ComponentType<ValueProps>;
    v2?: ComponentType<ValueProps>;
    v3?: ComponentType<ValueProps>;
    ''?: ComponentType<ValueProps>;
  };
  readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/**
 * Gets a callback that can set the tabular content of the Store, based on a
 * parameter.
 */
export function useSetTablesCallback<Parameter>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the tabular content of the Store.
 */
export function useDelTablesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the tabular content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function TablesView({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): ComponentReturnType;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/**
 * Gets a callback that can set the content of the 't1' Table, based on a
 * parameter.
 */
export function useSetT1TableCallback<Parameter>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the 't1' Table.
 */
export function useDelT1TableCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Gets a callback that can set the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1RowCallback<Parameter>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can add the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useAddT1RowCallback<Parameter>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the content of the specified Row in the
 * 't1' Table, based on a parameter.
 */
export function useSetT1PartialRowCallback<Parameter>(
  rowId: Id,
  getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getPartialRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialRow: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the specified Row in the 't1'
 * Table.
 */
export function useDelT1RowCallback(
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1RowView({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  separator,
  debugIds,
}: T1RowProps): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, sorted, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function T1SortedTableView({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: T1SortedTableProps): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function T1TableView(props: T1TableProps): ComponentReturnType;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'c1' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c1' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C1CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c2' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C2CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c2' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C2CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C2CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c3' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C3CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c3' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C3CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C3CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Gets a callback that can set the '' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Cell for the specified Row in the 't1'
 * Table.
 */
export function useDelT1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the tabular content of the
 * Store changes.
 */
export function useTablesListener(
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Table Ids in the Store
 * change.
 */
export function useTableIdsListener(
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Table in the Store
 * changes.
 */
export function useTableListener(
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Row Ids in a Table
 * change.
 */
export function useRowIdsListener(
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the sorted Row Ids in a
 * Table change.
 */
export function useSortedRowIdsListener(
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Row in a Table changes.
 */
export function useRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids in a Row
 * change.
 */
export function useCellIdsListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Cell in a Row changes.
 */
export function useCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Gets the keyed value content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useValues(sOrSId?: SOrSId): Values;

/**
 * Gets the Ids of the Values in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/**
 * Gets a callback that can set the keyed value content of the Store, based on a
 * parameter.
 */
export function useSetValuesCallback<Parameter>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the keyed value content of the Store,
 * based on a parameter.
 */
export function useSetPartialValuesCallback<Parameter>(
  getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getPartialValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialValues: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the keyed value content of the Store.
 */
export function useDelValuesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the keyed value content of the Store, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function ValuesView({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): ComponentReturnType;

/**
 * Gets the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV1Value(sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'v1' Value, based on a parameter.
 */
export function useSetV1ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v1' Value.
 */
export function useDelV1ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V1ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV2Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v2' Value, based on a parameter.
 */
export function useSetV2ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v2' Value.
 */
export function useDelV2ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V2ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV3Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v3' Value, based on a parameter.
 */
export function useSetV3ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v3' Value.
 */
export function useDelV3ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V3ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useValue(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the '' Value, based on a parameter.
 */
export function useSetValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Value.
 */
export function useDelValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the keyed value content of
 * the Store changes.
 */
export function useValuesListener(
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Value Ids in the Store
 * change.
 */
export function useValueIdsListener(
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Value in the Store
 * changes.
 */
export function useValueListener(
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {
  CellProps,
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  T1C1CellView as T1C1CellViewDecl,
  T1C2CellView as T1C2CellViewDecl,
  T1C3CellView as T1C3CellViewDecl,
  T1CellView as T1CellViewDecl,
  T1RowProps,
  T1RowView as T1RowViewDecl,
  T1SortedTableProps,
  T1SortedTableView as T1SortedTableViewDecl,
  T1TableProps,
  T1TableView as T1TableViewDecl,
  TablesProps,
  TablesView as TablesViewDecl,
  V1ValueView as V1ValueViewDecl,
  V2ValueView as V2ValueViewDecl,
  V3ValueView as V3ValueViewDecl,
  ValueProps,
  ValueView as ValueViewDecl,
  ValuesProps,
  ValuesView as ValuesViewDecl,
  useAddT1RowCallback as useAddT1RowCallbackDecl,
  useCellIdsListener as useCellIdsListenerDecl,
  useCellListener as useCellListenerDecl,
  useCreateS as useCreateSDecl,
  useDelT1C1CellCallback as useDelT1C1CellCallbackDecl,
  useDelT1C2CellCallback as useDelT1C2CellCallbackDecl,
  useDelT1C3CellCallback as useDelT1C3CellCallbackDecl,
  useDelT1CellCallback as useDelT1CellCallbackDecl,
  useDelT1RowCallback as useDelT1RowCallbackDecl,
  useDelT1TableCallback as useDelT1TableCallbackDecl,
  useDelTablesCallback as useDelTablesCallbackDecl,
  useDelV1ValueCallback as useDelV1ValueCallbackDecl,
  useDelV2ValueCallback as useDelV2ValueCallbackDecl,
  useDelV3ValueCallback as useDelV3ValueCallbackDecl,
  useDelValueCallback as useDelValueCallbackDecl,
  useDelValuesCallback as useDelValuesCallbackDecl,
  useRowIdsListener as useRowIdsListenerDecl,
  useRowListener as useRowListenerDecl,
  useS as useSDecl,
  useSetPartialValuesCallback as useSetPartialValuesCallbackDecl,
  useSetT1C1CellCallback as useSetT1C1CellCallbackDecl,
  useSetT1C2CellCallback as useSetT1C2CellCallbackDecl,
  useSetT1C3CellCallback as useSetT1C3CellCallbackDecl,
  useSetT1CellCallback as useSetT1CellCallbackDecl,
  useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl,
  useSetT1RowCallback as useSetT1RowCallbackDecl,
  useSetT1TableCallback as useSetT1TableCallbackDecl,
  useSetTablesCallback as useSetTablesCallbackDecl,
  useSetV1ValueCallback as useSetV1ValueCallbackDecl,
  useSetV2ValueCallback as useSetV2ValueCallbackDecl,
  useSetV3ValueCallback as useSetV3ValueCallbackDecl,
  useSetValueCallback as useSetValueCallbackDecl,
  useSetValuesCallback as useSetValuesCallbackDecl,
  useSortedRowIdsListener as useSortedRowIdsListenerDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1Table as useT1TableDecl,
  useTableIds as useTableIdsDecl,
  useTableIdsListener as useTableIdsListenerDecl,
  useTableListener as useTableListenerDecl,
  useTables as useTablesDecl,
  useTablesListener as useTablesListenerDecl,
  useV1Value as useV1ValueDecl,
  useV2Value as useV2ValueDecl,
  useV3Value as useV3ValueDecl,
  useValue as useValueDecl,
  useValueIds as useValueIdsDecl,
  useValueIdsListener as useValueIdsListenerDecl,
  useValueListener as useValueListenerDecl,
  useValues as useValuesDecl,
  useValuesListener as useValuesListenerDecl,
} from './s-ui-react.d';
import {
  ExtraProps,
  useAddRowCallback as useAddRowCallbackCore,
  useCell as useCellCore,
  useCellIds as useCellIdsCore,
  useCellIdsListener as useCellIdsListenerCore,
  useCellListener as useCellListenerCore,
  useDelCellCallback as useDelCellCallbackCore,
  useDelRowCallback as useDelRowCallbackCore,
  useDelTableCallback as useDelTableCallbackCore,
  useDelTablesCallback as useDelTablesCallbackCore,
  useDelValueCallback as useDelValueCallbackCore,
  useDelValuesCallback as useDelValuesCallbackCore,
  useRow as useRowCore,
  useRowIds as useRowIdsCore,
  useRowIdsListener as useRowIdsListenerCore,
  useRowListener as useRowListenerCore,
  useSetCellCallback as useSetCellCallbackCore,
  useSetPartialRowCallback as useSetPartialRowCallbackCore,
  useSetPartialValuesCallback as useSetPartialValuesCallbackCore,
  useSetRowCallback as useSetRowCallbackCore,
  useSetTableCallback as useSetTableCallbackCore,
  useSetTablesCallback as useSetTablesCallbackCore,
  useSetValueCallback as useSetValueCallbackCore,
  useSetValuesCallback as useSetValuesCallbackCore,
  useSortedRowIds as useSortedRowIdsCore,
  useSortedRowIdsListener as useSortedRowIdsListenerCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTableIdsListener as useTableIdsListenerCore,
  useTableListener as useTableListenerCore,
  useTables as useTablesCore,
  useTablesListener as useTablesListenerCore,
  useValue as useValueCore,
  useValueIds as useValueIdsCore,
  useValueIdsListener as useValueIdsListenerCore,
  useValueListener as useValueListenerCore,
  useValues as useValuesCore,
  useValuesListener as useValuesListenerCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const tableView = (
  {s, rowComponent, getRowComponentProps, separator, debugIds}: any,
  rowIds: Ids,
  tableId: Id,
  defaultRowComponent: React.ComponentType<any>,
) => {
  const Row = rowComponent ?? defaultRowComponent;
  return wrap(
    rowIds.map((rowId) => (
      <Row
        {...getProps(getRowComponentProps, rowId)}
        key={rowId}
        tableId={tableId}
        rowId={rowId}
        s={s}
        debugIds={debugIds}
      />
    )),
    separator,
    debugIds,
    tableId,
  );
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) =>
  tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) =>
  tableId == T1
    ? cellId == C1
      ? T1C1CellView
      : cellId == C2
      ? T1C2CellView
      : cellId == C3
      ? T1C3CellView
      : cellId == _
      ? T1CellView
      : NullComponent
    : NullComponent;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const getDefaultValueComponent = (valueId: Id) =>
  valueId == V1
    ? V1ValueView
    : valueId == V2
    ? V2ValueView
    : valueId == V3
    ? V3ValueView
    : valueId == _
    ? ValueView
    : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (
  sOrSId?: SOrSId,
): TableId[] => useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <
  Parameter,
>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTablesCallbackCore,
    [getTables, getTablesDeps],
    [then, thenDeps],
  );

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): any =>
  wrap(
    useTableIds(s).map((tableId) => {
      const Table =
        tableComponents?.[tableId] ?? getDefaultTableComponent(tableId);
      return (
        <Table
          {...getProps(getTableComponentProps, tableId)}
          key={tableId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1CellId[] => useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <
  Parameter,
>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTableCallbackCore,
    [T1, getTable, getTableDeps],
    [then, thenDeps],
  );

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetRowCallbackCore,
    [T1, rowId, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useAddRowCallbackCore,
    [T1, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl =
  <Parameter,>(
    rowId: Id,
    getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
    getPartialRowDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialRow: T1RowWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialRowCallbackCore,
      [T1, rowId, getPartialRow, getPartialRowDeps],
      [then, thenDeps],
    );

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  separator,
  debugIds,
}: T1RowProps): any =>
  wrap(
    useT1CellIds(rowId, s).map((cellId) => {
      const Cell =
        cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId);
      return (
        <Cell
          {...getProps(getCellComponentProps, cellId)}
          key={cellId}
          rowId={rowId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
    debugIds,
    rowId,
  );

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: T1SortedTableProps): any =>
  tableView(
    props,
    useT1SortedRowIds(cellId, descending, offset, limit, props.s),
    T1,
    T1RowView,
  );

export const T1TableView: typeof T1TableViewDecl = (props: T1TableProps): any =>
  tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C1, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C1, forceDel],
    [then, thenDeps],
  );

export const T1C1CellView: typeof T1C1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C2, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C2, forceDel],
    [then, thenDeps],
  );

export const T1C2CellView: typeof T1C2CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C3, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C3, forceDel],
    [then, thenDeps],
  );

export const T1C3CellView: typeof T1C3CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, _, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, _, forceDel],
    [then, thenDeps],
  );

export const T1CellView: typeof T1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _);

export const useTablesListener: typeof useTablesListenerDecl = (
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useSortedRowIdsListenerCore, [
    tableId,
    cellId,
    descending,
    offset,
    limit,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowListener: typeof useRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellIdsListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellListener: typeof useCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
  useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (
  sOrSId?: SOrSId,
): ValueId[] => useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <
  Parameter,
>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValuesCallbackCore,
    [getValues, getValuesDeps],
    [then, thenDeps],
  );

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl =
  <Parameter,>(
    getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
    getPartialValuesDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialValues: ValuesWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialValuesCallbackCore,
      [getPartialValues, getPartialValuesDeps],
      [then, thenDeps],
    );

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): any =>
  wrap(
    useValueIds(s).map((valueId) => {
      const Value =
        valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
      return (
        <Value
          {...getProps(getValueComponentProps, valueId)}
          key={valueId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
  useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V1, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V2, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V3, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [_, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelValueCallback: typeof useDelValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useValue(s) ?? '', undefined, debugIds, _);

export const useValuesListener: typeof useValuesListenerDecl = (
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty keyed value 1`] = `
[
  "import {DoRollback, Id, IdOrNull, Json, Store, ValueChange} from 'tinybase';

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/**
 * A function that takes a Value Id, and value.
 */
export type ValueCallback = (
  ...[valueId, rowCallback]:
    | [valueId: 'v1', value: number]
    | [valueId: 'v2', value: string]
    | [valueId: 'v3', value: string]
    | [valueId: '', value: string]
) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]:
    | [
        s: S,
        valueId: 'v1',
        newValue: number | undefined,
        oldValue: number | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v2',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: 'v3',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
    | [
        s: S,
        valueId: '',
        newValue: string | undefined,
        oldValue: string | undefined,
        getValueChange: GetValueChange | undefined,
      ]
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number | MapNumber): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string | MapString): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string | MapString): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string | MapString): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {DoRollback, Id, IdOrNull, Json, Store, createStore} from 'tinybase';
import {
  InvalidValueListener,
  MapNumber,
  MapString,
  S,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';

export const createS: typeof createSDecl = () => {
  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setValuesSchema({
    [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
    [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
    [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
    [_]: {[TYPE]: STRING},
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number | MapNumber): S =>
      fluent(() => store.setValue(V1, value as any)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V2, value as any)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V3, value as any)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string | MapString): S =>
      fluent(() => store.setValue(_, value as any)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';
import {
  MapNumber,
  MapString,
  S,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders a Value.
 */
export type ValueProps = {readonly s?: S; readonly debugIds?: boolean};

/**
 * The props passed to a component that renders the keyed value content of the
 * Store.
 */
export type ValuesProps = {
  readonly s?: S;
  readonly valueComponents?: {
    v1?: ComponentType<ValueProps>;
    v2?: ComponentType<ValueProps>;
    v3?: ComponentType<ValueProps>;
    ''?: ComponentType<ValueProps>;
  };
  readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the keyed value content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useValues(sOrSId?: SOrSId): Values;

/**
 * Gets the Ids of the Values in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/**
 * Gets a callback that can set the keyed value content of the Store, based on a
 * parameter.
 */
export function useSetValuesCallback<Parameter>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the keyed value content of the Store,
 * based on a parameter.
 */
export function useSetPartialValuesCallback<Parameter>(
  getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getPartialValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialValues: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the keyed value content of the Store.
 */
export function useDelValuesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the keyed value content of the Store, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function ValuesView({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): ComponentReturnType;

/**
 * Gets the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV1Value(sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'v1' Value, based on a parameter.
 */
export function useSetV1ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v1' Value.
 */
export function useDelV1ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V1ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV2Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v2' Value, based on a parameter.
 */
export function useSetV2ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v2' Value.
 */
export function useDelV2ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V2ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV3Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v3' Value, based on a parameter.
 */
export function useSetV3ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v3' Value.
 */
export function useDelV3ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V3ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Gets the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useValue(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the '' Value, based on a parameter.
 */
export function useSetValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Value.
 */
export function useDelValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the keyed value content of
 * the Store changes.
 */
export function useValuesListener(
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Value Ids in the Store
 * change.
 */
export function useValueIdsListener(
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Value in the Store
 * changes.
 */
export function useValueListener(
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {
  ExtraProps,
  useDelValueCallback as useDelValueCallbackCore,
  useDelValuesCallback as useDelValuesCallbackCore,
  useSetPartialValuesCallback as useSetPartialValuesCallbackCore,
  useSetValueCallback as useSetValueCallbackCore,
  useSetValuesCallback as useSetValuesCallbackCore,
  useValue as useValueCore,
  useValueIds as useValueIdsCore,
  useValueIdsListener as useValueIdsListenerCore,
  useValueListener as useValueListenerCore,
  useValues as useValuesCore,
  useValuesListener as useValuesListenerCore,
} from 'tinybase/ui-react';
import {
  MapNumber,
  MapString,
  S,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  V1ValueView as V1ValueViewDecl,
  V2ValueView as V2ValueViewDecl,
  V3ValueView as V3ValueViewDecl,
  ValueProps,
  ValueView as ValueViewDecl,
  ValuesProps,
  ValuesView as ValuesViewDecl,
  useCreateS as useCreateSDecl,
  useDelV1ValueCallback as useDelV1ValueCallbackDecl,
  useDelV2ValueCallback as useDelV2ValueCallbackDecl,
  useDelV3ValueCallback as useDelV3ValueCallbackDecl,
  useDelValueCallback as useDelValueCallbackDecl,
  useDelValuesCallback as useDelValuesCallbackDecl,
  useS as useSDecl,
  useSetPartialValuesCallback as useSetPartialValuesCallbackDecl,
  useSetV1ValueCallback as useSetV1ValueCallbackDecl,
  useSetV2ValueCallback as useSetV2ValueCallbackDecl,
  useSetV3ValueCallback as useSetV3ValueCallbackDecl,
  useSetValueCallback as useSetValueCallbackDecl,
  useSetValuesCallback as useSetValuesCallbackDecl,
  useV1Value as useV1ValueDecl,
  useV2Value as useV2ValueDecl,
  useV3Value as useV3ValueDecl,
  useValue as useValueDecl,
  useValueIds as useValueIdsDecl,
  useValueIdsListener as useValueIdsListenerDecl,
  useValueListener as useValueListenerDecl,
  useValues as useValuesDecl,
  useValuesListener as useValuesListenerDecl,
} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const getDefaultValueComponent = (valueId: Id) =>
  valueId == V1
    ? V1ValueView
    : valueId == V2
    ? V2ValueView
    : valueId == V3
    ? V3ValueView
    : valueId == _
    ? ValueView
    : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
  useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (
  sOrSId?: SOrSId,
): ValueId[] => useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <
  Parameter,
>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValuesCallbackCore,
    [getValues, getValuesDeps],
    [then, thenDeps],
  );

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl =
  <Parameter,>(
    getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
    getPartialValuesDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialValues: ValuesWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialValuesCallbackCore,
      [getPartialValues, getPartialValuesDeps],
      [then, thenDeps],
    );

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): any =>
  wrap(
    useValueIds(s).map((valueId) => {
      const Value =
        valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
      return (
        <Value
          {...getProps(getValueComponentProps, valueId)}
          key={valueId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
  useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V1, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V2, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V3, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [_, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelValueCallback: typeof useDelValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps): any => wrap('' + useValue(s) ?? '', undefined, debugIds, _);

export const useValuesListener: typeof useValuesListenerDecl = (
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table Id in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table Id in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

/**
 * Represents the 't1' Table.
 */
export type T1Table = Table<'t1'>;

/**
 * Represents the 't1' Table when setting it.
 */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = Row<'t1'>;

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = CellId<'t1'>;

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = CellCallback<'t1'>;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = RowCallback<'t1'>;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the sorted Row Ids in a Table.
 */
export type SortedRowIdsListener = (
  s: S,
  tableId: TableId,
  cellId: Id | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  sortedRowIds: Ids,
) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * Cell args for CellListener.
 */
type CellListenerArgsArrayInner<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId>
  ? [
      s: S,
      tableId: TId,
      rowId: Id,
      cellId: CId,
      newCell: Cell<TId, CId> | undefined,
      oldCell: Cell<TId, CId> | undefined,
      getCellChange: GetCellChange | undefined,
    ]
  : never;

/**
 * Table args for CellListener.
 */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? CellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[
    s,
    tableId,
    rowId,
    cellId,
    newCell,
    oldCell,
    getCellChange,
  ]: CellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  cellsTouched: boolean,
  valuesTouched: boolean,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1TableWhenSet): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Adds a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the sorted Row Ids in a
   * Table change.
   */
  addSortedRowIdsListener(
    tableId: TableId,
    cellId: Id | undefined,
    descending: boolean,
    offset: number,
    limit: number | undefined,
    listener: SortedRowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(json: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellIdsListener,
  CellListener,
  InvalidCellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCallback,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  TransactionListener,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setTablesSchema({
    [T1]: {
      [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    },
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: TablesWhenSet): S =>
      fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1TableWhenSet): S =>
      fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addSortedRowIdsListener: (
      tableId: TableId,
      cellId: Id | undefined,
      descending: boolean,
      offset: number,
      limit: number | undefined,
      listener: SortedRowIdsListener,
      mutator?: boolean,
    ): Id =>
      store.addSortedRowIdsListener(
        tableId,
        cellId,
        descending,
        offset,
        limit,
        proxy(listener),
        mutator,
      ),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getJson: (): Json => store.getJson() as Json,

    setJson: (json: Json): S => fluent(() => store.setJson(json)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders the tabular content of the
 * Store.
 */
export type TablesProps = {
  readonly s?: S;
  readonly tableComponents?: {t1?: ComponentType<T1TableProps>};
  readonly getTableComponentProps?: (tableId: TableId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Cell.
 */
export type CellProps = {
  readonly rowId: Id;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the specified Row in the 't1'
 * Table.
 */
export type T1RowProps = {
  readonly rowId: Id;
  readonly s?: S;
  readonly cellComponents?: {
    c1?: ComponentType<CellProps>;
    c2?: ComponentType<CellProps>;
    c3?: ComponentType<CellProps>;
    ''?: ComponentType<CellProps>;
  };
  readonly getCellComponentProps?: (cellId: T1CellId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the 't1' Table.
 */
export type T1TableProps = {
  readonly s?: S;
  readonly rowComponent?: ComponentType<T1RowProps>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the 't1' Table, sorted.
 */
export type T1SortedTableProps = {
  readonly cellId?: T1CellId;
  readonly descending?: boolean;
  readonly offset?: number;
  readonly limit?: number;
  readonly s?: S;
  readonly rowComponent?: ComponentType<T1RowProps>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/**
 * Gets a callback that can set the tabular content of the Store, based on a
 * parameter.
 */
export function useSetTablesCallback<Parameter>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the tabular content of the Store.
 */
export function useDelTablesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the tabular content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function TablesView({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): ComponentReturnType;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/**
 * Gets a callback that can set the content of the 't1' Table, based on a
 * parameter.
 */
export function useSetT1TableCallback<Parameter>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the 't1' Table.
 */
export function useDelT1TableCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Gets a callback that can set the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1RowCallback<Parameter>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can add the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useAddT1RowCallback<Parameter>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the content of the specified Row in the
 * 't1' Table, based on a parameter.
 */
export function useSetT1PartialRowCallback<Parameter>(
  rowId: Id,
  getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getPartialRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialRow: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the specified Row in the 't1'
 * Table.
 */
export function useDelT1RowCallback(
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1RowView({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  separator,
  debugIds,
}: T1RowProps): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, sorted, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function T1SortedTableView({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: T1SortedTableProps): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function T1TableView(props: T1TableProps): ComponentReturnType;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'c1' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c1' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C1CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c2' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C2CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c2' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C2CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C2CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c3' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C3CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c3' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C3CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C3CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Gets a callback that can set the '' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Cell for the specified Row in the 't1'
 * Table.
 */
export function useDelT1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1CellView({
  rowId,
  s,
  debugIds,
}: CellProps): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the tabular content of the
 * Store changes.
 */
export function useTablesListener(
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Table Ids in the Store
 * change.
 */
export function useTableIdsListener(
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Table in the Store
 * changes.
 */
export function useTableListener(
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Row Ids in a Table
 * change.
 */
export function useRowIdsListener(
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the sorted Row Ids in a
 * Table change.
 */
export function useSortedRowIdsListener(
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Row in a Table changes.
 */
export function useRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids in a Row
 * change.
 */
export function useCellIdsListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Cell in a Row changes.
 */
export function useCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  MapNumber,
  MapString,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
} from './s.d';
import {
  CellProps,
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  T1C1CellView as T1C1CellViewDecl,
  T1C2CellView as T1C2CellViewDecl,
  T1C3CellView as T1C3CellViewDecl,
  T1CellView as T1CellViewDecl,
  T1RowProps,
  T1RowView as T1RowViewDecl,
  T1SortedTableProps,
  T1SortedTableView as T1SortedTableViewDecl,
  T1TableProps,
  T1TableView as T1TableViewDecl,
  TablesProps,
  TablesView as TablesViewDecl,
  useAddT1RowCallback as useAddT1RowCallbackDecl,
  useCellIdsListener as useCellIdsListenerDecl,
  useCellListener as useCellListenerDecl,
  useCreateS as useCreateSDecl,
  useDelT1C1CellCallback as useDelT1C1CellCallbackDecl,
  useDelT1C2CellCallback as useDelT1C2CellCallbackDecl,
  useDelT1C3CellCallback as useDelT1C3CellCallbackDecl,
  useDelT1CellCallback as useDelT1CellCallbackDecl,
  useDelT1RowCallback as useDelT1RowCallbackDecl,
  useDelT1TableCallback as useDelT1TableCallbackDecl,
  useDelTablesCallback as useDelTablesCallbackDecl,
  useRowIdsListener as useRowIdsListenerDecl,
  useRowListener as useRowListenerDecl,
  useS as useSDecl,
  useSetT1C1CellCallback as useSetT1C1CellCallbackDecl,
  useSetT1C2CellCallback as useSetT1C2CellCallbackDecl,
  useSetT1C3CellCallback as useSetT1C3CellCallbackDecl,
  useSetT1CellCallback as useSetT1CellCallbackDecl,
  useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl,
  useSetT1RowCallback as useSetT1RowCallbackDecl,
  useSetT1TableCallback as useSetT1TableCallbackDecl,
  useSetTablesCallback as useSetTablesCallbackDecl,
  useSortedRowIdsListener as useSortedRowIdsListenerDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1Table as useT1TableDecl,
  useTableIds as useTableIdsDecl,
  useTableIdsListener as useTableIdsListenerDecl,
  useTableListener as useTableListenerDecl,
  useTables as useTablesDecl,
  useTablesListener as useTablesListenerDecl,
} from './s-ui-react.d';
import {
  ExtraProps,
  useAddRowCallback as useAddRowCallbackCore,
  useCell as useCellCore,
  useCellIds as useCellIdsCore,
  useCellIdsListener as useCellIdsListenerCore,
  useCellListener as useCellListenerCore,
  useDelCellCallback as useDelCellCallbackCore,
  useDelRowCallback as useDelRowCallbackCore,
  useDelTableCallback as useDelTableCallbackCore,
  useDelTablesCallback as useDelTablesCallbackCore,
  useRow as useRowCore,
  useRowIds as useRowIdsCore,
  useRowIdsListener as useRowIdsListenerCore,
  useRowListener as useRowListenerCore,
  useSetCellCallback as useSetCellCallbackCore,
  useSetPartialRowCallback as useSetPartialRowCallbackCore,
  useSetRowCallback as useSetRowCallbackCore,
  useSetTableCallback as useSetTableCallbackCore,
  useSetTablesCallback as useSetTablesCallbackCore,
  useSortedRowIds as useSortedRowIdsCore,
  useSortedRowIdsListener as useSortedRowIdsListenerCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTableIdsListener as useTableIdsListenerCore,
  useTableListener as useTableListenerCore,
  useTables as useTablesCore,
  useTablesListener as useTablesListenerCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const tableView = (
  {s, rowComponent, getRowComponentProps, separator, debugIds}: any,
  rowIds: Ids,
  tableId: Id,
  defaultRowComponent: React.ComponentType<any>,
) => {
  const Row = rowComponent ?? defaultRowComponent;
  return wrap(
    rowIds.map((rowId) => (
      <Row
        {...getProps(getRowComponentProps, rowId)}
        key={rowId}
        tableId={tableId}
        rowId={rowId}
        s={s}
        debugIds={debugIds}
      />
    )),
    separator,
    debugIds,
    tableId,
  );
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) =>
  tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) =>
  tableId == T1
    ? cellId == C1
      ? T1C1CellView
      : cellId == C2
      ? T1C2CellView
      : cellId == C3
      ? T1C3CellView
      : cellId == _
      ? T1CellView
      : NullComponent
    : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (
  sOrSId?: SOrSId,
): TableId[] => useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <
  Parameter,
>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTablesCallbackCore,
    [getTables, getTablesDeps],
    [then, thenDeps],
  );

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): any =>
  wrap(
    useTableIds(s).map((tableId) => {
      const Table =
        tableComponents?.[tableId] ?? getDefaultTableComponent(tableId);
      return (
        <Table
          {...getProps(getTableComponentProps, tableId)}
          key={tableId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1CellId[] => useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <
  Parameter,
>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTableCallbackCore,
    [T1, getTable, getTableDeps],
    [then, thenDeps],
  );

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetRowCallbackCore,
    [T1, rowId, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useAddRowCallbackCore,
    [T1, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl =
  <Parameter,>(
    rowId: Id,
    getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
    getPartialRowDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialRow: T1RowWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialRowCallbackCore,
      [T1, rowId, getPartialRow, getPartialRowDeps],
      [then, thenDeps],
    );

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  separator,
  debugIds,
}: T1RowProps): any =>
  wrap(
    useT1CellIds(rowId, s).map((cellId) => {
      const Cell =
        cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId);
      return (
        <Cell
          {...getProps(getCellComponentProps, cellId)}
          key={cellId}
          rowId={rowId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
    debugIds,
    rowId,
  );

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: T1SortedTableProps): any =>
  tableView(
    props,
    useT1SortedRowIds(cellId, descending, offset, limit, props.s),
    T1,
    T1RowView,
  );

export const T1TableView: typeof T1TableViewDecl = (props: T1TableProps): any =>
  tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C1, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C1, forceDel],
    [then, thenDeps],
  );

export const T1C1CellView: typeof T1C1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C2, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C2, forceDel],
    [then, thenDeps],
  );

export const T1C2CellView: typeof T1C2CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C3, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C3, forceDel],
    [then, thenDeps],
  );

export const T1C3CellView: typeof T1C3CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, _, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, _, forceDel],
    [then, thenDeps],
  );

export const T1CellView: typeof T1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps): any =>
  wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _);

export const useTablesListener: typeof useTablesListenerDecl = (
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useSortedRowIdsListenerCore, [
    tableId,
    cellId,
    descending,
    offset,
    limit,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowListener: typeof useRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellIdsListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellListener: typeof useCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Unpretty both 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store, ValueChange} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table Id in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table Id in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

/** Represents the 't1' Table. */
export type T1Table = Table<'t1'>;

/** Represents the 't1' Table when setting it. */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = Row<'t1'>;

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/** A Cell Id for the 't1' Table. */
export type T1CellId = CellId<'t1'>;

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = CellCallback<'t1'>;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = RowCallback<'t1'>;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the sorted Row Ids in a Table. */
export type SortedRowIdsListener = (s: S, tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, sortedRowIds: Ids) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** Cell args for CellListener. */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, newCell: Cell<TId, CId>  | undefined, oldCell: Cell<TId, CId>  | undefined, getCellChange: GetCellChange  | undefined] : never;

/** Table args for CellListener. */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? CellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: CellListenerArgsArrayOuter) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string] | [valueId: 'v3', value: string] | [valueId: '', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v3', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: '', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1TableWhenSet): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
addSortedRowIdsListener(tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number | MapNumber): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string | MapString): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string | MapString): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string | MapString): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, InvalidValueListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, T1TableWhenSet, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
})
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: TablesWhenSet): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1TableWhenSet): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addSortedRowIdsListener: (tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id => store.addSortedRowIdsListener(tableId, cellId, descending, offset, limit, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number | MapNumber): S => fluent(() => store.setValue(V1, value as any)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string | MapString): S => fluent(() => store.setValue(V2, value as any)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string | MapString): S => fluent(() => store.setValue(V3, value as any)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string | MapString): S => fluent(() => store.setValue(_, value as any)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders the tabular content of the Store. */
export type TablesProps = {readonly s?: S; readonly tableComponents?: {'t1'?: ComponentType<T1TableProps>}; readonly getTableComponentProps?: (tableId: TableId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Cell. */
export type CellProps = {readonly rowId: Id; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the specified Row in the 't1' Table. */
export type T1RowProps = {readonly rowId: Id; readonly s?: S; readonly cellComponents?: {'c1'?: ComponentType<CellProps>, 'c2'?: ComponentType<CellProps>, 'c3'?: ComponentType<CellProps>, ''?: ComponentType<CellProps>}; readonly getCellComponentProps?: (cellId: T1CellId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the 't1' Table. */
export type T1TableProps = {readonly s?: S; readonly rowComponent?: ComponentType<T1RowProps>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the 't1' Table, sorted. */
export type T1SortedTableProps = {readonly cellId?: T1CellId; readonly descending?: boolean; readonly offset?: number; readonly limit?: number; readonly s?: S; readonly rowComponent?: ComponentType<T1RowProps>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Value. */
export type ValueProps = {readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the keyed value content of the Store. */
export type ValuesProps = {readonly s?: S; readonly valueComponents?: {'v1'?: ComponentType<ValueProps>, 'v2'?: ComponentType<ValueProps>, 'v3'?: ComponentType<ValueProps>, ''?: ComponentType<ValueProps>}; readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/** Gets a callback that can set the tabular content of the Store, based on a parameter. */
export function useSetTablesCallback<Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the tabular content of the Store. */
export function useDelTablesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function TablesView({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): ComponentReturnType;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/** Gets a callback that can set the content of the 't1' Table, based on a parameter. */
export function useSetT1TableCallback<Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the 't1' Table. */
export function useDelT1TableCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Gets a callback that can set the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1RowCallback<Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can add the content of the specified Row in the 't1' Table, based on a parameter. */
export function useAddT1RowCallback<Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1PartialRowCallback<Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the specified Row in the 't1' Table. */
export function useDelT1RowCallback(rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1RowView({rowId, s, cellComponents, getCellComponentProps, separator, debugIds}: T1RowProps): ComponentReturnType;

/** Renders the content of the 't1' Table, sorted, and registers a listener so that any changes to that result will cause a re-render. */
export function T1SortedTableView({cellId, descending, offset, limit, ...props}: T1SortedTableProps): ComponentReturnType;

/** Renders the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1TableView(props: T1TableProps): ComponentReturnType;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'c1' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c1' Cell for the specified Row in the 't1' Table. */
export function useDelT1C1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C1CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c2' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C2CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c2' Cell for the specified Row in the 't1' Table. */
export function useDelT1C2CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C2CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c3' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C3CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c3' Cell for the specified Row in the 't1' Table. */
export function useDelT1C3CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C3CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Gets a callback that can set the '' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Cell for the specified Row in the 't1' Table. */
export function useDelT1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
export function useTablesListener(listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
export function useTableIdsListener(listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Table in the Store changes. */
export function useTableListener(tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
export function useRowIdsListener(tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
export function useSortedRowIdsListener(tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Row in a Table changes. */
export function useRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
export function useCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
export function useCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Gets the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValues(sOrSId?: SOrSId): Values;

/** Gets the Ids of the Values in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/** Gets a callback that can set the keyed value content of the Store, based on a parameter. */
export function useSetValuesCallback<Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the keyed value content of the Store, based on a parameter. */
export function useSetPartialValuesCallback<Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the keyed value content of the Store. */
export function useDelValuesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function ValuesView({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): ComponentReturnType;

/** Gets the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV1Value(sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'v1' Value, based on a parameter. */
export function useSetV1ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v1' Value. */
export function useDelV1ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V1ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV2Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v2' Value, based on a parameter. */
export function useSetV2ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v2' Value. */
export function useDelV2ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V2ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV3Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v3' Value, based on a parameter. */
export function useSetV3ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v3' Value. */
export function useDelV3ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V3ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useValue(sOrSId?: SOrSId): string;

/** Gets a callback that can set the '' Value, based on a parameter. */
export function useSetValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Value. */
export function useDelValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
export function useValuesListener(listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
export function useValueIdsListener(listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Value in the Store changes. */
export function useValueListener(valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {CellProps, Provider as ProviderDecl, ProviderProps, SOrSId, T1C1CellView as T1C1CellViewDecl, T1C2CellView as T1C2CellViewDecl, T1C3CellView as T1C3CellViewDecl, T1CellView as T1CellViewDecl, T1RowProps, T1RowView as T1RowViewDecl, T1SortedTableProps, T1SortedTableView as T1SortedTableViewDecl, T1TableProps, T1TableView as T1TableViewDecl, TablesProps, TablesView as TablesViewDecl, V1ValueView as V1ValueViewDecl, V2ValueView as V2ValueViewDecl, V3ValueView as V3ValueViewDecl, ValueProps, ValueView as ValueViewDecl, ValuesProps, ValuesView as ValuesViewDecl, useAddT1RowCallback as useAddT1RowCallbackDecl, useCellIdsListener as useCellIdsListenerDecl, useCellListener as useCellListenerDecl, useCreateS as useCreateSDecl, useDelT1C1CellCallback as useDelT1C1CellCallbackDecl, useDelT1C2CellCallback as useDelT1C2CellCallbackDecl, useDelT1C3CellCallback as useDelT1C3CellCallbackDecl, useDelT1CellCallback as useDelT1CellCallbackDecl, useDelT1RowCallback as useDelT1RowCallbackDecl, useDelT1TableCallback as useDelT1TableCallbackDecl, useDelTablesCallback as useDelTablesCallbackDecl, useDelV1ValueCallback as useDelV1ValueCallbackDecl, useDelV2ValueCallback as useDelV2ValueCallbackDecl, useDelV3ValueCallback as useDelV3ValueCallbackDecl, useDelValueCallback as useDelValueCallbackDecl, useDelValuesCallback as useDelValuesCallbackDecl, useRowIdsListener as useRowIdsListenerDecl, useRowListener as useRowListenerDecl, useS as useSDecl, useSetPartialValuesCallback as useSetPartialValuesCallbackDecl, useSetT1C1CellCallback as useSetT1C1CellCallbackDecl, useSetT1C2CellCallback as useSetT1C2CellCallbackDecl, useSetT1C3CellCallback as useSetT1C3CellCallbackDecl, useSetT1CellCallback as useSetT1CellCallbackDecl, useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl, useSetT1RowCallback as useSetT1RowCallbackDecl, useSetT1TableCallback as useSetT1TableCallbackDecl, useSetTablesCallback as useSetTablesCallbackDecl, useSetV1ValueCallback as useSetV1ValueCallbackDecl, useSetV2ValueCallback as useSetV2ValueCallbackDecl, useSetV3ValueCallback as useSetV3ValueCallbackDecl, useSetValueCallback as useSetValueCallbackDecl, useSetValuesCallback as useSetValuesCallbackDecl, useSortedRowIdsListener as useSortedRowIdsListenerDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1Table as useT1TableDecl, useTableIds as useTableIdsDecl, useTableIdsListener as useTableIdsListenerDecl, useTableListener as useTableListenerDecl, useTables as useTablesDecl, useTablesListener as useTablesListenerDecl, useV1Value as useV1ValueDecl, useV2Value as useV2ValueDecl, useV3Value as useV3ValueDecl, useValue as useValueDecl, useValueIds as useValueIdsDecl, useValueIdsListener as useValueIdsListenerDecl, useValueListener as useValueListenerDecl, useValues as useValuesDecl, useValuesListener as useValuesListenerDecl} from './s-ui-react.d';
import {ExtraProps, useAddRowCallback as useAddRowCallbackCore, useCell as useCellCore, useCellIds as useCellIdsCore, useCellIdsListener as useCellIdsListenerCore, useCellListener as useCellListenerCore, useDelCellCallback as useDelCellCallbackCore, useDelRowCallback as useDelRowCallbackCore, useDelTableCallback as useDelTableCallbackCore, useDelTablesCallback as useDelTablesCallbackCore, useDelValueCallback as useDelValueCallbackCore, useDelValuesCallback as useDelValuesCallbackCore, useRow as useRowCore, useRowIds as useRowIdsCore, useRowIdsListener as useRowIdsListenerCore, useRowListener as useRowListenerCore, useSetCellCallback as useSetCellCallbackCore, useSetPartialRowCallback as useSetPartialRowCallbackCore, useSetPartialValuesCallback as useSetPartialValuesCallbackCore, useSetRowCallback as useSetRowCallbackCore, useSetTableCallback as useSetTableCallbackCore, useSetTablesCallback as useSetTablesCallbackCore, useSetValueCallback as useSetValueCallbackCore, useSetValuesCallback as useSetValuesCallbackCore, useSortedRowIds as useSortedRowIdsCore, useSortedRowIdsListener as useSortedRowIdsListenerCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTableIdsListener as useTableIdsListenerCore, useTableListener as useTableListenerCore, useTables as useTablesCore, useTablesListener as useTablesListenerCore, useValue as useValueCore, useValueIds as useValueIdsCore, useValueIdsListener as useValueIdsListenerCore, useValueListener as useValueListenerCore, useValues as useValuesCore, useValuesListener as useValuesListenerCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const tableView = ({s, rowComponent, getRowComponentProps, separator, debugIds}: any, rowIds: Ids, tableId: Id, defaultRowComponent: React.ComponentType<any>) => {
const Row = rowComponent ?? defaultRowComponent;
return wrap(rowIds.map((rowId) => (
<Row
{...getProps(getRowComponentProps, rowId)}
key={rowId}
tableId={tableId}
rowId={rowId}
s={s}
debugIds={debugIds}
/>
))
, separator, debugIds
, tableId,
);
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) => tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) => tableId == T1 ? cellId == C1 ? T1C1CellView : cellId == C2 ? T1C2CellView : cellId == C3 ? T1C3CellView : cellId == _ ? T1CellView : NullComponent : NullComponent;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const getDefaultValueComponent = (valueId: Id) => valueId == V1 ? V1ValueView : valueId == V2 ? V2ValueView : valueId == V3 ? V3ValueView : valueId == _ ? ValueView : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId[] =>
useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTablesCallbackCore, [getTables, getTablesDeps], [then, thenDeps]);

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): any =>
wrap(useTableIds(s).map((tableId) => {
const Table = tableComponents?.[tableId] ?? getDefaultTableComponent(tableId);
return <Table
{...getProps(getTableComponentProps, tableId)}
key={tableId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): T1CellId[] =>
useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTableCallbackCore, [T1, getTable, getTableDeps], [then, thenDeps]);

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetRowCallbackCore, [T1, rowId, getRow, getRowDeps], [then, thenDeps]);

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useAddRowCallbackCore, [T1, getRow, getRowDeps], [then, thenDeps]);

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl = <Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialRowCallbackCore, [T1, rowId, getPartialRow, getPartialRowDeps], [then, thenDeps]);

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({rowId, s, cellComponents, getCellComponentProps, separator, debugIds}: T1RowProps): any =>
wrap(useT1CellIds(rowId, s).map((cellId) => {
const Cell = cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId);
return <Cell
{...getProps(getCellComponentProps, cellId)} 
key={cellId}
rowId={rowId}
s={s}
debugIds={debugIds}
/>;
}), separator, debugIds, rowId)

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({cellId, descending, offset, limit, ...props}: T1SortedTableProps): any =>
tableView(props, useT1SortedRowIds(cellId, descending, offset, limit, props.s), T1, T1RowView);

export const T1TableView: typeof T1TableViewDecl = (props: T1TableProps): any =>
tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C1, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C1, forceDel], [then, thenDeps]);

export const T1C1CellView: typeof T1C1CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1)

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C2, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C2, forceDel], [then, thenDeps]);

export const T1C2CellView: typeof T1C2CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2)

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C3, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C3, forceDel], [then, thenDeps]);

export const T1C3CellView: typeof T1C3CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3)

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, _, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, _, forceDel], [then, thenDeps]);

export const T1CellView: typeof T1CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _)

export const useTablesListener: typeof useTablesListenerDecl = (listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useSortedRowIdsListenerCore, [tableId, cellId, descending, offset, limit, listener, listenerDeps, mutator]);

export const useRowListener: typeof useRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellIdsListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellListener: typeof useCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (sOrSId?: SOrSId): ValueId[] =>
useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValuesCallbackCore, [getValues, getValuesDeps], [then, thenDeps]);

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl = <Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialValuesCallbackCore, [getPartialValues, getPartialValuesDeps], [then, thenDeps]);

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): any =>
wrap(useValueIds(s).map((valueId) => {
const Value = valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
return <Value
{...getProps(getValueComponentProps, valueId)}
key={valueId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V1, getValue, getValueDeps], [then, thenDeps]);

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1)

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V2, getValue, getValueDeps], [then, thenDeps]);

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2)

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V3, getValue, getValueDeps], [then, thenDeps]);

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3)

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [_, getValue, getValueDeps], [then, thenDeps]);

export const useDelValueCallback: typeof useDelValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useValue(s) ?? '', undefined, debugIds, _)

export const useValuesListener: typeof useValuesListenerDecl = (listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty keyed value 1`] = `
[
  "import {DoRollback, Id, IdOrNull, Json, Store, ValueChange} from 'tinybase';

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

/** A Value Id in the Store. */
export type ValueId = 'v1' | 'v2' | 'v3' | '';

/** A function that takes a Value Id, and value. */
export type ValueCallback = (...[valueId, rowCallback]: [valueId: 'v1', value: number] | [valueId: 'v2', value: string] | [valueId: 'v3', value: string] | [valueId: '', value: string]) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: [s: S, valueId: 'v1', newValue: number | undefined, oldValue: number | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v2', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: 'v3', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined] | [s: S, valueId: '', newValue: string | undefined, oldValue: string | undefined, getValueChange: GetValueChange | undefined]) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number | MapNumber): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string | MapString): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string | MapString): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string | MapString): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {DoRollback, Id, IdOrNull, Json, Store, createStore} from 'tinybase';
import {InvalidValueListener, MapNumber, MapString, S, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';

export const createS: typeof createSDecl = () => {
const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number | MapNumber): S => fluent(() => store.setValue(V1, value as any)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string | MapString): S => fluent(() => store.setValue(V2, value as any)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string | MapString): S => fluent(() => store.setValue(V3, value as any)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string | MapString): S => fluent(() => store.setValue(_, value as any)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';
import {MapNumber, MapString, S, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders a Value. */
export type ValueProps = {readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the keyed value content of the Store. */
export type ValuesProps = {readonly s?: S; readonly valueComponents?: {'v1'?: ComponentType<ValueProps>, 'v2'?: ComponentType<ValueProps>, 'v3'?: ComponentType<ValueProps>, ''?: ComponentType<ValueProps>}; readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValues(sOrSId?: SOrSId): Values;

/** Gets the Ids of the Values in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/** Gets a callback that can set the keyed value content of the Store, based on a parameter. */
export function useSetValuesCallback<Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the keyed value content of the Store, based on a parameter. */
export function useSetPartialValuesCallback<Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the keyed value content of the Store. */
export function useDelValuesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function ValuesView({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): ComponentReturnType;

/** Gets the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV1Value(sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'v1' Value, based on a parameter. */
export function useSetV1ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v1' Value. */
export function useDelV1ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V1ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV2Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v2' Value, based on a parameter. */
export function useSetV2ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v2' Value. */
export function useDelV2ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V2ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV3Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v3' Value, based on a parameter. */
export function useSetV3ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v3' Value. */
export function useDelV3ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V3ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Gets the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useValue(sOrSId?: SOrSId): string;

/** Gets a callback that can set the '' Value, based on a parameter. */
export function useSetValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Value. */
export function useDelValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function ValueView({s, debugIds}: ValueProps): ComponentReturnType;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
export function useValuesListener(listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
export function useValueIdsListener(listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Value in the Store changes. */
export function useValueListener(valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ExtraProps, useDelValueCallback as useDelValueCallbackCore, useDelValuesCallback as useDelValuesCallbackCore, useSetPartialValuesCallback as useSetPartialValuesCallbackCore, useSetValueCallback as useSetValueCallbackCore, useSetValuesCallback as useSetValuesCallbackCore, useValue as useValueCore, useValueIds as useValueIdsCore, useValueIdsListener as useValueIdsListenerCore, useValueListener as useValueListenerCore, useValues as useValuesCore, useValuesListener as useValuesListenerCore} from 'tinybase/ui-react';
import {MapNumber, MapString, S, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {Provider as ProviderDecl, ProviderProps, SOrSId, V1ValueView as V1ValueViewDecl, V2ValueView as V2ValueViewDecl, V3ValueView as V3ValueViewDecl, ValueProps, ValueView as ValueViewDecl, ValuesProps, ValuesView as ValuesViewDecl, useCreateS as useCreateSDecl, useDelV1ValueCallback as useDelV1ValueCallbackDecl, useDelV2ValueCallback as useDelV2ValueCallbackDecl, useDelV3ValueCallback as useDelV3ValueCallbackDecl, useDelValueCallback as useDelValueCallbackDecl, useDelValuesCallback as useDelValuesCallbackDecl, useS as useSDecl, useSetPartialValuesCallback as useSetPartialValuesCallbackDecl, useSetV1ValueCallback as useSetV1ValueCallbackDecl, useSetV2ValueCallback as useSetV2ValueCallbackDecl, useSetV3ValueCallback as useSetV3ValueCallbackDecl, useSetValueCallback as useSetValueCallbackDecl, useSetValuesCallback as useSetValuesCallbackDecl, useV1Value as useV1ValueDecl, useV2Value as useV2ValueDecl, useV3Value as useV3ValueDecl, useValue as useValueDecl, useValueIds as useValueIdsDecl, useValueIdsListener as useValueIdsListenerDecl, useValueListener as useValueListenerDecl, useValues as useValuesDecl, useValuesListener as useValuesListenerDecl} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const getDefaultValueComponent = (valueId: Id) => valueId == V1 ? V1ValueView : valueId == V2 ? V2ValueView : valueId == V3 ? V3ValueView : valueId == _ ? ValueView : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (sOrSId?: SOrSId): ValueId[] =>
useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValuesCallbackCore, [getValues, getValuesDeps], [then, thenDeps]);

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl = <Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialValuesCallbackCore, [getPartialValues, getPartialValuesDeps], [then, thenDeps]);

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): any =>
wrap(useValueIds(s).map((valueId) => {
const Value = valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
return <Value
{...getProps(getValueComponentProps, valueId)}
key={valueId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V1, getValue, getValueDeps], [then, thenDeps]);

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1)

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V2, getValue, getValueDeps], [then, thenDeps]);

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2)

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V3, getValue, getValueDeps], [then, thenDeps]);

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3)

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [_, getValue, getValueDeps], [then, thenDeps]);

export const useDelValueCallback: typeof useDelValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({s, debugIds}: ValueProps): any =>
wrap('' + useValue(s) ?? '', undefined, debugIds, _)

export const useValuesListener: typeof useValuesListenerDecl = (listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty tabular 1`] = `
[
  "import {CellChange, DoRollback, Id, IdOrNull, Ids, Json, Store} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table Id in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table Id in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

/** Represents the 't1' Table. */
export type T1Table = Table<'t1'>;

/** Represents the 't1' Table when setting it. */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = Row<'t1'>;

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/** A Cell Id for the 't1' Table. */
export type T1CellId = CellId<'t1'>;

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = CellCallback<'t1'>;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = RowCallback<'t1'>;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the sorted Row Ids in a Table. */
export type SortedRowIdsListener = (s: S, tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, sortedRowIds: Ids) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** Cell args for CellListener. */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, newCell: Cell<TId, CId>  | undefined, oldCell: Cell<TId, CId>  | undefined, getCellChange: GetCellChange  | undefined] : never;

/** Table args for CellListener. */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? CellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: CellListenerArgsArrayOuter) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, cellsTouched: boolean, valuesTouched: boolean) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1TableWhenSet): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Adds a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
addSortedRowIdsListener(tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(json: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback,): S;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellIdsListener, CellListener, InvalidCellListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, T1TableWhenSet, TableCallback, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, TransactionListener, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: TablesWhenSet): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1TableWhenSet): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet): Id | undefined => store.addRow(T1, row),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addSortedRowIdsListener: (tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id => store.addSortedRowIdsListener(tableId, cellId, descending, offset, limit, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getJson: (): Json => store.getJson() as Json,

setJson: (json: Json): S => fluent(() => store.setJson(json)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback,): S => fluent(() => store.finishTransaction(doRollback)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders the tabular content of the Store. */
export type TablesProps = {readonly s?: S; readonly tableComponents?: {'t1'?: ComponentType<T1TableProps>}; readonly getTableComponentProps?: (tableId: TableId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Cell. */
export type CellProps = {readonly rowId: Id; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the specified Row in the 't1' Table. */
export type T1RowProps = {readonly rowId: Id; readonly s?: S; readonly cellComponents?: {'c1'?: ComponentType<CellProps>, 'c2'?: ComponentType<CellProps>, 'c3'?: ComponentType<CellProps>, ''?: ComponentType<CellProps>}; readonly getCellComponentProps?: (cellId: T1CellId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the 't1' Table. */
export type T1TableProps = {readonly s?: S; readonly rowComponent?: ComponentType<T1RowProps>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the 't1' Table, sorted. */
export type T1SortedTableProps = {readonly cellId?: T1CellId; readonly descending?: boolean; readonly offset?: number; readonly limit?: number; readonly s?: S; readonly rowComponent?: ComponentType<T1RowProps>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/** Gets a callback that can set the tabular content of the Store, based on a parameter. */
export function useSetTablesCallback<Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the tabular content of the Store. */
export function useDelTablesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function TablesView({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): ComponentReturnType;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/** Gets a callback that can set the content of the 't1' Table, based on a parameter. */
export function useSetT1TableCallback<Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the 't1' Table. */
export function useDelT1TableCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Gets a callback that can set the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1RowCallback<Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can add the content of the specified Row in the 't1' Table, based on a parameter. */
export function useAddT1RowCallback<Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1PartialRowCallback<Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the specified Row in the 't1' Table. */
export function useDelT1RowCallback(rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1RowView({rowId, s, cellComponents, getCellComponentProps, separator, debugIds}: T1RowProps): ComponentReturnType;

/** Renders the content of the 't1' Table, sorted, and registers a listener so that any changes to that result will cause a re-render. */
export function T1SortedTableView({cellId, descending, offset, limit, ...props}: T1SortedTableProps): ComponentReturnType;

/** Renders the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1TableView(props: T1TableProps): ComponentReturnType;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'c1' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c1' Cell for the specified Row in the 't1' Table. */
export function useDelT1C1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C1CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c2' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C2CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c2' Cell for the specified Row in the 't1' Table. */
export function useDelT1C2CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C2CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c3' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C3CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c3' Cell for the specified Row in the 't1' Table. */
export function useDelT1C3CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C3CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Gets a callback that can set the '' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Cell for the specified Row in the 't1' Table. */
export function useDelT1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1CellView({rowId, s, debugIds}: CellProps): ComponentReturnType;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
export function useTablesListener(listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
export function useTableIdsListener(listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Table in the Store changes. */
export function useTableListener(tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
export function useRowIdsListener(tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
export function useSortedRowIdsListener(tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Row in a Table changes. */
export function useRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
export function useCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
export function useCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, MapNumber, MapString, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet} from './s.d';
import {CellProps, Provider as ProviderDecl, ProviderProps, SOrSId, T1C1CellView as T1C1CellViewDecl, T1C2CellView as T1C2CellViewDecl, T1C3CellView as T1C3CellViewDecl, T1CellView as T1CellViewDecl, T1RowProps, T1RowView as T1RowViewDecl, T1SortedTableProps, T1SortedTableView as T1SortedTableViewDecl, T1TableProps, T1TableView as T1TableViewDecl, TablesProps, TablesView as TablesViewDecl, useAddT1RowCallback as useAddT1RowCallbackDecl, useCellIdsListener as useCellIdsListenerDecl, useCellListener as useCellListenerDecl, useCreateS as useCreateSDecl, useDelT1C1CellCallback as useDelT1C1CellCallbackDecl, useDelT1C2CellCallback as useDelT1C2CellCallbackDecl, useDelT1C3CellCallback as useDelT1C3CellCallbackDecl, useDelT1CellCallback as useDelT1CellCallbackDecl, useDelT1RowCallback as useDelT1RowCallbackDecl, useDelT1TableCallback as useDelT1TableCallbackDecl, useDelTablesCallback as useDelTablesCallbackDecl, useRowIdsListener as useRowIdsListenerDecl, useRowListener as useRowListenerDecl, useS as useSDecl, useSetT1C1CellCallback as useSetT1C1CellCallbackDecl, useSetT1C2CellCallback as useSetT1C2CellCallbackDecl, useSetT1C3CellCallback as useSetT1C3CellCallbackDecl, useSetT1CellCallback as useSetT1CellCallbackDecl, useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl, useSetT1RowCallback as useSetT1RowCallbackDecl, useSetT1TableCallback as useSetT1TableCallbackDecl, useSetTablesCallback as useSetTablesCallbackDecl, useSortedRowIdsListener as useSortedRowIdsListenerDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1Table as useT1TableDecl, useTableIds as useTableIdsDecl, useTableIdsListener as useTableIdsListenerDecl, useTableListener as useTableListenerDecl, useTables as useTablesDecl, useTablesListener as useTablesListenerDecl} from './s-ui-react.d';
import {ExtraProps, useAddRowCallback as useAddRowCallbackCore, useCell as useCellCore, useCellIds as useCellIdsCore, useCellIdsListener as useCellIdsListenerCore, useCellListener as useCellListenerCore, useDelCellCallback as useDelCellCallbackCore, useDelRowCallback as useDelRowCallbackCore, useDelTableCallback as useDelTableCallbackCore, useDelTablesCallback as useDelTablesCallbackCore, useRow as useRowCore, useRowIds as useRowIdsCore, useRowIdsListener as useRowIdsListenerCore, useRowListener as useRowListenerCore, useSetCellCallback as useSetCellCallbackCore, useSetPartialRowCallback as useSetPartialRowCallbackCore, useSetRowCallback as useSetRowCallbackCore, useSetTableCallback as useSetTableCallbackCore, useSetTablesCallback as useSetTablesCallbackCore, useSortedRowIds as useSortedRowIdsCore, useSortedRowIdsListener as useSortedRowIdsListenerCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTableIdsListener as useTableIdsListenerCore, useTableListener as useTableListenerCore, useTables as useTablesCore, useTablesListener as useTablesListenerCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const NullComponent = () => null;

const tableView = ({s, rowComponent, getRowComponentProps, separator, debugIds}: any, rowIds: Ids, tableId: Id, defaultRowComponent: React.ComponentType<any>) => {
const Row = rowComponent ?? defaultRowComponent;
return wrap(rowIds.map((rowId) => (
<Row
{...getProps(getRowComponentProps, rowId)}
key={rowId}
tableId={tableId}
rowId={rowId}
s={s}
debugIds={debugIds}
/>
))
, separator, debugIds
, tableId,
);
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) => tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) => tableId == T1 ? cellId == C1 ? T1C1CellView : cellId == C2 ? T1C2CellView : cellId == C3 ? T1C3CellView : cellId == _ ? T1CellView : NullComponent : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId[] =>
useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTablesCallbackCore, [getTables, getTablesDeps], [then, thenDeps]);

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): any =>
wrap(useTableIds(s).map((tableId) => {
const Table = tableComponents?.[tableId] ?? getDefaultTableComponent(tableId);
return <Table
{...getProps(getTableComponentProps, tableId)}
key={tableId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): T1CellId[] =>
useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTableCallbackCore, [T1, getTable, getTableDeps], [then, thenDeps]);

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetRowCallbackCore, [T1, rowId, getRow, getRowDeps], [then, thenDeps]);

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useAddRowCallbackCore, [T1, getRow, getRowDeps], [then, thenDeps]);

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl = <Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialRowCallbackCore, [T1, rowId, getPartialRow, getPartialRowDeps], [then, thenDeps]);

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({rowId, s, cellComponents, getCellComponentProps, separator, debugIds}: T1RowProps): any =>
wrap(useT1CellIds(rowId, s).map((cellId) => {
const Cell = cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId);
return <Cell
{...getProps(getCellComponentProps, cellId)} 
key={cellId}
rowId={rowId}
s={s}
debugIds={debugIds}
/>;
}), separator, debugIds, rowId)

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({cellId, descending, offset, limit, ...props}: T1SortedTableProps): any =>
tableView(props, useT1SortedRowIds(cellId, descending, offset, limit, props.s), T1, T1RowView);

export const T1TableView: typeof T1TableViewDecl = (props: T1TableProps): any =>
tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C1, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C1, forceDel], [then, thenDeps]);

export const T1C1CellView: typeof T1C1CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1)

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C2, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C2, forceDel], [then, thenDeps]);

export const T1C2CellView: typeof T1C2CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2)

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C3, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C3, forceDel], [then, thenDeps]);

export const T1C3CellView: typeof T1C3CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3)

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, _, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, _, forceDel], [then, thenDeps]);

export const T1CellView: typeof T1CellViewDecl = ({rowId, s, debugIds}: CellProps): any =>
wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _)

export const useTablesListener: typeof useTablesListenerDecl = (listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useSortedRowIdsListenerCore, [tableId, cellId, descending, offset, limit, listener, listenerDeps, mutator]);

export const useRowListener: typeof useRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellIdsListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellListener: typeof useCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`Refinements Pretty both 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table Id in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table Id in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

interface Refined {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): Store;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): Store;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): Store;
}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/**
 * Creates a Store object.
 */
export function createStore(): Store;
",
  "export * from 'tinybase/ui-react';
",
]
`;

exports[`Refinements Pretty keyed value 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

interface Refined {
  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): Store;
}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/**
 * Creates a Store object.
 */
export function createStore(): Store;
",
  "export * from 'tinybase/ui-react';
",
]
`;

exports[`Refinements Pretty tabular 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table Id in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table Id in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<
  TId extends TableId,
  CId = CellId<TId>,
> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

interface Refined {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): Store;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): Store;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];
}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/**
 * Creates a Store object.
 */
export function createStore(): Store;
",
  "export * from 'tinybase/ui-react';
",
]
`;

exports[`Refinements Unpretty both 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table Id in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table Id in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

interface Refined {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): Store;

/** Deletes the tabular content of the Store. */
delTables(): Store;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): Store;

}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/** Creates a Store object. */
export function createStore(): Store",
  "export * from 'tinybase/ui-react';",
]
`;

exports[`Refinements Unpretty keyed value 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

interface Refined {
/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): Store;

}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/** Creates a Store object. */
export function createStore(): Store",
  "export * from 'tinybase/ui-react';",
]
`;

exports[`Refinements Unpretty tabular 1`] = `
[
  "export * from 'tinybase';
import {CellChange, Id, Store as StoreCore} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table Id in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table Id in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = keyof NonNullable<Tables[TId]>[Id];

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

interface Refined {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): Store;

/** Deletes the tabular content of the Store. */
delTables(): Store;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

}

export type Store = Omit<StoreCore, keyof Refined> & Refined;

/** Creates a Store object. */
export function createStore(): Store",
  "export * from 'tinybase/ui-react';",
]
`;
