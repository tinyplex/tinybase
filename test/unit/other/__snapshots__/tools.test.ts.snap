// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API Pretty both 1`] = `
[
  "import {
  CellChange,
  DoRollback,
  GetTransactionChanges,
  GetTransactionLog,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  TransactionChanges,
  ValueChange,
} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = Extract<keyof Row<TId>, Id>;

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * A function that takes a Cell Id, and count of how many times it appears.
 */
export type TableCellCallback<TId extends TableId> = (
  cellId: CellId<TId>,
  count: number,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

/**
 * A function for listening to changes to the existence of Tables in the Store.
 */
export type HasTablesListener = (s: S, hasTables: boolean) => void;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to the existence of a Table in the Store.
 */
export type HasTableListener = (
  s: S,
  tableId: TableId,
  hasTable: boolean,
) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids anywhere in a Table.
 */
export type TableCellIdsListener = (s: S, tableId: TableId) => void;

/**
 * Cell args for HasTableCellListener.
 */
type HasTableCellListenerArgsArrayInner<
  TId extends TableId,
  CId = CellId<TId>,
> =
  CId extends CellId<TId>
    ? [s: S, tableId: TId, cellId: CId, hasTableCell: boolean]
    : never;

/**
 * Table args for HasTableCellListener.
 */
type HasTableCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? HasTableCellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to the existence of a Cell anywhere in a
 * Table.
 */
export type HasTableCellListener = (
  ...[s, tableId, cellId, hasTableCell]: HasTableCellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to the number of Rows in a Table.
 */
export type RowCountListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the sorted Row Ids in a Table.
 */
export type SortedRowIdsListener = (
  s: S,
  tableId: TableId,
  cellId: Id | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  sortedRowIds: Ids,
) => void;

/**
 * A function for listening to changes to the existence of a Row in a Table.
 */
export type HasRowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  hasRow: boolean,
) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * Cell args for HasCellListener.
 */
type HasCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId>
    ? [s: S, tableId: TId, rowId: Id, cellId: CId, hasCell: boolean]
    : never;

/**
 * Table args for HasCellListener.
 */
type HasCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? HasCellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to the existence of a Cell in a Row.
 */
export type HasCellListener = (
  ...[s, tableId, rowId, cellId, hasCell]: HasCellListenerArgsArrayOuter
) => void;

/**
 * Cell args for CellListener.
 */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId>
    ? [
        s: S,
        tableId: TId,
        rowId: Id,
        cellId: CId,
        newCell: Cell<TId, CId> | undefined,
        oldCell: Cell<TId, CId> | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    : never;

/**
 * Table args for CellListener.
 */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? CellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[
    s,
    tableId,
    rowId,
    cellId,
    newCell,
    oldCell,
    getCellChange,
  ]: CellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Represents the 't1' Table.
 */
export type T1Table = Table<'t1'>;

/**
 * Represents the 't1' Table when setting it.
 */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = Row<'t1'>;

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = CellId<'t1'>;

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = CellCallback<'t1'>;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = RowCallback<'t1'>;

/**
 * A function that takes a Cell Id from anywhere in the 't1' Table, and a count
 * of how many times it appears.
 */
export type T1TableCellCallback = TableCellCallback<'t1'>;

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = keyof Values;

/**
 * A Value Id in the Store.
 */
export type Value<VId extends ValueId> = NonNullable<Values[VId]>;

/**
 * Value Ids and types in the Store.
 */
type ValueIdValueArray<VId = ValueId> = VId extends ValueId
  ? [valueId: VId, value: Value<VId>]
  : never;

/**
 * A function that takes a Value Id, and Value.
 */
export type ValueCallback = (...[valueId, value]: ValueIdValueArray) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to the existence of Values in the Store.
 */
export type HasValuesListener = (s: S, hasValues: boolean) => void;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to the existence of a Value in the Store.
 */
export type HasValueListener = (
  s: S,
  valueId: ValueId,
  hasValue: boolean,
) => void;

/**
 * Value args for ValueListener.
 */
type ValueListenerArgsArray<VId = ValueId> = VId extends ValueId
  ? [
      s: S,
      valueId: VId,
      newValue: Value<VId> | undefined,
      oldValue: Value<VId> | undefined,
      getValueChange: GetValueChange | undefined,
    ]
  : never;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]: ValueListenerArgsArray
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  getTransactionChanges: GetTransactionChanges,
  getTransactionLog: GetTransactionLog,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1TableWhenSet): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Cells in the whole of the 't1' Table.
   */
  getT1TableCellIds(): Ids;

  /**
   * Calls a function for each TableCell in the whole of the 't1' Table.
   */
  forEachT1TableCell(tableCellCallback: T1TableCellCallback): void;

  /**
   * Gets the number of Rows in the the 't1' Table.
   */
  getT1RowCount(): number;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Add a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet, reuseIds?: boolean): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c1' Cell anywhere in the 't1' Table.
   */
  hasT1C1TableCell(): boolean;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c2' Cell anywhere in the 't1' Table.
   */
  hasT1C2TableCell(): boolean;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c3' Cell anywhere in the 't1' Table.
   */
  hasT1C3TableCell(): boolean;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Checks existence of the '' Cell anywhere in the 't1' Table.
   */
  hasT1TableCell(): boolean;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the existence of the
   * tabular content of the Store changes.
   */
  addHasTablesListener(listener: HasTablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Table
   * in the Store changes.
   */
  addHasTableListener(
    tableId: TableId | null,
    listener: HasTableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids anywhere in
   * a Table change.
   */
  addTableCellIdsListener(
    tableId: TableId | null,
    listener: TableCellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Cell
   * anywhere in a Table changes.
   */
  addHasTableCellListener(
    tableId: TableId | null,
    cellId: T1CellId | null,
    listener: HasTableCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the number of Rows in a
   * Table changes.
   */
  addRowCountListener(
    tableId: TableId | null,
    listener: RowCountListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the sorted Row Ids in a
   * Table change.
   */
  addSortedRowIdsListener<TId extends TableId>(
    tableId: TId,
    cellId: CellId<TId> | undefined,
    descending: boolean,
    offset: number,
    limit: number | undefined,
    listener: SortedRowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Row in
   * a Table changes.
   */
  addHasRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: HasRowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Cell
   * in a Row changes.
   */
  addHasCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: HasCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number | MapNumber): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string | MapString): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string | MapString): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string | MapString): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the existence of the
   * keyed value content of the Store changes.
   */
  addHasValuesListener(listener: HasValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Value
   * in the Store changes.
   */
  addHasValueListener(
    valueId: ValueId | null,
    listener: HasValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the content of the Store.
   */
  getContent(): [Tables, Values];

  /**
   * Sets the content of the Store.
   */
  setContent([tables, values]: [Tables, Values]): S;

  /**
   * Applies a set of TransactionChanges to the Store.
   */
  applyChanges(changes: TransactionChanges): S;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(tablesAndValuesJson: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the start of the
   * transaction.
   */
  addStartTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellId,
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  HasValueListener,
  HasValuesListener,
  InvalidCellListener,
  InvalidValueListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  T1TableCellCallback,
  T1TableWhenSet,
  TableCallback,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  TransactionChanges,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const store = createStore()
    .setTablesSchema({
      [T1]: {
        [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
        [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
        [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
        [_]: {[TYPE]: STRING},
      },
    })
    .setValuesSchema({
      [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: TablesWhenSet): S =>
      fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1TableWhenSet): S =>
      fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1TableCellIds: (): Ids => store.getTableCellIds(T1) as Ids,

    forEachT1TableCell: (tableCellCallback: T1TableCellCallback): void =>
      store.forEachTableCell(T1, tableCellCallback as any),

    getT1RowCount: (): number => store.getRowCount(T1) as number,

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet, reuseIds?: boolean): Id | undefined =>
      store.addRow(T1, row, reuseIds),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    hasT1C1TableCell: (): boolean => store.hasTableCell(T1, C1),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    hasT1C2TableCell: (): boolean => store.hasTableCell(T1, C2),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    hasT1C3TableCell: (): boolean => store.hasTableCell(T1, C3),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    hasT1TableCell: (): boolean => store.hasTableCell(T1, _),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addHasTablesListener: (
      listener: HasTablesListener,
      mutator?: boolean,
    ): Id => store.addHasTablesListener(proxy(listener), mutator),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addHasTableListener: (
      tableId: TableId | null,
      listener: HasTableListener,
      mutator?: boolean,
    ): Id => store.addHasTableListener(tableId, proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addTableCellIdsListener: (
      tableId: TableId | null,
      listener: TableCellIdsListener,
      mutator?: boolean,
    ): Id => store.addTableCellIdsListener(tableId, proxy(listener), mutator),

    addHasTableCellListener: (
      tableId: TableId | null,
      cellId: T1CellId | null,
      listener: HasTableCellListener,
      mutator?: boolean,
    ): Id =>
      store.addHasTableCellListener(tableId, cellId, proxy(listener), mutator),

    addRowCountListener: (
      tableId: TableId | null,
      listener: RowCountListener,
      mutator?: boolean,
    ): Id => store.addRowCountListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addSortedRowIdsListener: <TId extends TableId>(
      tableId: TId,
      cellId: CellId<TId> | undefined,
      descending: boolean,
      offset: number,
      limit: number | undefined,
      listener: SortedRowIdsListener,
      mutator?: boolean,
    ): Id =>
      store.addSortedRowIdsListener(
        tableId,
        cellId,
        descending,
        offset,
        limit,
        proxy(listener),
        mutator,
      ),

    addHasRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: HasRowListener,
      mutator?: boolean,
    ): Id => store.addHasRowListener(tableId, rowId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addHasCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: HasCellListener,
      mutator?: boolean,
    ): Id =>
      store.addHasCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number | MapNumber): S =>
      fluent(() => store.setValue(V1, value as any)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V2, value as any)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V3, value as any)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string | MapString): S =>
      fluent(() => store.setValue(_, value as any)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addHasValuesListener: (
      listener: HasValuesListener,
      mutator?: boolean,
    ): Id => store.addHasValuesListener(proxy(listener), mutator),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addHasValueListener: (
      valueId: ValueId | null,
      listener: HasValueListener,
      mutator?: boolean,
    ): Id => store.addHasValueListener(valueId, proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

    setContent: ([tables, values]: [Tables, Values]): S =>
      fluent(() => store.setContent([tables, values])),

    applyChanges: (changes: TransactionChanges): S =>
      fluent(() => store.applyChanges(changes)),

    getJson: (): Json => store.getJson() as Json,

    setJson: (tablesAndValuesJson: Json): S =>
      fluent(() => store.setJson(tablesAndValuesJson)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addStartTransactionListener: (listener: TransactionListener): Id =>
      store.addStartTransactionListener(proxy(listener)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellId,
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  HasValueListener,
  HasValuesListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders a Cell.
 */
export type CellProps<TId extends TableId, CId extends CellId<TId>> = {
  readonly tableId?: TId;
  readonly rowId: Id;
  readonly cellId?: CId;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Row.
 */
export type RowProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly rowId: Id;
  readonly s?: S;
  readonly cellComponents?: {
    readonly [CId in CellId<TId>]?: ComponentType<CellProps<TId, CId>>;
  };
  readonly getCellComponentProps?: (cellId: CellId<TId>) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Table.
 */
export type TableProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly s?: S;
  readonly rowComponent?: ComponentType<RowProps<TId>>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a sorted Table.
 */
export type SortedTableProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly cellId?: CellId<TId>;
  readonly descending?: boolean;
  readonly offset?: number;
  readonly limit?: number;
  readonly s?: S;
  readonly rowComponent?: ComponentType<RowProps<TId>>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the tabular content of the
 * Store.
 */
export type TablesProps = {
  readonly s?: S;
  readonly tableComponents?: {
    readonly [TId in TableId]?: ComponentType<TableProps<TId>>;
  };
  readonly getTableComponentProps?: (tableId: TableId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Value.
 */
export type ValueProps<VId extends ValueId> = {
  readonly valueId?: VId;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the keyed value content of the
 * Store.
 */
export type ValuesProps = {
  readonly s?: S;
  readonly valueComponents?: {
    readonly [VId in ValueId]?: ComponentType<ValueProps<VId>>;
  };
  readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the existence of the tabular content of the Store, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasTables(sOrSId?: SOrSId): boolean;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/**
 * Gets a callback that can set the tabular content of the Store, based on a
 * parameter.
 */
export function useSetTablesCallback<Parameter>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the tabular content of the Store.
 */
export function useDelTablesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the tabular content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function TablesView({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): ComponentReturnType;

/**
 * Gets the existence of the content of the 't1' Table, and registers a listener
 * so that any changes to that result will cause a re-render.
 */
export function useHasT1Table(sOrSId?: SOrSId): boolean;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Cells in the whole of the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1TableCellIds(sOrSId?: SOrSId): Ids;

/**
 * Gets the number of Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowCount(sOrSId?: SOrSId): number;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the existence of the content of the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1Row(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/**
 * Gets a callback that can set the content of the 't1' Table, based on a
 * parameter.
 */
export function useSetT1TableCallback<Parameter>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the 't1' Table.
 */
export function useDelT1TableCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Gets a callback that can set the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1RowCallback<Parameter>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can add the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useAddT1RowCallback<Parameter>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
  reuseRowIds?: boolean,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the content of the specified Row in the
 * 't1' Table, based on a parameter.
 */
export function useSetT1PartialRowCallback<Parameter>(
  rowId: Id,
  getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getPartialRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialRow: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the specified Row in the 't1'
 * Table.
 */
export function useDelT1RowCallback(
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1RowView({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  customCellIds,
  separator,
  debugIds,
}: RowProps<'t1'>): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, sorted, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function T1SortedTableView({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: SortedTableProps<'t1'>): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function T1TableView(props: TableProps<'t1'>): ComponentReturnType;

/**
 * Gets the existence of the 'c1' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C1TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c1' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'c1' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c1' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C1CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c1'>): ComponentReturnType;

/**
 * Gets the existence of the 'c2' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C2TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c2' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C2Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c2' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C2CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c2' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C2CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C2CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c2'>): ComponentReturnType;

/**
 * Gets the existence of the 'c3' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C3TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c3' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C3Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c3' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C3CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c3' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C3CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C3CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c3'>): ComponentReturnType;

/**
 * Gets the existence of the '' Cell anywhere in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasT1TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the '' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Gets a callback that can set the '' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Cell for the specified Row in the 't1'
 * Table.
 */
export function useDelT1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', ''>): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the existence of the
 * tabular content of the Store changes.
 */
export function useHasTablesListener(
  listener: HasTablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the tabular content of the
 * Store changes.
 */
export function useTablesListener(
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Table Ids in the Store
 * change.
 */
export function useTableIdsListener(
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Table in
 * the Store changes.
 */
export function useHasTableListener(
  tableId: TableId | null,
  listener: HasTableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Table in the Store
 * changes.
 */
export function useTableListener(
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids anywhere in a
 * Table change.
 */
export function useTableCellIdsListener(
  tableId: TableId | null,
  listener: TableCellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Cell
 * anywhere in a Table changes.
 */
export function useHasTableCellListener(
  tableId: TableId | null,
  cellId: T1CellId | null,
  listener: HasTableCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the number of Rows in a
 * Table changes.
 */
export function useRowCountListener(
  tableId: TableId | null,
  listener: RowCountListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Row Ids in a Table
 * change.
 */
export function useRowIdsListener(
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the sorted Row Ids in a
 * Table change.
 */
export function useSortedRowIdsListener(
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Row in a
 * Table changes.
 */
export function useHasRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: HasRowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Row in a Table changes.
 */
export function useRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids in a Row
 * change.
 */
export function useCellIdsListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Cell in
 * a Row changes.
 */
export function useHasCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: HasCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Cell in a Row changes.
 */
export function useCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Gets the existence of the keyed value content of the Store, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasValues(sOrSId?: SOrSId): boolean;

/**
 * Gets the keyed value content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useValues(sOrSId?: SOrSId): Values;

/**
 * Gets the Ids of the Values in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/**
 * Gets a callback that can set the keyed value content of the Store, based on a
 * parameter.
 */
export function useSetValuesCallback<Parameter>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the keyed value content of the Store,
 * based on a parameter.
 */
export function useSetPartialValuesCallback<Parameter>(
  getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getPartialValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialValues: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the keyed value content of the Store.
 */
export function useDelValuesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the keyed value content of the Store, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function ValuesView({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): ComponentReturnType;

/**
 * Gets the existence of the 'v1' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV1Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV1Value(sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'v1' Value, based on a parameter.
 */
export function useSetV1ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v1' Value.
 */
export function useDelV1ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V1ValueView({
  s,
  debugIds,
}: ValueProps<'v1'>): ComponentReturnType;

/**
 * Gets the existence of the 'v2' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV2Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV2Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v2' Value, based on a parameter.
 */
export function useSetV2ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v2' Value.
 */
export function useDelV2ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V2ValueView({
  s,
  debugIds,
}: ValueProps<'v2'>): ComponentReturnType;

/**
 * Gets the existence of the 'v3' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV3Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV3Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v3' Value, based on a parameter.
 */
export function useSetV3ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v3' Value.
 */
export function useDelV3ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V3ValueView({
  s,
  debugIds,
}: ValueProps<'v3'>): ComponentReturnType;

/**
 * Gets the existence of the '' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasValue(sOrSId?: SOrSId): boolean;

/**
 * Gets the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useValue(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the '' Value, based on a parameter.
 */
export function useSetValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Value.
 */
export function useDelValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function ValueView({s, debugIds}: ValueProps<''>): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the existence of the keyed
 * value content of the Store changes.
 */
export function useHasValuesListener(
  listener: HasValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the keyed value content of
 * the Store changes.
 */
export function useValuesListener(
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Value Ids in the Store
 * change.
 */
export function useValueIdsListener(
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Value in
 * the Store changes.
 */
export function useHasValueListener(
  valueId: ValueId | null,
  listener: HasValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Value in the Store
 * changes.
 */
export function useValueListener(
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  HasValueListener,
  HasValuesListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {
  CellProps,
  Provider as ProviderDecl,
  ProviderProps,
  RowProps,
  SOrSId,
  SortedTableProps,
  T1C1CellView as T1C1CellViewDecl,
  T1C2CellView as T1C2CellViewDecl,
  T1C3CellView as T1C3CellViewDecl,
  T1CellView as T1CellViewDecl,
  T1RowView as T1RowViewDecl,
  T1SortedTableView as T1SortedTableViewDecl,
  T1TableView as T1TableViewDecl,
  TableProps,
  TablesProps,
  TablesView as TablesViewDecl,
  V1ValueView as V1ValueViewDecl,
  V2ValueView as V2ValueViewDecl,
  V3ValueView as V3ValueViewDecl,
  ValueProps,
  ValueView as ValueViewDecl,
  ValuesProps,
  ValuesView as ValuesViewDecl,
  useAddT1RowCallback as useAddT1RowCallbackDecl,
  useCellIdsListener as useCellIdsListenerDecl,
  useCellListener as useCellListenerDecl,
  useCreateS as useCreateSDecl,
  useDelT1C1CellCallback as useDelT1C1CellCallbackDecl,
  useDelT1C2CellCallback as useDelT1C2CellCallbackDecl,
  useDelT1C3CellCallback as useDelT1C3CellCallbackDecl,
  useDelT1CellCallback as useDelT1CellCallbackDecl,
  useDelT1RowCallback as useDelT1RowCallbackDecl,
  useDelT1TableCallback as useDelT1TableCallbackDecl,
  useDelTablesCallback as useDelTablesCallbackDecl,
  useDelV1ValueCallback as useDelV1ValueCallbackDecl,
  useDelV2ValueCallback as useDelV2ValueCallbackDecl,
  useDelV3ValueCallback as useDelV3ValueCallbackDecl,
  useDelValueCallback as useDelValueCallbackDecl,
  useDelValuesCallback as useDelValuesCallbackDecl,
  useHasCellListener as useHasCellListenerDecl,
  useHasRowListener as useHasRowListenerDecl,
  useHasT1C1Cell as useHasT1C1CellDecl,
  useHasT1C1TableCell as useHasT1C1TableCellDecl,
  useHasT1C2Cell as useHasT1C2CellDecl,
  useHasT1C2TableCell as useHasT1C2TableCellDecl,
  useHasT1C3Cell as useHasT1C3CellDecl,
  useHasT1C3TableCell as useHasT1C3TableCellDecl,
  useHasT1Cell as useHasT1CellDecl,
  useHasT1Row as useHasT1RowDecl,
  useHasT1TableCell as useHasT1TableCellDecl,
  useHasT1Table as useHasT1TableDecl,
  useHasTableCellListener as useHasTableCellListenerDecl,
  useHasTableListener as useHasTableListenerDecl,
  useHasTables as useHasTablesDecl,
  useHasTablesListener as useHasTablesListenerDecl,
  useHasV1Value as useHasV1ValueDecl,
  useHasV2Value as useHasV2ValueDecl,
  useHasV3Value as useHasV3ValueDecl,
  useHasValue as useHasValueDecl,
  useHasValueListener as useHasValueListenerDecl,
  useHasValues as useHasValuesDecl,
  useHasValuesListener as useHasValuesListenerDecl,
  useRowCountListener as useRowCountListenerDecl,
  useRowIdsListener as useRowIdsListenerDecl,
  useRowListener as useRowListenerDecl,
  useS as useSDecl,
  useSetPartialValuesCallback as useSetPartialValuesCallbackDecl,
  useSetT1C1CellCallback as useSetT1C1CellCallbackDecl,
  useSetT1C2CellCallback as useSetT1C2CellCallbackDecl,
  useSetT1C3CellCallback as useSetT1C3CellCallbackDecl,
  useSetT1CellCallback as useSetT1CellCallbackDecl,
  useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl,
  useSetT1RowCallback as useSetT1RowCallbackDecl,
  useSetT1TableCallback as useSetT1TableCallbackDecl,
  useSetTablesCallback as useSetTablesCallbackDecl,
  useSetV1ValueCallback as useSetV1ValueCallbackDecl,
  useSetV2ValueCallback as useSetV2ValueCallbackDecl,
  useSetV3ValueCallback as useSetV3ValueCallbackDecl,
  useSetValueCallback as useSetValueCallbackDecl,
  useSetValuesCallback as useSetValuesCallbackDecl,
  useSortedRowIdsListener as useSortedRowIdsListenerDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1RowCount as useT1RowCountDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1TableCellIds as useT1TableCellIdsDecl,
  useT1Table as useT1TableDecl,
  useTableCellIdsListener as useTableCellIdsListenerDecl,
  useTableIds as useTableIdsDecl,
  useTableIdsListener as useTableIdsListenerDecl,
  useTableListener as useTableListenerDecl,
  useTables as useTablesDecl,
  useTablesListener as useTablesListenerDecl,
  useV1Value as useV1ValueDecl,
  useV2Value as useV2ValueDecl,
  useV3Value as useV3ValueDecl,
  useValue as useValueDecl,
  useValueIds as useValueIdsDecl,
  useValueIdsListener as useValueIdsListenerDecl,
  useValueListener as useValueListenerDecl,
  useValues as useValuesDecl,
  useValuesListener as useValuesListenerDecl,
} from './s-ui-react.d';
import {
  ExtraProps,
  useAddRowCallback as useAddRowCallbackCore,
  useCell as useCellCore,
  useCellIds,
  useCellIds as useCellIdsCore,
  useCellIdsListener as useCellIdsListenerCore,
  useCellListener as useCellListenerCore,
  useDelCellCallback as useDelCellCallbackCore,
  useDelRowCallback as useDelRowCallbackCore,
  useDelTableCallback as useDelTableCallbackCore,
  useDelTablesCallback as useDelTablesCallbackCore,
  useDelValueCallback as useDelValueCallbackCore,
  useDelValuesCallback as useDelValuesCallbackCore,
  useHasCell as useHasCellCore,
  useHasCellListener as useHasCellListenerCore,
  useHasRow as useHasRowCore,
  useHasRowListener as useHasRowListenerCore,
  useHasTableCell as useHasTableCellCore,
  useHasTableCellListener as useHasTableCellListenerCore,
  useHasTable as useHasTableCore,
  useHasTableListener as useHasTableListenerCore,
  useHasTables as useHasTablesCore,
  useHasTablesListener as useHasTablesListenerCore,
  useHasValue as useHasValueCore,
  useHasValueListener as useHasValueListenerCore,
  useHasValues as useHasValuesCore,
  useHasValuesListener as useHasValuesListenerCore,
  useRow as useRowCore,
  useRowCount as useRowCountCore,
  useRowCountListener as useRowCountListenerCore,
  useRowIds as useRowIdsCore,
  useRowIdsListener as useRowIdsListenerCore,
  useRowListener as useRowListenerCore,
  useSetCellCallback as useSetCellCallbackCore,
  useSetPartialRowCallback as useSetPartialRowCallbackCore,
  useSetPartialValuesCallback as useSetPartialValuesCallbackCore,
  useSetRowCallback as useSetRowCallbackCore,
  useSetTableCallback as useSetTableCallbackCore,
  useSetTablesCallback as useSetTablesCallbackCore,
  useSetValueCallback as useSetValueCallbackCore,
  useSetValuesCallback as useSetValuesCallbackCore,
  useSortedRowIds as useSortedRowIdsCore,
  useSortedRowIdsListener as useSortedRowIdsListenerCore,
  useTableCellIds as useTableCellIdsCore,
  useTableCellIdsListener as useTableCellIdsListenerCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTableIdsListener as useTableIdsListenerCore,
  useTableListener as useTableListenerCore,
  useTables as useTablesCore,
  useTablesListener as useTablesListenerCore,
  useValue as useValueCore,
  useValueIds as useValueIdsCore,
  useValueIdsListener as useValueIdsListenerCore,
  useValueListener as useValueListenerCore,
  useValues as useValuesCore,
  useValuesListener as useValuesListenerCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (
  customCellIds: Ids | undefined,
  tableId: Id,
  rowId: Id,
  sOrSId?: SOrSId | undefined,
) => {
  const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
  return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const tableView = (
  {
    s,
    rowComponent,
    getRowComponentProps,
    customCellIds,
    separator,
    debugIds,
  }: any,
  rowIds: Ids,
  tableId: Id,
  defaultRowComponent: React.ComponentType<any>,
) => {
  const Row = rowComponent ?? defaultRowComponent;
  return wrap(
    rowIds.map((rowId) => (
      <Row
        {...getProps(getRowComponentProps, rowId)}
        key={rowId}
        tableId={tableId}
        rowId={rowId}
        customCellIds={customCellIds}
        s={s}
        debugIds={debugIds}
      />
    )),
    separator,
    debugIds,
    tableId,
  );
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) =>
  tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) =>
  tableId == T1
    ? cellId == C1
      ? T1C1CellView
      : cellId == C2
        ? T1C2CellView
        : cellId == C3
          ? T1C3CellView
          : cellId == _
            ? T1CellView
            : NullComponent
    : NullComponent;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const getDefaultValueComponent = (valueId: Id) =>
  valueId == V1
    ? V1ValueView
    : valueId == V2
      ? V2ValueView
      : valueId == V3
        ? V3ValueView
        : valueId == _
          ? ValueView
          : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useHasTables: typeof useHasTablesDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTablesCore, []);

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (
  sOrSId?: SOrSId,
): TableId[] => useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <
  Parameter,
>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTablesCallbackCore,
    [getTables, getTablesDeps],
    [then, thenDeps],
  );

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): any =>
  wrap(
    useTableIds(s).map((tableId) => {
      const Table = (tableComponents?.[tableId] ??
        getDefaultTableComponent(tableId)) as React.ComponentType<
        TableProps<typeof tableId>
      >;
      return (
        <Table
          {...getProps(getTableComponentProps, tableId)}
          tableId={tableId}
          key={tableId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useHasT1Table: typeof useHasT1TableDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCore, [T1]);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, [T1]);

export const useT1TableCellIds: typeof useT1TableCellIdsDecl = (
  sOrSId?: SOrSId,
): Ids => useHook(sOrSId, useTableCellIdsCore, [T1]);

export const useT1RowCount: typeof useT1RowCountDecl = (
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useRowCountCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useHasT1Row: typeof useHasT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasRowCore, [T1, rowId]);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1CellId[] => useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <
  Parameter,
>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTableCallbackCore,
    [T1, getTable, getTableDeps],
    [then, thenDeps],
  );

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetRowCallbackCore,
    [T1, rowId, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
  reuseRowIds?: boolean,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useAddRowCallbackCore,
    [T1, getRow, getRowDeps],
    [then, thenDeps, reuseRowIds],
  );

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl =
  <Parameter,>(
    rowId: Id,
    getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
    getPartialRowDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialRow: T1RowWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialRowCallbackCore,
      [T1, rowId, getPartialRow, getPartialRowDeps],
      [then, thenDeps],
    );

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  customCellIds,
  separator,
  debugIds,
}: RowProps<'t1'>): any =>
  wrap(
    useCustomOrDefaultCellIds(customCellIds, T1, rowId, s).map(
      (cellId: T1CellId) => {
        const Cell = (cellComponents?.[cellId] ??
          getDefaultCellComponent(T1, cellId)) as React.ComponentType<
          CellProps<typeof T1, typeof cellId>
        >;
        return (
          <Cell
            {...getProps(getCellComponentProps, cellId)}
            key={cellId}
            tableId={T1}
            rowId={rowId}
            cellId={cellId}
            s={s}
            debugIds={debugIds}
          />
        );
      },
    ),
    separator,
    debugIds,
    rowId,
  );

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: SortedTableProps<'t1'>): any =>
  tableView(
    props,
    useT1SortedRowIds(cellId, descending, offset, limit, props.s),
    T1,
    T1RowView,
  );

export const T1TableView: typeof T1TableViewDecl = (
  props: TableProps<'t1'>,
): any => tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useHasT1C1TableCell: typeof useHasT1C1TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C1]);

export const useHasT1C1Cell: typeof useHasT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C1]);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C1, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C1, forceDel],
    [then, thenDeps],
  );

export const T1C1CellView: typeof T1C1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c1'>): any =>
  wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1);

export const useHasT1C2TableCell: typeof useHasT1C2TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C2]);

export const useHasT1C2Cell: typeof useHasT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C2]);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C2, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C2, forceDel],
    [then, thenDeps],
  );

export const T1C2CellView: typeof T1C2CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c2'>): any =>
  wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2);

export const useHasT1C3TableCell: typeof useHasT1C3TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C3]);

export const useHasT1C3Cell: typeof useHasT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C3]);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C3, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C3, forceDel],
    [then, thenDeps],
  );

export const T1C3CellView: typeof T1C3CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c3'>): any =>
  wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3);

export const useHasT1TableCell: typeof useHasT1TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, _]);

export const useHasT1Cell: typeof useHasT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, _]);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, _, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, _, forceDel],
    [then, thenDeps],
  );

export const T1CellView: typeof T1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', ''>): any =>
  wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _);

export const useHasTablesListener: typeof useHasTablesListenerDecl = (
  listener: HasTablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTablesListener: typeof useTablesListenerDecl = (
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasTableListener: typeof useHasTableListenerDecl = (
  tableId: TableId | null,
  listener: HasTableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useTableListener: typeof useTableListenerDecl = (
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useTableCellIdsListener: typeof useTableCellIdsListenerDecl = (
  tableId: TableId | null,
  listener: TableCellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableCellIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasTableCellListener: typeof useHasTableCellListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | null,
  listener: HasTableCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTableCellListenerCore, [
    tableId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowCountListener: typeof useRowCountListenerDecl = (
  tableId: TableId | null,
  listener: RowCountListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowCountListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useSortedRowIdsListenerCore, [
    tableId,
    cellId,
    descending,
    offset,
    limit,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasRowListener: typeof useHasRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: HasRowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowListener: typeof useRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellIdsListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasCellListener: typeof useHasCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: HasCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellListener: typeof useCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasValues: typeof useHasValuesDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValuesCore, []);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
  useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (
  sOrSId?: SOrSId,
): ValueId[] => useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <
  Parameter,
>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValuesCallbackCore,
    [getValues, getValuesDeps],
    [then, thenDeps],
  );

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl =
  <Parameter,>(
    getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
    getPartialValuesDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialValues: ValuesWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialValuesCallbackCore,
      [getPartialValues, getPartialValuesDeps],
      [then, thenDeps],
    );

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): any =>
  wrap(
    useValueIds(s).map((valueId) => {
      const Value =
        valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
      return (
        <Value
          {...getProps(getValueComponentProps, valueId)}
          key={valueId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useHasV1Value: typeof useHasV1ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V1]);

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
  useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V1, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v1'>): any =>
  wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1);

export const useHasV2Value: typeof useHasV2ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V2]);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V2, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v2'>): any =>
  wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2);

export const useHasV3Value: typeof useHasV3ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V3]);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V3, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v3'>): any =>
  wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3);

export const useHasValue: typeof useHasValueDecl = (sOrSId?: SOrSId): boolean =>
  useHook(sOrSId, useHasValueCore, [_]);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [_, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelValueCallback: typeof useDelValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<''>): any => wrap('' + useValue(s) ?? '', undefined, debugIds, _);

export const useHasValuesListener: typeof useHasValuesListenerDecl = (
  listener: HasValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValuesListener: typeof useValuesListenerDecl = (
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasValueListener: typeof useHasValueListenerDecl = (
  valueId: ValueId | null,
  listener: HasValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useValueListener: typeof useValueListenerDecl = (
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty keyed value 1`] = `
[
  "import {
  DoRollback,
  GetTransactionChanges,
  GetTransactionLog,
  Id,
  IdOrNull,
  Json,
  Store,
  Tables,
  TransactionChanges,
  ValueChange,
} from 'tinybase';

/**
 * Represents the keyed value content of the Store.
 */
export type Values = {v1: number; v2: string; v3: string; ''?: string};

/**
 * Represents the keyed value content of the Store when setting it.
 */
export type ValuesWhenSet = {
  v1?: number;
  v2?: string;
  v3?: string;
  ''?: string;
};

/**
 * A Value Id in the Store.
 */
export type ValueId = keyof Values;

/**
 * A Value Id in the Store.
 */
export type Value<VId extends ValueId> = NonNullable<Values[VId]>;

/**
 * Value Ids and types in the Store.
 */
type ValueIdValueArray<VId = ValueId> = VId extends ValueId
  ? [valueId: VId, value: Value<VId>]
  : never;

/**
 * A function that takes a Value Id, and Value.
 */
export type ValueCallback = (...[valueId, value]: ValueIdValueArray) => void;

/**
 * A function for returning information about any Value's changes during a
 * transaction.
 */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/**
 * A function for listening to changes to the existence of Values in the Store.
 */
export type HasValuesListener = (s: S, hasValues: boolean) => void;

/**
 * A function for listening to changes to Values in the Store.
 */
export type ValuesListener = (
  s: S,
  getValueChange: GetValueChange | undefined,
) => void;

/**
 * A function for listening to changes to the Value Ids in the Store.
 */
export type ValueIdsListener = (s: S) => void;

/**
 * A function for listening to changes to the existence of a Value in the Store.
 */
export type HasValueListener = (
  s: S,
  valueId: ValueId,
  hasValue: boolean,
) => void;

/**
 * Value args for ValueListener.
 */
type ValueListenerArgsArray<VId = ValueId> = VId extends ValueId
  ? [
      s: S,
      valueId: VId,
      newValue: Value<VId> | undefined,
      oldValue: Value<VId> | undefined,
      getValueChange: GetValueChange | undefined,
    ]
  : never;

/**
 * A function for listening to changes to a Value in the Store.
 */
export type ValueListener = (
  ...[s, valueId, newValue, oldValue, getValueChange]: ValueListenerArgsArray
) => void;

/**
 * A function for listening to changes to invalid Value changes in the Store.
 */
export type InvalidValueListener = (
  s: S,
  valueId: Id,
  invalidValues: any[],
) => void;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  getTransactionChanges: GetTransactionChanges,
  getTransactionLog: GetTransactionLog,
) => void;

export interface S {
  /**
   * Gets the keyed value content of the Store.
   */
  getValues(): Values;

  /**
   * Checks existence of the keyed value content of the Store.
   */
  hasValues(): boolean;

  /**
   * Sets the keyed value content of the Store.
   */
  setValues(values: ValuesWhenSet): S;

  /**
   * Deletes the keyed value content of the Store.
   */
  delValues(): S;

  /**
   * Sets part of the keyed value content of the Store.
   */
  setPartialValues(partialValues: ValuesWhenSet): S;

  /**
   * Gets the Ids of the Values in the Store.
   */
  getValueIds(): ValueId[];

  /**
   * Calls a function for each Value in the Store.
   */
  forEachValue(valueCallback: ValueCallback): void;

  /**
   * Gets the 'v1' Value.
   */
  getV1Value(): number;

  /**
   * Checks existence of the 'v1' Value.
   */
  hasV1Value(): boolean;

  /**
   * Sets the 'v1' Value.
   */
  setV1Value(value: number | MapNumber): S;

  /**
   * Deletes the 'v1' Value.
   */
  delV1Value(): S;

  /**
   * Gets the 'v2' Value.
   */
  getV2Value(): string;

  /**
   * Checks existence of the 'v2' Value.
   */
  hasV2Value(): boolean;

  /**
   * Sets the 'v2' Value.
   */
  setV2Value(value: string | MapString): S;

  /**
   * Deletes the 'v2' Value.
   */
  delV2Value(): S;

  /**
   * Gets the 'v3' Value.
   */
  getV3Value(): string;

  /**
   * Checks existence of the 'v3' Value.
   */
  hasV3Value(): boolean;

  /**
   * Sets the 'v3' Value.
   */
  setV3Value(value: string | MapString): S;

  /**
   * Deletes the 'v3' Value.
   */
  delV3Value(): S;

  /**
   * Gets the '' Value.
   */
  getValue(): string;

  /**
   * Checks existence of the '' Value.
   */
  hasValue(): boolean;

  /**
   * Sets the '' Value.
   */
  setValue(value: string | MapString): S;

  /**
   * Deletes the '' Value.
   */
  delValue(): S;

  /**
   * Gets a string serialization of the keyed value content of the Store.
   */
  getValuesJson(): Json;

  /**
   * Sets a string serialization of the keyed value content of the Store.
   */
  setValuesJson(valuesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the existence of the
   * keyed value content of the Store changes.
   */
  addHasValuesListener(listener: HasValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the keyed value content
   * of the Store changes.
   */
  addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Value Ids in the
   * Store change.
   */
  addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Value
   * in the Store changes.
   */
  addHasValueListener(
    valueId: ValueId | null,
    listener: HasValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Value in the Store
   * changes.
   */
  addValueListener(
    valueId: ValueId | null,
    listener: ValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Value change
   * was attempted.
   */
  addInvalidValueListener(
    valueId: IdOrNull,
    listener: InvalidValueListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the content of the Store.
   */
  getContent(): [Tables, Values];

  /**
   * Sets the content of the Store.
   */
  setContent([tables, values]: [Tables, Values]): S;

  /**
   * Applies a set of TransactionChanges to the Store.
   */
  applyChanges(changes: TransactionChanges): S;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(tablesAndValuesJson: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the start of the
   * transaction.
   */
  addStartTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  DoRollback,
  Id,
  IdOrNull,
  Json,
  Store,
  Tables,
  TransactionChanges,
  createStore,
} from 'tinybase';
import {
  HasValueListener,
  HasValuesListener,
  InvalidValueListener,
  MapNumber,
  MapString,
  S,
  TransactionListener,
  ValueCallback,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
  createS as createSDecl,
} from './s.d';

export const createS: typeof createSDecl = () => {
  const V1 = 'v1';

  const V2 = 'v2';

  const V3 = 'v3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setValuesSchema({
    [V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
    [V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
    [V3]: {[TYPE]: STRING, [DEFAULT]: _3},
    [_]: {[TYPE]: STRING},
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getValues: (): Values => store.getValues() as Values,

    hasValues: (): boolean => store.hasValues(),

    setValues: (values: ValuesWhenSet): S =>
      fluent(() => store.setValues(values)),

    delValues: (): S => fluent(() => store.delValues()),

    setPartialValues: (partialValues: ValuesWhenSet): S =>
      fluent(() => store.setPartialValues(partialValues)),

    getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

    forEachValue: (valueCallback: ValueCallback): void =>
      store.forEachValue(valueCallback as any),

    getV1Value: (): number => store.getValue(V1) as number,

    hasV1Value: (): boolean => store.hasValue(V1),

    setV1Value: (value: number | MapNumber): S =>
      fluent(() => store.setValue(V1, value as any)),

    delV1Value: (): S => fluent(() => store.delValue(V1)),

    getV2Value: (): string => store.getValue(V2) as string,

    hasV2Value: (): boolean => store.hasValue(V2),

    setV2Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V2, value as any)),

    delV2Value: (): S => fluent(() => store.delValue(V2)),

    getV3Value: (): string => store.getValue(V3) as string,

    hasV3Value: (): boolean => store.hasValue(V3),

    setV3Value: (value: string | MapString): S =>
      fluent(() => store.setValue(V3, value as any)),

    delV3Value: (): S => fluent(() => store.delValue(V3)),

    getValue: (): string => store.getValue(_) as string,

    hasValue: (): boolean => store.hasValue(_),

    setValue: (value: string | MapString): S =>
      fluent(() => store.setValue(_, value as any)),

    delValue: (): S => fluent(() => store.delValue(_)),

    getValuesJson: (): Json => store.getValuesJson() as Json,

    setValuesJson: (valuesJson: Json): S =>
      fluent(() => store.setValuesJson(valuesJson)),

    addHasValuesListener: (
      listener: HasValuesListener,
      mutator?: boolean,
    ): Id => store.addHasValuesListener(proxy(listener), mutator),

    addValuesListener: (listener: ValuesListener, mutator?: boolean): Id =>
      store.addValuesListener(proxy(listener), mutator),

    addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id =>
      store.addValueIdsListener(proxy(listener), mutator),

    addHasValueListener: (
      valueId: ValueId | null,
      listener: HasValueListener,
      mutator?: boolean,
    ): Id => store.addHasValueListener(valueId, proxy(listener), mutator),

    addValueListener: (
      valueId: ValueId | null,
      listener: ValueListener,
      mutator?: boolean,
    ): Id => store.addValueListener(valueId, proxy(listener), mutator),

    addInvalidValueListener: (
      valueId: IdOrNull,
      listener: InvalidValueListener,
      mutator?: boolean,
    ): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

    getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

    setContent: ([tables, values]: [Tables, Values]): S =>
      fluent(() => store.setContent([tables, values])),

    applyChanges: (changes: TransactionChanges): S =>
      fluent(() => store.applyChanges(changes)),

    getJson: (): Json => store.getJson() as Json,

    setJson: (tablesAndValuesJson: Json): S =>
      fluent(() => store.setJson(tablesAndValuesJson)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addStartTransactionListener: (listener: TransactionListener): Id =>
      store.addStartTransactionListener(proxy(listener)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';
import {
  HasValueListener,
  HasValuesListener,
  MapNumber,
  MapString,
  S,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders a Value.
 */
export type ValueProps<VId extends ValueId> = {
  readonly valueId?: VId;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the keyed value content of the
 * Store.
 */
export type ValuesProps = {
  readonly s?: S;
  readonly valueComponents?: {
    readonly [VId in ValueId]?: ComponentType<ValueProps<VId>>;
  };
  readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the existence of the keyed value content of the Store, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasValues(sOrSId?: SOrSId): boolean;

/**
 * Gets the keyed value content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useValues(sOrSId?: SOrSId): Values;

/**
 * Gets the Ids of the Values in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/**
 * Gets a callback that can set the keyed value content of the Store, based on a
 * parameter.
 */
export function useSetValuesCallback<Parameter>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the keyed value content of the Store,
 * based on a parameter.
 */
export function useSetPartialValuesCallback<Parameter>(
  getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getPartialValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialValues: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the keyed value content of the Store.
 */
export function useDelValuesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the keyed value content of the Store, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function ValuesView({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): ComponentReturnType;

/**
 * Gets the existence of the 'v1' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV1Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV1Value(sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'v1' Value, based on a parameter.
 */
export function useSetV1ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v1' Value.
 */
export function useDelV1ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v1' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V1ValueView({
  s,
  debugIds,
}: ValueProps<'v1'>): ComponentReturnType;

/**
 * Gets the existence of the 'v2' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV2Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV2Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v2' Value, based on a parameter.
 */
export function useSetV2ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v2' Value.
 */
export function useDelV2ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v2' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V2ValueView({
  s,
  debugIds,
}: ValueProps<'v2'>): ComponentReturnType;

/**
 * Gets the existence of the 'v3' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasV3Value(sOrSId?: SOrSId): boolean;

/**
 * Gets the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useV3Value(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'v3' Value, based on a parameter.
 */
export function useSetV3ValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'v3' Value.
 */
export function useDelV3ValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'v3' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function V3ValueView({
  s,
  debugIds,
}: ValueProps<'v3'>): ComponentReturnType;

/**
 * Gets the existence of the '' Value, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useHasValue(sOrSId?: SOrSId): boolean;

/**
 * Gets the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function useValue(sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the '' Value, based on a parameter.
 */
export function useSetValueCallback<Parameter>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Value.
 */
export function useDelValueCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Value, and registers a listener so that any changes to that
 * result will cause a re-render.
 */
export function ValueView({s, debugIds}: ValueProps<''>): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the existence of the keyed
 * value content of the Store changes.
 */
export function useHasValuesListener(
  listener: HasValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the keyed value content of
 * the Store changes.
 */
export function useValuesListener(
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Value Ids in the Store
 * change.
 */
export function useValueIdsListener(
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Value in
 * the Store changes.
 */
export function useHasValueListener(
  valueId: ValueId | null,
  listener: HasValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Value in the Store
 * changes.
 */
export function useValueListener(
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {
  ExtraProps,
  useCellIds,
  useDelValueCallback as useDelValueCallbackCore,
  useDelValuesCallback as useDelValuesCallbackCore,
  useHasValue as useHasValueCore,
  useHasValueListener as useHasValueListenerCore,
  useHasValues as useHasValuesCore,
  useHasValuesListener as useHasValuesListenerCore,
  useSetPartialValuesCallback as useSetPartialValuesCallbackCore,
  useSetValueCallback as useSetValueCallbackCore,
  useSetValuesCallback as useSetValuesCallbackCore,
  useValue as useValueCore,
  useValueIds as useValueIdsCore,
  useValueIdsListener as useValueIdsListenerCore,
  useValueListener as useValueListenerCore,
  useValues as useValuesCore,
  useValuesListener as useValuesListenerCore,
} from 'tinybase/ui-react';
import {
  HasValueListener,
  HasValuesListener,
  MapNumber,
  MapString,
  S,
  ValueId,
  ValueIdsListener,
  ValueListener,
  Values,
  ValuesListener,
  ValuesWhenSet,
} from './s.d';
import {
  Provider as ProviderDecl,
  ProviderProps,
  SOrSId,
  V1ValueView as V1ValueViewDecl,
  V2ValueView as V2ValueViewDecl,
  V3ValueView as V3ValueViewDecl,
  ValueProps,
  ValueView as ValueViewDecl,
  ValuesProps,
  ValuesView as ValuesViewDecl,
  useCreateS as useCreateSDecl,
  useDelV1ValueCallback as useDelV1ValueCallbackDecl,
  useDelV2ValueCallback as useDelV2ValueCallbackDecl,
  useDelV3ValueCallback as useDelV3ValueCallbackDecl,
  useDelValueCallback as useDelValueCallbackDecl,
  useDelValuesCallback as useDelValuesCallbackDecl,
  useHasV1Value as useHasV1ValueDecl,
  useHasV2Value as useHasV2ValueDecl,
  useHasV3Value as useHasV3ValueDecl,
  useHasValue as useHasValueDecl,
  useHasValueListener as useHasValueListenerDecl,
  useHasValues as useHasValuesDecl,
  useHasValuesListener as useHasValuesListenerDecl,
  useS as useSDecl,
  useSetPartialValuesCallback as useSetPartialValuesCallbackDecl,
  useSetV1ValueCallback as useSetV1ValueCallbackDecl,
  useSetV2ValueCallback as useSetV2ValueCallbackDecl,
  useSetV3ValueCallback as useSetV3ValueCallbackDecl,
  useSetValueCallback as useSetValueCallbackDecl,
  useSetValuesCallback as useSetValuesCallbackDecl,
  useV1Value as useV1ValueDecl,
  useV2Value as useV2ValueDecl,
  useV3Value as useV3ValueDecl,
  useValue as useValueDecl,
  useValueIds as useValueIdsDecl,
  useValueIdsListener as useValueIdsListenerDecl,
  useValueListener as useValueListenerDecl,
  useValues as useValuesDecl,
  useValuesListener as useValuesListenerDecl,
} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (
  customCellIds: Ids | undefined,
  tableId: Id,
  rowId: Id,
  sOrSId?: SOrSId | undefined,
) => {
  const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
  return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const getDefaultValueComponent = (valueId: Id) =>
  valueId == V1
    ? V1ValueView
    : valueId == V2
      ? V2ValueView
      : valueId == V3
        ? V3ValueView
        : valueId == _
          ? ValueView
          : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useHasValues: typeof useHasValuesDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValuesCore, []);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
  useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (
  sOrSId?: SOrSId,
): ValueId[] => useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <
  Parameter,
>(
  getValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
  getValuesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, values: ValuesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValuesCallbackCore,
    [getValues, getValuesDeps],
    [then, thenDeps],
  );

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl =
  <Parameter,>(
    getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet,
    getPartialValuesDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialValues: ValuesWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialValuesCallbackCore,
      [getPartialValues, getPartialValuesDeps],
      [then, thenDeps],
    );

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({
  s,
  valueComponents,
  getValueComponentProps,
  separator,
  debugIds,
}: ValuesProps): any =>
  wrap(
    useValueIds(s).map((valueId) => {
      const Value =
        valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
      return (
        <Value
          {...getProps(getValueComponentProps, valueId)}
          key={valueId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useHasV1Value: typeof useHasV1ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V1]);

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
  useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => number | MapNumber,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V1, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v1'>): any =>
  wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1);

export const useHasV2Value: typeof useHasV2ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V2]);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V2, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v2'>): any =>
  wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2);

export const useHasV3Value: typeof useHasV3ValueDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasValueCore, [V3]);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <
  Parameter,
>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [V3, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<'v3'>): any =>
  wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3);

export const useHasValue: typeof useHasValueDecl = (sOrSId?: SOrSId): boolean =>
  useHook(sOrSId, useHasValueCore, [_]);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
  useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(
  getValue: (parameter: Parameter, store: Store) => string | MapString,
  getValueDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, value: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetValueCallbackCore,
    [_, getValue, getValueDeps],
    [then, thenDeps],
  );

export const useDelValueCallback: typeof useDelValueCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({
  s,
  debugIds,
}: ValueProps<''>): any => wrap('' + useValue(s) ?? '', undefined, debugIds, _);

export const useHasValuesListener: typeof useHasValuesListenerDecl = (
  listener: HasValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValuesListener: typeof useValuesListenerDecl = (
  listener: ValuesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (
  listener: ValueIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasValueListener: typeof useHasValueListenerDecl = (
  valueId: ValueId | null,
  listener: HasValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useValueListener: typeof useValueListenerDecl = (
  valueId: ValueId | null,
  listener: ValueListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useValueListenerCore, [
    valueId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Pretty tabular 1`] = `
[
  "import {
  CellChange,
  DoRollback,
  GetTransactionChanges,
  GetTransactionLog,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  TransactionChanges,
  Values,
} from 'tinybase';

/**
 * Represents the tabular content of the Store.
 */
export type Tables = {
  t1?: {[rowId: Id]: {c1: number; c2: string; c3: string; ''?: string}};
};

/**
 * Represents the tabular content of the Store when setting it.
 */
export type TablesWhenSet = {
  t1?: {[rowId: Id]: {c1?: number; c2?: string; c3?: string; ''?: string}};
};

/**
 * A Table Id in the Store.
 */
export type TableId = keyof Tables;

/**
 * A Table in the Store.
 */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/**
 * A Table in the Store when setting it.
 */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/**
 * A Row in a Table.
 */
export type Row<TId extends TableId> = Table<TId>[Id];

/**
 * A Row in a Table when setting it.
 */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/**
 * A Cell Id in a Row.
 */
export type CellId<TId extends TableId> = Extract<keyof Row<TId>, Id>;

/**
 * A Cell in a Row.
 */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<
  Tables[TId]
>[Id][CId];

/**
 * Cell Ids and types in a Row.
 */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/**
 * A function that takes a Cell Id, and Cell.
 */
export type CellCallback<TId extends TableId> = (
  ...[cellId, cell]: CellIdCellArray<TId>
) => void;

/**
 * A function that takes a Row Id, and a Cell iterator.
 */
export type RowCallback<TId extends TableId> = (
  rowId: Id,
  forEachCell: (cellCallback: CellCallback<TId>) => void,
) => void;

/**
 * A function that takes a Cell Id, and count of how many times it appears.
 */
export type TableCellCallback<TId extends TableId> = (
  cellId: CellId<TId>,
  count: number,
) => void;

/**
 * Table Ids and callback types.
 */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void]
  : never;

/**
 * A function that takes a Table Id, and a Row iterator.
 */
export type TableCallback = (
  ...[tableId, forEachRow]: TableIdForEachRowArray
) => void;

/**
 * Ids for GetCellChange.
 */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId
  ? [tableId: TId, rowId: Id, cellId: CellId<TId>]
  : never;

/**
 * A function for returning information about any Cell's changes during a
 * transaction.
 */
export type GetCellChange = (
  ...[tableId, rowId, cellId]: TableIdRowIdCellIdArray
) => CellChange;

/**
 * A function for listening to changes to the existence of Tables in the Store.
 */
export type HasTablesListener = (s: S, hasTables: boolean) => void;

/**
 * A function for listening to changes to Tables in the Store.
 */
export type TablesListener = (
  s: S,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Table Ids in the Store.
 */
export type TableIdsListener = (s: S) => void;

/**
 * A function for listening to changes to the existence of a Table in the Store.
 */
export type HasTableListener = (
  s: S,
  tableId: TableId,
  hasTable: boolean,
) => void;

/**
 * A function for listening to changes to a Table in the Store.
 */
export type TableListener = (
  s: S,
  tableId: TableId,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids anywhere in a Table.
 */
export type TableCellIdsListener = (s: S, tableId: TableId) => void;

/**
 * Cell args for HasTableCellListener.
 */
type HasTableCellListenerArgsArrayInner<
  TId extends TableId,
  CId = CellId<TId>,
> =
  CId extends CellId<TId>
    ? [s: S, tableId: TId, cellId: CId, hasTableCell: boolean]
    : never;

/**
 * Table args for HasTableCellListener.
 */
type HasTableCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? HasTableCellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to the existence of a Cell anywhere in a
 * Table.
 */
export type HasTableCellListener = (
  ...[s, tableId, cellId, hasTableCell]: HasTableCellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to the number of Rows in a Table.
 */
export type RowCountListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the Row Ids in a Table.
 */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/**
 * A function for listening to changes to the sorted Row Ids in a Table.
 */
export type SortedRowIdsListener = (
  s: S,
  tableId: TableId,
  cellId: Id | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  sortedRowIds: Ids,
) => void;

/**
 * A function for listening to changes to the existence of a Row in a Table.
 */
export type HasRowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  hasRow: boolean,
) => void;

/**
 * A function for listening to changes to a Row in a Table.
 */
export type RowListener = (
  s: S,
  tableId: TableId,
  rowId: Id,
  getCellChange: GetCellChange | undefined,
) => void;

/**
 * A function for listening to changes to the Cell Ids in a Row.
 */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/**
 * Cell args for HasCellListener.
 */
type HasCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId>
    ? [s: S, tableId: TId, rowId: Id, cellId: CId, hasCell: boolean]
    : never;

/**
 * Table args for HasCellListener.
 */
type HasCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? HasCellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to the existence of a Cell in a Row.
 */
export type HasCellListener = (
  ...[s, tableId, rowId, cellId, hasCell]: HasCellListenerArgsArrayOuter
) => void;

/**
 * Cell args for CellListener.
 */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> =
  CId extends CellId<TId>
    ? [
        s: S,
        tableId: TId,
        rowId: Id,
        cellId: CId,
        newCell: Cell<TId, CId> | undefined,
        oldCell: Cell<TId, CId> | undefined,
        getCellChange: GetCellChange | undefined,
      ]
    : never;

/**
 * Table args for CellListener.
 */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId
  ? CellListenerArgsArrayInner<TId>
  : never;

/**
 * A function for listening to changes to a Cell in a Row.
 */
export type CellListener = (
  ...[
    s,
    tableId,
    rowId,
    cellId,
    newCell,
    oldCell,
    getCellChange,
  ]: CellListenerArgsArrayOuter
) => void;

/**
 * A function for listening to changes to invalid Cell changes in the Store.
 */
export type InvalidCellListener = (
  s: S,
  tableId: Id,
  rowId: Id,
  cellId: Id,
  invalidCells: any[],
) => void;

/**
 * Represents the 't1' Table.
 */
export type T1Table = Table<'t1'>;

/**
 * Represents the 't1' Table when setting it.
 */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/**
 * Represents a Row when getting the content of the 't1' Table.
 */
export type T1Row = Row<'t1'>;

/**
 * Represents a Row when setting the content of the 't1' Table.
 */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/**
 * A Cell Id for the 't1' Table.
 */
export type T1CellId = CellId<'t1'>;

/**
 * A function that takes a Cell Id and value from a Row in the 't1' Table.
 */
export type T1CellCallback = CellCallback<'t1'>;

/**
 * A function that takes a Row Id from the 't1' Table, and a Cell iterator.
 */
export type T1RowCallback = RowCallback<'t1'>;

/**
 * A function that takes a Cell Id from anywhere in the 't1' Table, and a count
 * of how many times it appears.
 */
export type T1TableCellCallback = TableCellCallback<'t1'>;

/**
 * Takes a number Cell value and returns another.
 */
export type MapNumber = (cell: number | undefined) => number;

/**
 * Takes a string Cell value and returns another.
 */
export type MapString = (cell: string | undefined) => string;

/**
 * A function for listening to the completion of a transaction.
 */
export type TransactionListener = (
  s: S,
  getTransactionChanges: GetTransactionChanges,
  getTransactionLog: GetTransactionLog,
) => void;

export interface S {
  /**
   * Gets the tabular content of the Store.
   */
  getTables(): Tables;

  /**
   * Checks existence of the tabular content of the Store.
   */
  hasTables(): boolean;

  /**
   * Sets the tabular content of the Store.
   */
  setTables(tables: TablesWhenSet): S;

  /**
   * Deletes the tabular content of the Store.
   */
  delTables(): S;

  /**
   * Gets the Ids of the Tables in the Store.
   */
  getTableIds(): TableId[];

  /**
   * Calls a function for each Table in the Store.
   */
  forEachTable(tableCallback: TableCallback): void;

  /**
   * Gets the content of the 't1' Table.
   */
  getT1Table(): T1Table;

  /**
   * Checks existence of the content of the 't1' Table.
   */
  hasT1Table(): boolean;

  /**
   * Sets the content of the 't1' Table.
   */
  setT1Table(table: T1TableWhenSet): S;

  /**
   * Deletes the content of the 't1' Table.
   */
  delT1Table(): S;

  /**
   * Gets the Ids of the Cells in the whole of the 't1' Table.
   */
  getT1TableCellIds(): Ids;

  /**
   * Calls a function for each TableCell in the whole of the 't1' Table.
   */
  forEachT1TableCell(tableCellCallback: T1TableCellCallback): void;

  /**
   * Gets the number of Rows in the the 't1' Table.
   */
  getT1RowCount(): number;

  /**
   * Gets the Ids of the Rows in the 't1' Table.
   */
  getT1RowIds(): Ids;

  /**
   * Gets sorted, paginated Ids of the Rows in the 't1' Table.
   */
  getT1SortedRowIds(
    cellId?: T1CellId,
    descending?: boolean,
    offset?: number,
    limit?: number,
  ): Ids;

  /**
   * Calls a function for each Row in the 't1' Table.
   */
  forEachT1Row(rowCallback: T1RowCallback): void;

  /**
   * Gets the content of the specified Row in the 't1' Table.
   */
  getT1Row(rowId: Id): T1Row;

  /**
   * Checks existence of the content of the specified Row in the 't1' Table.
   */
  hasT1Row(rowId: Id): boolean;

  /**
   * Sets the content of the specified Row in the 't1' Table.
   */
  setT1Row(rowId: Id, row: T1RowWhenSet): S;

  /**
   * Deletes the content of the specified Row in the 't1' Table.
   */
  delT1Row(rowId: Id): S;

  /**
   * Sets part of the content of the specified Row in the 't1' Table.
   */
  setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

  /**
   * Add a new Row to the 't1' Table.
   */
  addT1Row(row: T1RowWhenSet, reuseIds?: boolean): Id | undefined;

  /**
   * Gets the Ids of the Cells in the specified Row in the 't1' Table.
   */
  getT1CellIds(rowId: Id): T1CellId[];

  /**
   * Calls a function for each Cell in the specified Row in the 't1' Table.
   */
  forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

  /**
   * Gets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  getT1C1Cell(rowId: Id): number;

  /**
   * Checks existence of the 'c1' Cell for the specified Row in the 't1' Table.
   */
  hasT1C1Cell(rowId: Id): boolean;

  /**
   * Sets the 'c1' Cell for the specified Row in the 't1' Table.
   */
  setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

  /**
   * Deletes the 'c1' Cell for the specified Row in the 't1' Table.
   */
  delT1C1Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c1' Cell anywhere in the 't1' Table.
   */
  hasT1C1TableCell(): boolean;

  /**
   * Gets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  getT1C2Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c2' Cell for the specified Row in the 't1' Table.
   */
  hasT1C2Cell(rowId: Id): boolean;

  /**
   * Sets the 'c2' Cell for the specified Row in the 't1' Table.
   */
  setT1C2Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c2' Cell for the specified Row in the 't1' Table.
   */
  delT1C2Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c2' Cell anywhere in the 't1' Table.
   */
  hasT1C2TableCell(): boolean;

  /**
   * Gets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  getT1C3Cell(rowId: Id): string;

  /**
   * Checks existence of the 'c3' Cell for the specified Row in the 't1' Table.
   */
  hasT1C3Cell(rowId: Id): boolean;

  /**
   * Sets the 'c3' Cell for the specified Row in the 't1' Table.
   */
  setT1C3Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the 'c3' Cell for the specified Row in the 't1' Table.
   */
  delT1C3Cell(rowId: Id): S;

  /**
   * Checks existence of the 'c3' Cell anywhere in the 't1' Table.
   */
  hasT1C3TableCell(): boolean;

  /**
   * Gets the '' Cell for the specified Row in the 't1' Table.
   */
  getT1Cell(rowId: Id): string | undefined;

  /**
   * Checks existence of the '' Cell for the specified Row in the 't1' Table.
   */
  hasT1Cell(rowId: Id): boolean;

  /**
   * Sets the '' Cell for the specified Row in the 't1' Table.
   */
  setT1Cell(rowId: Id, cell: string | MapString): S;

  /**
   * Deletes the '' Cell for the specified Row in the 't1' Table.
   */
  delT1Cell(rowId: Id): S;

  /**
   * Checks existence of the '' Cell anywhere in the 't1' Table.
   */
  hasT1TableCell(): boolean;

  /**
   * Gets a string serialization of the tabular content of the Store.
   */
  getTablesJson(): Json;

  /**
   * Sets a string serialization of the tabular content of the Store.
   */
  setTablesJson(tablesJson: Json): S;

  /**
   * Registers a listener that will be called whenever the existence of the
   * tabular content of the Store changes.
   */
  addHasTablesListener(listener: HasTablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the tabular content of
   * the Store changes.
   */
  addTablesListener(listener: TablesListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the Table Ids in the
   * Store change.
   */
  addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Table
   * in the Store changes.
   */
  addHasTableListener(
    tableId: TableId | null,
    listener: HasTableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Table in the Store
   * changes.
   */
  addTableListener(
    tableId: TableId | null,
    listener: TableListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids anywhere in
   * a Table change.
   */
  addTableCellIdsListener(
    tableId: TableId | null,
    listener: TableCellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Cell
   * anywhere in a Table changes.
   */
  addHasTableCellListener(
    tableId: TableId | null,
    cellId: T1CellId | null,
    listener: HasTableCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the number of Rows in a
   * Table changes.
   */
  addRowCountListener(
    tableId: TableId | null,
    listener: RowCountListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Row Ids in a Table
   * change.
   */
  addRowIdsListener(
    tableId: TableId | null,
    listener: RowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the sorted Row Ids in a
   * Table change.
   */
  addSortedRowIdsListener<TId extends TableId>(
    tableId: TId,
    cellId: CellId<TId> | undefined,
    descending: boolean,
    offset: number,
    limit: number | undefined,
    listener: SortedRowIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Row in
   * a Table changes.
   */
  addHasRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: HasRowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Row in a Table changes.
   */
  addRowListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: RowListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the Cell Ids in a Row
   * change.
   */
  addCellIdsListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    listener: CellIdsListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever the existence of a Cell
   * in a Row changes.
   */
  addHasCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: HasCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever a Cell in a Row changes.
   */
  addCellListener(
    tableId: TableId | null,
    rowId: IdOrNull,
    cellId: T1CellId | null,
    listener: CellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Registers a listener that will be called whenever an invalid Cell change
   * was attempted.
   */
  addInvalidCellListener(
    tableId: IdOrNull,
    rowId: IdOrNull,
    cellId: IdOrNull,
    listener: InvalidCellListener,
    mutator?: boolean,
  ): Id;

  /**
   * Gets the content of the Store.
   */
  getContent(): [Tables, Values];

  /**
   * Sets the content of the Store.
   */
  setContent([tables, values]: [Tables, Values]): S;

  /**
   * Applies a set of TransactionChanges to the Store.
   */
  applyChanges(changes: TransactionChanges): S;

  /**
   * Gets a string serialization of the content of the Store.
   */
  getJson(): Json;

  /**
   * Sets a string serialization of the content of the Store.
   */
  setJson(tablesAndValuesJson: Json): S;

  /**
   * Execute a transaction to make multiple mutations.
   */
  transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

  /**
   * Explicitly starts a transaction.
   */
  startTransaction(): S;

  /**
   * Explicitly finishes a transaction.
   */
  finishTransaction(doRollback?: DoRollback): S;

  /**
   * Registers a listener that will be called just before the start of the
   * transaction.
   */
  addStartTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just before the end of the
   * transaction.
   */
  addWillFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Registers a listener that will be called just after the end of the
   * transaction.
   */
  addDidFinishTransactionListener(listener: TransactionListener): Id;

  /**
   * Manually provoke a listener to be called.
   */
  callListener(listenerId: Id): S;

  /**
   * Remove a listener that was previously added to the Store.
   */
  delListener(listenerId: Id): S;

  /**
   * Gets the underlying Store object.
   */
  getStore(): Store;
}

/**
 * Creates a S object.
 */
export function createS(): S;
",
  "import {
  CellId,
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  InvalidCellListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellCallback,
  T1CellId,
  T1Row,
  T1RowCallback,
  T1RowWhenSet,
  T1Table,
  T1TableCellCallback,
  T1TableWhenSet,
  TableCallback,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
  TransactionListener,
  createS as createSDecl,
} from './s.d';
import {
  DoRollback,
  Id,
  IdOrNull,
  Ids,
  Json,
  Store,
  TransactionChanges,
  Values,
  createStore,
} from 'tinybase';

export const createS: typeof createSDecl = () => {
  const T1 = 't1';

  const C1 = 'c1';

  const C2 = 'c2';

  const C3 = 'c3';

  const _ = '';

  const TYPE = 'type';

  const NUMBER = 'number';

  const DEFAULT = 'default';

  const STRING = 'string';

  const TWO = 'two';

  const _3 = '3';

  const store = createStore().setTablesSchema({
    [T1]: {
      [C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
      [C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
      [C3]: {[TYPE]: STRING, [DEFAULT]: _3},
      [_]: {[TYPE]: STRING},
    },
  });

  const fluent = (actions: () => Store) => {
    actions();
    return s;
  };

  const proxy =
    (listener: any) =>
    (_: Store, ...params: any[]) =>
      listener(s, ...params);

  const s = {
    getTables: (): Tables => store.getTables() as Tables,

    hasTables: (): boolean => store.hasTables(),

    setTables: (tables: TablesWhenSet): S =>
      fluent(() => store.setTables(tables)),

    delTables: (): S => fluent(() => store.delTables()),

    getTableIds: (): TableId[] => store.getTableIds() as TableId[],

    forEachTable: (tableCallback: TableCallback): void =>
      store.forEachTable(tableCallback as any),

    getT1Table: (): T1Table => store.getTable(T1) as T1Table,

    hasT1Table: (): boolean => store.hasTable(T1),

    setT1Table: (table: T1TableWhenSet): S =>
      fluent(() => store.setTable(T1, table)),

    delT1Table: (): S => fluent(() => store.delTable(T1)),

    getT1TableCellIds: (): Ids => store.getTableCellIds(T1) as Ids,

    forEachT1TableCell: (tableCellCallback: T1TableCellCallback): void =>
      store.forEachTableCell(T1, tableCellCallback as any),

    getT1RowCount: (): number => store.getRowCount(T1) as number,

    getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

    getT1SortedRowIds: (
      cellId?: T1CellId,
      descending?: boolean,
      offset?: number,
      limit?: number,
    ): Ids =>
      store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

    forEachT1Row: (rowCallback: T1RowCallback): void =>
      store.forEachRow(T1, rowCallback as any),

    getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

    hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

    setT1Row: (rowId: Id, row: T1RowWhenSet): S =>
      fluent(() => store.setRow(T1, rowId, row)),

    delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

    setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S =>
      fluent(() => store.setPartialRow(T1, rowId, partialRow)),

    addT1Row: (row: T1RowWhenSet, reuseIds?: boolean): Id | undefined =>
      store.addRow(T1, row, reuseIds),

    getT1CellIds: (rowId: Id): T1CellId[] =>
      store.getCellIds(T1, rowId) as T1CellId[],

    forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void =>
      store.forEachCell(T1, rowId, cellCallback as any),

    getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

    hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

    setT1C1Cell: (rowId: Id, cell: number | MapNumber): S =>
      fluent(() => store.setCell(T1, rowId, C1, cell as any)),

    delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

    hasT1C1TableCell: (): boolean => store.hasTableCell(T1, C1),

    getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

    hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

    setT1C2Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C2, cell as any)),

    delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

    hasT1C2TableCell: (): boolean => store.hasTableCell(T1, C2),

    getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

    hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

    setT1C3Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, C3, cell as any)),

    delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

    hasT1C3TableCell: (): boolean => store.hasTableCell(T1, C3),

    getT1Cell: (rowId: Id): string | undefined =>
      store.getCell(T1, rowId, _) as string | undefined,

    hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

    setT1Cell: (rowId: Id, cell: string | MapString): S =>
      fluent(() => store.setCell(T1, rowId, _, cell as any)),

    delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

    hasT1TableCell: (): boolean => store.hasTableCell(T1, _),

    getTablesJson: (): Json => store.getTablesJson() as Json,

    setTablesJson: (tablesJson: Json): S =>
      fluent(() => store.setTablesJson(tablesJson)),

    addHasTablesListener: (
      listener: HasTablesListener,
      mutator?: boolean,
    ): Id => store.addHasTablesListener(proxy(listener), mutator),

    addTablesListener: (listener: TablesListener, mutator?: boolean): Id =>
      store.addTablesListener(proxy(listener), mutator),

    addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id =>
      store.addTableIdsListener(proxy(listener), mutator),

    addHasTableListener: (
      tableId: TableId | null,
      listener: HasTableListener,
      mutator?: boolean,
    ): Id => store.addHasTableListener(tableId, proxy(listener), mutator),

    addTableListener: (
      tableId: TableId | null,
      listener: TableListener,
      mutator?: boolean,
    ): Id => store.addTableListener(tableId, proxy(listener), mutator),

    addTableCellIdsListener: (
      tableId: TableId | null,
      listener: TableCellIdsListener,
      mutator?: boolean,
    ): Id => store.addTableCellIdsListener(tableId, proxy(listener), mutator),

    addHasTableCellListener: (
      tableId: TableId | null,
      cellId: T1CellId | null,
      listener: HasTableCellListener,
      mutator?: boolean,
    ): Id =>
      store.addHasTableCellListener(tableId, cellId, proxy(listener), mutator),

    addRowCountListener: (
      tableId: TableId | null,
      listener: RowCountListener,
      mutator?: boolean,
    ): Id => store.addRowCountListener(tableId, proxy(listener), mutator),

    addRowIdsListener: (
      tableId: TableId | null,
      listener: RowIdsListener,
      mutator?: boolean,
    ): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

    addSortedRowIdsListener: <TId extends TableId>(
      tableId: TId,
      cellId: CellId<TId> | undefined,
      descending: boolean,
      offset: number,
      limit: number | undefined,
      listener: SortedRowIdsListener,
      mutator?: boolean,
    ): Id =>
      store.addSortedRowIdsListener(
        tableId,
        cellId,
        descending,
        offset,
        limit,
        proxy(listener),
        mutator,
      ),

    addHasRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: HasRowListener,
      mutator?: boolean,
    ): Id => store.addHasRowListener(tableId, rowId, proxy(listener), mutator),

    addRowListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: RowListener,
      mutator?: boolean,
    ): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

    addCellIdsListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      listener: CellIdsListener,
      mutator?: boolean,
    ): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

    addHasCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: HasCellListener,
      mutator?: boolean,
    ): Id =>
      store.addHasCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    addCellListener: (
      tableId: TableId | null,
      rowId: IdOrNull,
      cellId: T1CellId | null,
      listener: CellListener,
      mutator?: boolean,
    ): Id =>
      store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

    addInvalidCellListener: (
      tableId: IdOrNull,
      rowId: IdOrNull,
      cellId: IdOrNull,
      listener: InvalidCellListener,
      mutator?: boolean,
    ): Id =>
      store.addInvalidCellListener(
        tableId,
        rowId,
        cellId,
        proxy(listener),
        mutator,
      ),

    getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

    setContent: ([tables, values]: [Tables, Values]): S =>
      fluent(() => store.setContent([tables, values])),

    applyChanges: (changes: TransactionChanges): S =>
      fluent(() => store.applyChanges(changes)),

    getJson: (): Json => store.getJson() as Json,

    setJson: (tablesAndValuesJson: Json): S =>
      fluent(() => store.setJson(tablesAndValuesJson)),

    transaction: <Return>(
      actions: () => Return,
      doRollback?: DoRollback,
    ): Return => store.transaction(actions, doRollback),

    startTransaction: (): S => fluent(() => store.startTransaction()),

    finishTransaction: (doRollback?: DoRollback): S =>
      fluent(() => store.finishTransaction(doRollback)),

    addStartTransactionListener: (listener: TransactionListener): Id =>
      store.addStartTransactionListener(proxy(listener)),

    addWillFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addWillFinishTransactionListener(proxy(listener)),

    addDidFinishTransactionListener: (listener: TransactionListener): Id =>
      store.addDidFinishTransactionListener(proxy(listener)),

    callListener: (listenerId: Id): S =>
      fluent(() => store.callListener(listenerId)),

    delListener: (listenerId: Id): S =>
      fluent(() => store.delListener(listenerId)),

    getStore: (): Store => store,
  };

  return Object.freeze(s);
};
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellId,
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/**
 * Used when you need to refer to a S in a React hook or component.
 */
export type SOrSId = S | Id;

/**
 * Used with the Provider component, so that a S can be passed into the context
 * of an application.
 */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/**
 * The props passed to a component that renders a Cell.
 */
export type CellProps<TId extends TableId, CId extends CellId<TId>> = {
  readonly tableId?: TId;
  readonly rowId: Id;
  readonly cellId?: CId;
  readonly s?: S;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Row.
 */
export type RowProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly rowId: Id;
  readonly s?: S;
  readonly cellComponents?: {
    readonly [CId in CellId<TId>]?: ComponentType<CellProps<TId, CId>>;
  };
  readonly getCellComponentProps?: (cellId: CellId<TId>) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a Table.
 */
export type TableProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly s?: S;
  readonly rowComponent?: ComponentType<RowProps<TId>>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders a sorted Table.
 */
export type SortedTableProps<TId extends TableId> = {
  readonly tableId?: TId;
  readonly cellId?: CellId<TId>;
  readonly descending?: boolean;
  readonly offset?: number;
  readonly limit?: number;
  readonly s?: S;
  readonly rowComponent?: ComponentType<RowProps<TId>>;
  readonly getRowComponentProps?: (rowId: Id) => ExtraProps;
  readonly customCellIds?: CellId<TId>[];
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * The props passed to a component that renders the tabular content of the
 * Store.
 */
export type TablesProps = {
  readonly s?: S;
  readonly tableComponents?: {
    readonly [TId in TableId]?: ComponentType<TableProps<TId>>;
  };
  readonly getTableComponentProps?: (tableId: TableId) => ExtraProps;
  readonly separator?: ReactElement | string;
  readonly debugIds?: boolean;
};

/**
 * Create a S within a React application with convenient memoization.
 */
export function useCreateS(
  create: () => S,
  createDeps?: React.DependencyList,
): S;

/**
 * Get a reference to a S from within a Provider component context.
 */
export function useS(id?: Id): S | undefined;

/**
 * Gets the existence of the tabular content of the Store, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasTables(sOrSId?: SOrSId): boolean;

/**
 * Gets the tabular content of the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTables(sOrSId?: SOrSId): Tables;

/**
 * Gets the Ids of the Tables in the Store, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/**
 * Gets a callback that can set the tabular content of the Store, based on a
 * parameter.
 */
export function useSetTablesCallback<Parameter>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the tabular content of the Store.
 */
export function useDelTablesCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the tabular content of the Store, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function TablesView({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): ComponentReturnType;

/**
 * Gets the existence of the content of the 't1' Table, and registers a listener
 * so that any changes to that result will cause a re-render.
 */
export function useHasT1Table(sOrSId?: SOrSId): boolean;

/**
 * Gets the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/**
 * Gets the Ids of the Cells in the whole of the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1TableCellIds(sOrSId?: SOrSId): Ids;

/**
 * Gets the number of Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowCount(sOrSId?: SOrSId): number;

/**
 * Gets the Ids of the Rows in the 't1' Table, and registers a listener so that
 * any changes to that result will cause a re-render.
 */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/**
 * Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1SortedRowIds(
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids;

/**
 * Gets the existence of the content of the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1Row(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/**
 * Gets the Ids of the Cells in the specified Row in the 't1' Table, and
 * registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/**
 * Gets a callback that can set the content of the 't1' Table, based on a
 * parameter.
 */
export function useSetT1TableCallback<Parameter>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the 't1' Table.
 */
export function useDelT1TableCallback(
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Gets a callback that can set the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1RowCallback<Parameter>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can add the content of the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useAddT1RowCallback<Parameter>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
  reuseRowIds?: boolean,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can set part of the content of the specified Row in the
 * 't1' Table, based on a parameter.
 */
export function useSetT1PartialRowCallback<Parameter>(
  rowId: Id,
  getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getPartialRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, partialRow: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the content of the specified Row in the 't1'
 * Table.
 */
export function useDelT1RowCallback(
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the content of the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1RowView({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  customCellIds,
  separator,
  debugIds,
}: RowProps<'t1'>): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, sorted, and registers a listener so
 * that any changes to that result will cause a re-render.
 */
export function T1SortedTableView({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: SortedTableProps<'t1'>): ComponentReturnType;

/**
 * Renders the content of the 't1' Table, and registers a listener so that any
 * changes to that result will cause a re-render.
 */
export function T1TableView(props: TableProps<'t1'>): ComponentReturnType;

/**
 * Gets the existence of the 'c1' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C1TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c1' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/**
 * Gets a callback that can set the 'c1' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c1' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C1CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c1'>): ComponentReturnType;

/**
 * Gets the existence of the 'c2' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C2TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c2' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C2Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c2' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C2CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c2' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C2CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C2CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c2'>): ComponentReturnType;

/**
 * Gets the existence of the 'c3' Cell anywhere in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function useHasT1C3TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the 'c3' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1C3Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/**
 * Gets a callback that can set the 'c3' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1C3CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the 'c3' Cell for the specified Row in the
 * 't1' Table.
 */
export function useDelT1C3CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers
 * a listener so that any changes to that result will cause a re-render.
 */
export function T1C3CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c3'>): ComponentReturnType;

/**
 * Gets the existence of the '' Cell anywhere in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useHasT1TableCell(sOrSId?: SOrSId): boolean;

/**
 * Gets the existence of the '' Cell for the specified Row in the 't1' Table,
 * and registers a listener so that any changes to that result will cause a
 * re-render.
 */
export function useHasT1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/**
 * Gets the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/**
 * Gets a callback that can set the '' Cell for the specified Row in the 't1'
 * Table, based on a parameter.
 */
export function useSetT1CellCallback<Parameter>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter>;

/**
 * Gets a callback that can delete the '' Cell for the specified Row in the 't1'
 * Table.
 */
export function useDelT1CellCallback(
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback;

/**
 * Renders the '' Cell for the specified Row in the 't1' Table, and registers a
 * listener so that any changes to that result will cause a re-render.
 */
export function T1CellView({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', ''>): ComponentReturnType;

/**
 * Registers a listener that will be called whenever the existence of the
 * tabular content of the Store changes.
 */
export function useHasTablesListener(
  listener: HasTablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the tabular content of the
 * Store changes.
 */
export function useTablesListener(
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Table Ids in the Store
 * change.
 */
export function useTableIdsListener(
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Table in
 * the Store changes.
 */
export function useHasTableListener(
  tableId: TableId | null,
  listener: HasTableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Table in the Store
 * changes.
 */
export function useTableListener(
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids anywhere in a
 * Table change.
 */
export function useTableCellIdsListener(
  tableId: TableId | null,
  listener: TableCellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Cell
 * anywhere in a Table changes.
 */
export function useHasTableCellListener(
  tableId: TableId | null,
  cellId: T1CellId | null,
  listener: HasTableCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the number of Rows in a
 * Table changes.
 */
export function useRowCountListener(
  tableId: TableId | null,
  listener: RowCountListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Row Ids in a Table
 * change.
 */
export function useRowIdsListener(
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the sorted Row Ids in a
 * Table change.
 */
export function useSortedRowIdsListener(
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Row in a
 * Table changes.
 */
export function useHasRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: HasRowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Row in a Table changes.
 */
export function useRowListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the Cell Ids in a Row
 * change.
 */
export function useCellIdsListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever the existence of a Cell in
 * a Row changes.
 */
export function useHasCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: HasCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Registers a listener that will be called whenever a Cell in a Row changes.
 */
export function useCellListener(
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void;

/**
 * Wraps part of an application in a context that provides default objects to be
 * used by hooks and components within.
 */
export function Provider({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {
  Callback,
  Id,
  IdOrNull,
  Ids,
  ParameterizedCallback,
  Store,
} from 'tinybase';
import {
  CellIdsListener,
  CellListener,
  HasCellListener,
  HasRowListener,
  HasTableCellListener,
  HasTableListener,
  HasTablesListener,
  MapNumber,
  MapString,
  RowCountListener,
  RowIdsListener,
  RowListener,
  S,
  SortedRowIdsListener,
  T1CellId,
  T1Row,
  T1RowWhenSet,
  T1Table,
  T1TableWhenSet,
  TableCellIdsListener,
  TableId,
  TableIdsListener,
  TableListener,
  Tables,
  TablesListener,
  TablesWhenSet,
} from './s.d';
import {
  CellProps,
  Provider as ProviderDecl,
  ProviderProps,
  RowProps,
  SOrSId,
  SortedTableProps,
  T1C1CellView as T1C1CellViewDecl,
  T1C2CellView as T1C2CellViewDecl,
  T1C3CellView as T1C3CellViewDecl,
  T1CellView as T1CellViewDecl,
  T1RowView as T1RowViewDecl,
  T1SortedTableView as T1SortedTableViewDecl,
  T1TableView as T1TableViewDecl,
  TableProps,
  TablesProps,
  TablesView as TablesViewDecl,
  useAddT1RowCallback as useAddT1RowCallbackDecl,
  useCellIdsListener as useCellIdsListenerDecl,
  useCellListener as useCellListenerDecl,
  useCreateS as useCreateSDecl,
  useDelT1C1CellCallback as useDelT1C1CellCallbackDecl,
  useDelT1C2CellCallback as useDelT1C2CellCallbackDecl,
  useDelT1C3CellCallback as useDelT1C3CellCallbackDecl,
  useDelT1CellCallback as useDelT1CellCallbackDecl,
  useDelT1RowCallback as useDelT1RowCallbackDecl,
  useDelT1TableCallback as useDelT1TableCallbackDecl,
  useDelTablesCallback as useDelTablesCallbackDecl,
  useHasCellListener as useHasCellListenerDecl,
  useHasRowListener as useHasRowListenerDecl,
  useHasT1C1Cell as useHasT1C1CellDecl,
  useHasT1C1TableCell as useHasT1C1TableCellDecl,
  useHasT1C2Cell as useHasT1C2CellDecl,
  useHasT1C2TableCell as useHasT1C2TableCellDecl,
  useHasT1C3Cell as useHasT1C3CellDecl,
  useHasT1C3TableCell as useHasT1C3TableCellDecl,
  useHasT1Cell as useHasT1CellDecl,
  useHasT1Row as useHasT1RowDecl,
  useHasT1TableCell as useHasT1TableCellDecl,
  useHasT1Table as useHasT1TableDecl,
  useHasTableCellListener as useHasTableCellListenerDecl,
  useHasTableListener as useHasTableListenerDecl,
  useHasTables as useHasTablesDecl,
  useHasTablesListener as useHasTablesListenerDecl,
  useRowCountListener as useRowCountListenerDecl,
  useRowIdsListener as useRowIdsListenerDecl,
  useRowListener as useRowListenerDecl,
  useS as useSDecl,
  useSetT1C1CellCallback as useSetT1C1CellCallbackDecl,
  useSetT1C2CellCallback as useSetT1C2CellCallbackDecl,
  useSetT1C3CellCallback as useSetT1C3CellCallbackDecl,
  useSetT1CellCallback as useSetT1CellCallbackDecl,
  useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl,
  useSetT1RowCallback as useSetT1RowCallbackDecl,
  useSetT1TableCallback as useSetT1TableCallbackDecl,
  useSetTablesCallback as useSetTablesCallbackDecl,
  useSortedRowIdsListener as useSortedRowIdsListenerDecl,
  useT1C1Cell as useT1C1CellDecl,
  useT1C2Cell as useT1C2CellDecl,
  useT1C3Cell as useT1C3CellDecl,
  useT1Cell as useT1CellDecl,
  useT1CellIds as useT1CellIdsDecl,
  useT1RowCount as useT1RowCountDecl,
  useT1Row as useT1RowDecl,
  useT1RowIds as useT1RowIdsDecl,
  useT1SortedRowIds as useT1SortedRowIdsDecl,
  useT1TableCellIds as useT1TableCellIdsDecl,
  useT1Table as useT1TableDecl,
  useTableCellIdsListener as useTableCellIdsListenerDecl,
  useTableIds as useTableIdsDecl,
  useTableIdsListener as useTableIdsListenerDecl,
  useTableListener as useTableListenerDecl,
  useTables as useTablesDecl,
  useTablesListener as useTablesListenerDecl,
} from './s-ui-react.d';
import {
  ExtraProps,
  useAddRowCallback as useAddRowCallbackCore,
  useCell as useCellCore,
  useCellIds,
  useCellIds as useCellIdsCore,
  useCellIdsListener as useCellIdsListenerCore,
  useCellListener as useCellListenerCore,
  useDelCellCallback as useDelCellCallbackCore,
  useDelRowCallback as useDelRowCallbackCore,
  useDelTableCallback as useDelTableCallbackCore,
  useDelTablesCallback as useDelTablesCallbackCore,
  useHasCell as useHasCellCore,
  useHasCellListener as useHasCellListenerCore,
  useHasRow as useHasRowCore,
  useHasRowListener as useHasRowListenerCore,
  useHasTableCell as useHasTableCellCore,
  useHasTableCellListener as useHasTableCellListenerCore,
  useHasTable as useHasTableCore,
  useHasTableListener as useHasTableListenerCore,
  useHasTables as useHasTablesCore,
  useHasTablesListener as useHasTablesListenerCore,
  useRow as useRowCore,
  useRowCount as useRowCountCore,
  useRowCountListener as useRowCountListenerCore,
  useRowIds as useRowIdsCore,
  useRowIdsListener as useRowIdsListenerCore,
  useRowListener as useRowListenerCore,
  useSetCellCallback as useSetCellCallbackCore,
  useSetPartialRowCallback as useSetPartialRowCallbackCore,
  useSetRowCallback as useSetRowCallbackCore,
  useSetTableCallback as useSetTableCallbackCore,
  useSetTablesCallback as useSetTablesCallbackCore,
  useSortedRowIds as useSortedRowIdsCore,
  useSortedRowIdsListener as useSortedRowIdsListenerCore,
  useTableCellIds as useTableCellIdsCore,
  useTableCellIdsListener as useTableCellIdsListenerCore,
  useTable as useTableCore,
  useTableIds as useTableIdsCore,
  useTableIdsListener as useTableIdsListenerCore,
  useTableListener as useTableListenerCore,
  useTables as useTablesCore,
  useTablesListener as useTablesListenerCore,
} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (
  sOrSId: SOrSId | undefined,
  hook: (...params: any[]) => any,
  preParams: any[],
  postParams: any[] = [],
) => {
  const s = useS(sOrSId as Id);
  return hook(
    ...preParams,
    (sOrSId == null || typeof sOrSId == 'string' ? s : sOrSId)?.getStore(),
    ...postParams,
  );
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) =>
  getProps == null ? ({} as ExtraProps) : getProps(id);

const wrap = (
  children: any,
  separator?: any,
  encloseWithId?: boolean,
  id?: Id,
) => {
  const separated =
    separator == null || !Array.isArray(children)
      ? children
      : children.map((child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (
  customCellIds: Ids | undefined,
  tableId: Id,
  rowId: Id,
  sOrSId?: SOrSId | undefined,
) => {
  const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
  return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const tableView = (
  {
    s,
    rowComponent,
    getRowComponentProps,
    customCellIds,
    separator,
    debugIds,
  }: any,
  rowIds: Ids,
  tableId: Id,
  defaultRowComponent: React.ComponentType<any>,
) => {
  const Row = rowComponent ?? defaultRowComponent;
  return wrap(
    rowIds.map((rowId) => (
      <Row
        {...getProps(getRowComponentProps, rowId)}
        key={rowId}
        tableId={tableId}
        rowId={rowId}
        customCellIds={customCellIds}
        s={s}
        debugIds={debugIds}
      />
    )),
    separator,
    debugIds,
    tableId,
  );
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) =>
  tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) =>
  tableId == T1
    ? cellId == C1
      ? T1C1CellView
      : cellId == C2
        ? T1C2CellView
        : cellId == C3
          ? T1C3CellView
          : cellId == _
            ? T1CellView
            : NullComponent
    : NullComponent;

export const useCreateS: typeof useCreateSDecl = (
  create: () => S,
  createDeps?: React.DependencyList,
): S =>
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useMemo(create, createDeps);

export const useS: typeof useSDecl = (id?: Id): S | undefined => {
  const contextValue = useContext(Context);
  return id == null ? contextValue[0] : contextValue[1]?.[id];
};

export const useHasTables: typeof useHasTablesDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTablesCore, []);

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
  useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (
  sOrSId?: SOrSId,
): TableId[] => useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <
  Parameter,
>(
  getTables: (parameter: Parameter, store: Store) => TablesWhenSet,
  getTablesDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, tables: TablesWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTablesCallbackCore,
    [getTables, getTablesDeps],
    [then, thenDeps],
  );

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({
  s,
  tableComponents,
  getTableComponentProps,
  separator,
  debugIds,
}: TablesProps): any =>
  wrap(
    useTableIds(s).map((tableId) => {
      const Table = (tableComponents?.[tableId] ??
        getDefaultTableComponent(tableId)) as React.ComponentType<
        TableProps<typeof tableId>
      >;
      return (
        <Table
          {...getProps(getTableComponentProps, tableId)}
          tableId={tableId}
          key={tableId}
          s={s}
          debugIds={debugIds}
        />
      );
    }),
    separator,
  );

export const useHasT1Table: typeof useHasT1TableDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCore, [T1]);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
  useHook(sOrSId, useTableCore, [T1]);

export const useT1TableCellIds: typeof useT1TableCellIdsDecl = (
  sOrSId?: SOrSId,
): Ids => useHook(sOrSId, useTableCellIdsCore, [T1]);

export const useT1RowCount: typeof useT1RowCountDecl = (
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useRowCountCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
  useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (
  cellId?: T1CellId,
  descending?: boolean,
  offset?: number,
  limit?: number,
  sOrSId?: SOrSId,
): Ids =>
  useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useHasT1Row: typeof useHasT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasRowCore, [T1, rowId]);

export const useT1Row: typeof useT1RowDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1Row => useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): T1CellId[] => useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <
  Parameter,
>(
  getTable: (parameter: Parameter, store: Store) => T1TableWhenSet,
  getTableDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, table: T1TableWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetTableCallbackCore,
    [T1, getTable, getTableDeps],
    [then, thenDeps],
  );

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback => useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(
  rowId: Id,
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetRowCallbackCore,
    [T1, rowId, getRow, getRowDeps],
    [then, thenDeps],
  );

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(
  getRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
  getRowDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void,
  thenDeps?: React.DependencyList,
  reuseRowIds?: boolean,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useAddRowCallbackCore,
    [T1, getRow, getRowDeps],
    [then, thenDeps, reuseRowIds],
  );

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl =
  <Parameter,>(
    rowId: Id,
    getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet,
    getPartialRowDeps?: React.DependencyList,
    sOrSId?: SOrSId,
    then?: (store: Store, partialRow: T1RowWhenSet) => void,
    thenDeps?: React.DependencyList,
  ): ParameterizedCallback<Parameter> =>
    useHook(
      sOrSId,
      useSetPartialRowCallbackCore,
      [T1, rowId, getPartialRow, getPartialRowDeps],
      [then, thenDeps],
    );

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({
  rowId,
  s,
  cellComponents,
  getCellComponentProps,
  customCellIds,
  separator,
  debugIds,
}: RowProps<'t1'>): any =>
  wrap(
    useCustomOrDefaultCellIds(customCellIds, T1, rowId, s).map(
      (cellId: T1CellId) => {
        const Cell = (cellComponents?.[cellId] ??
          getDefaultCellComponent(T1, cellId)) as React.ComponentType<
          CellProps<typeof T1, typeof cellId>
        >;
        return (
          <Cell
            {...getProps(getCellComponentProps, cellId)}
            key={cellId}
            tableId={T1}
            rowId={rowId}
            cellId={cellId}
            s={s}
            debugIds={debugIds}
          />
        );
      },
    ),
    separator,
    debugIds,
    rowId,
  );

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({
  cellId,
  descending,
  offset,
  limit,
  ...props
}: SortedTableProps<'t1'>): any =>
  tableView(
    props,
    useT1SortedRowIds(cellId, descending, offset, limit, props.s),
    T1,
    T1RowView,
  );

export const T1TableView: typeof T1TableViewDecl = (
  props: TableProps<'t1'>,
): any => tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useHasT1C1TableCell: typeof useHasT1C1TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C1]);

export const useHasT1C1Cell: typeof useHasT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C1]);

export const useT1C1Cell: typeof useT1C1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): number => useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => number | MapNumber,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: number | MapNumber) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C1, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C1, forceDel],
    [then, thenDeps],
  );

export const T1C1CellView: typeof T1C1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c1'>): any =>
  wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1);

export const useHasT1C2TableCell: typeof useHasT1C2TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C2]);

export const useHasT1C2Cell: typeof useHasT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C2]);

export const useT1C2Cell: typeof useT1C2CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C2, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C2, forceDel],
    [then, thenDeps],
  );

export const T1C2CellView: typeof T1C2CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c2'>): any =>
  wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2);

export const useHasT1C3TableCell: typeof useHasT1C3TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, C3]);

export const useHasT1C3Cell: typeof useHasT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, C3]);

export const useT1C3Cell: typeof useT1C3CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string => useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, C3, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, C3, forceDel],
    [then, thenDeps],
  );

export const T1C3CellView: typeof T1C3CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', 'c3'>): any =>
  wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3);

export const useHasT1TableCell: typeof useHasT1TableCellDecl = (
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasTableCellCore, [T1, _]);

export const useHasT1Cell: typeof useHasT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): boolean => useHook(sOrSId, useHasCellCore, [T1, rowId, _]);

export const useT1Cell: typeof useT1CellDecl = (
  rowId: Id,
  sOrSId?: SOrSId,
): string | undefined => useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <
  Parameter,
>(
  rowId: Id,
  getCell: (parameter: Parameter, store: Store) => string | MapString,
  getCellDeps?: React.DependencyList,
  sOrSId?: SOrSId,
  then?: (store: Store, cell: string | MapString) => void,
  thenDeps?: React.DependencyList,
): ParameterizedCallback<Parameter> =>
  useHook(
    sOrSId,
    useSetCellCallbackCore,
    [T1, rowId, _, getCell, getCellDeps],
    [then, thenDeps],
  );

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (
  rowId: Id,
  forceDel?: boolean,
  sOrSId?: SOrSId,
  then?: (store: Store) => void,
  thenDeps?: React.DependencyList,
): Callback =>
  useHook(
    sOrSId,
    useDelCellCallbackCore,
    [T1, rowId, _, forceDel],
    [then, thenDeps],
  );

export const T1CellView: typeof T1CellViewDecl = ({
  rowId,
  s,
  debugIds,
}: CellProps<'t1', ''>): any =>
  wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _);

export const useHasTablesListener: typeof useHasTablesListenerDecl = (
  listener: HasTablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTablesListener: typeof useTablesListenerDecl = (
  listener: TablesListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (
  listener: TableIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasTableListener: typeof useHasTableListenerDecl = (
  tableId: TableId | null,
  listener: HasTableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useTableListener: typeof useTableListenerDecl = (
  tableId: TableId | null,
  listener: TableListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useTableCellIdsListener: typeof useTableCellIdsListenerDecl = (
  tableId: TableId | null,
  listener: TableCellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useTableCellIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasTableCellListener: typeof useHasTableCellListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | null,
  listener: HasTableCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasTableCellListenerCore, [
    tableId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowCountListener: typeof useRowCountListenerDecl = (
  tableId: TableId | null,
  listener: RowCountListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowCountListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (
  tableId: TableId | null,
  listener: RowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowIdsListenerCore, [
    tableId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (
  tableId: TableId | null,
  cellId: T1CellId | undefined,
  descending: boolean,
  offset: number,
  limit: number | undefined,
  listener: SortedRowIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useSortedRowIdsListenerCore, [
    tableId,
    cellId,
    descending,
    offset,
    limit,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasRowListener: typeof useHasRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: HasRowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useRowListener: typeof useRowListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: RowListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useRowListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  listener: CellIdsListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellIdsListenerCore, [
    tableId,
    rowId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useHasCellListener: typeof useHasCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: HasCellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useHasCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const useCellListener: typeof useCellListenerDecl = (
  tableId: TableId | null,
  rowId: IdOrNull,
  cellId: T1CellId | null,
  listener: CellListener,
  listenerDeps?: React.DependencyList,
  mutator?: boolean,
  sOrSId?: SOrSId,
): void =>
  useHook(sOrSId, useCellListenerCore, [
    tableId,
    rowId,
    cellId,
    listener,
    listenerDeps,
    mutator,
  ]);

export const Provider: typeof ProviderDecl = ({
  s,
  sById,
  children,
}: ProviderProps & {children: React.ReactNode}): any => {
  const contextValue = useContext(Context);
  return (
    <Context.Provider
      value={useMemo(
        () => [s ?? contextValue[0], {...contextValue[1], ...sById}],
        [s, sById, contextValue],
      )}
    >
      {children}
    </Context.Provider>
  );
};
",
]
`;

exports[`API Unpretty both 1`] = `
[
  "import {CellChange, DoRollback, GetTransactionChanges, GetTransactionLog, Id, IdOrNull, Ids, Json, Store, TransactionChanges, ValueChange} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = Extract<keyof Row<TId>, Id>;

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** A function that takes a Cell Id, and count of how many times it appears. */
export type TableCellCallback<TId extends TableId> = (cellId: CellId<TId>, count: number)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

/** A function for listening to changes to the existence of Tables in the Store. */
export type HasTablesListener = (s: S, hasTables: boolean) => void;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to the existence of a Table in the Store. */
export type HasTableListener = (s: S, tableId: TableId, hasTable: boolean) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids anywhere in a Table. */
export type TableCellIdsListener = (s: S, tableId: TableId) => void;

/** Cell args for HasTableCellListener. */
type HasTableCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, cellId: CId, hasTableCell: boolean] : never;

/** Table args for HasTableCellListener. */
type HasTableCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? HasTableCellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to the existence of a Cell anywhere in a Table. */
export type HasTableCellListener = (...[s, tableId, cellId, hasTableCell]: HasTableCellListenerArgsArrayOuter) => void;

/** A function for listening to changes to the number of Rows in a Table. */
export type RowCountListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the sorted Row Ids in a Table. */
export type SortedRowIdsListener = (s: S, tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, sortedRowIds: Ids) => void;

/** A function for listening to changes to the existence of a Row in a Table. */
export type HasRowListener = (s: S, tableId: TableId, rowId: Id, hasRow: boolean) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** Cell args for HasCellListener. */
type HasCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, hasCell: boolean] : never;

/** Table args for HasCellListener. */
type HasCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? HasCellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to the existence of a Cell in a Row. */
export type HasCellListener = (...[s, tableId, rowId, cellId, hasCell]: HasCellListenerArgsArrayOuter) => void;

/** Cell args for CellListener. */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, newCell: Cell<TId, CId>  | undefined, oldCell: Cell<TId, CId>  | undefined, getCellChange: GetCellChange  | undefined] : never;

/** Table args for CellListener. */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? CellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: CellListenerArgsArrayOuter) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Represents the 't1' Table. */
export type T1Table = Table<'t1'>;

/** Represents the 't1' Table when setting it. */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = Row<'t1'>;

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/** A Cell Id for the 't1' Table. */
export type T1CellId = CellId<'t1'>;

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = CellCallback<'t1'>;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = RowCallback<'t1'>;

/** A function that takes a Cell Id from anywhere in the 't1' Table, and a count of how many times it appears. */
export type T1TableCellCallback = TableCellCallback<'t1'>;

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

/** A Value Id in the Store. */
export type ValueId = keyof Values;

/** A Value Id in the Store. */
export type Value<VId extends ValueId> = NonNullable<Values[VId]>;

/** Value Ids and types in the Store. */
type ValueIdValueArray<VId = ValueId> = VId extends ValueId ? [valueId: VId, value: Value<VId>] : never;

/** A function that takes a Value Id, and Value. */
export type ValueCallback = (...[valueId, value]: ValueIdValueArray) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to the existence of Values in the Store. */
export type HasValuesListener = (s: S, hasValues: boolean) => void;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to the existence of a Value in the Store. */
export type HasValueListener = (s: S, valueId: ValueId, hasValue: boolean) => void;

/** Value args for ValueListener. */
type ValueListenerArgsArray<VId = ValueId> = VId extends ValueId ? [s: S, valueId: VId, newValue: Value<VId>  | undefined, oldValue: Value<VId>  | undefined, getValueChange: GetValueChange  | undefined] : never;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: ValueListenerArgsArray) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, getTransactionChanges: GetTransactionChanges, getTransactionLog: GetTransactionLog) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1TableWhenSet): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Cells in the whole of the 't1' Table. */
getT1TableCellIds(): Ids;

/** Calls a function for each TableCell in the whole of the 't1' Table. */
forEachT1TableCell(tableCellCallback: T1TableCellCallback): void;

/** Gets the number of Rows in the the 't1' Table. */
getT1RowCount(): number;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Add a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet, reuseIds?: boolean): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Checks existence of the 'c1' Cell anywhere in the 't1' Table. */
hasT1C1TableCell(): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Checks existence of the 'c2' Cell anywhere in the 't1' Table. */
hasT1C2TableCell(): boolean;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Checks existence of the 'c3' Cell anywhere in the 't1' Table. */
hasT1C3TableCell(): boolean;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Checks existence of the '' Cell anywhere in the 't1' Table. */
hasT1TableCell(): boolean;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the existence of the tabular content of the Store changes. */
addHasTablesListener(listener: HasTablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Table in the Store changes. */
addHasTableListener(tableId: TableId | null, listener: HasTableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids anywhere in a Table change. */
addTableCellIdsListener(tableId: TableId | null, listener: TableCellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Cell anywhere in a Table changes. */
addHasTableCellListener(tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the number of Rows in a Table changes. */
addRowCountListener(tableId: TableId | null, listener: RowCountListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
addSortedRowIdsListener<TId extends TableId>(tableId: TId, cellId: CellId<TId> | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Row in a Table changes. */
addHasRowListener(tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Cell in a Row changes. */
addHasCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number | MapNumber): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string | MapString): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string | MapString): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string | MapString): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the existence of the keyed value content of the Store changes. */
addHasValuesListener(listener: HasValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Value in the Store changes. */
addHasValueListener(valueId: ValueId | null, listener: HasValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets the content of the Store. */
getContent(): [Tables, Values];

/** Sets the content of the Store. */
setContent([tables, values]: [Tables, Values]): S;

/** Applies a set of TransactionChanges to the Store. */
applyChanges(changes: TransactionChanges): S;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(tablesAndValuesJson: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback): S;

/** Registers a listener that will be called just before the start of the transaction. */
addStartTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellId, CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, HasValueListener, HasValuesListener, InvalidCellListener, InvalidValueListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, T1TableCellCallback, T1TableWhenSet, TableCallback, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, TransactionChanges, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
})
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: TablesWhenSet): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1TableWhenSet): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1TableCellIds: (): Ids => store.getTableCellIds(T1) as Ids,

forEachT1TableCell: (tableCellCallback: T1TableCellCallback): void => store.forEachTableCell(T1, tableCellCallback as any),

getT1RowCount: (): number => store.getRowCount(T1) as number,

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet, reuseIds?: boolean): Id | undefined => store.addRow(T1, row, reuseIds),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

hasT1C1TableCell: (): boolean => store.hasTableCell(T1, C1),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

hasT1C2TableCell: (): boolean => store.hasTableCell(T1, C2),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

hasT1C3TableCell: (): boolean => store.hasTableCell(T1, C3),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

hasT1TableCell: (): boolean => store.hasTableCell(T1, _),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addHasTablesListener: (listener: HasTablesListener, mutator?: boolean): Id => store.addHasTablesListener(proxy(listener), mutator),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addHasTableListener: (tableId: TableId | null, listener: HasTableListener, mutator?: boolean): Id => store.addHasTableListener(tableId, proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addTableCellIdsListener: (tableId: TableId | null, listener: TableCellIdsListener, mutator?: boolean): Id => store.addTableCellIdsListener(tableId, proxy(listener), mutator),

addHasTableCellListener: (tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, mutator?: boolean): Id => store.addHasTableCellListener(tableId,  cellId, proxy(listener), mutator),

addRowCountListener: (tableId: TableId | null, listener: RowCountListener, mutator?: boolean): Id => store.addRowCountListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addSortedRowIdsListener: <TId extends TableId>(tableId: TId, cellId: CellId<TId> | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id => store.addSortedRowIdsListener(tableId, cellId, descending, offset, limit, proxy(listener), mutator),

addHasRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, mutator?: boolean): Id => store.addHasRowListener(tableId, rowId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addHasCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, mutator?: boolean): Id => store.addHasCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number | MapNumber): S => fluent(() => store.setValue(V1, value as any)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string | MapString): S => fluent(() => store.setValue(V2, value as any)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string | MapString): S => fluent(() => store.setValue(V3, value as any)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string | MapString): S => fluent(() => store.setValue(_, value as any)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addHasValuesListener: (listener: HasValuesListener, mutator?: boolean): Id => store.addHasValuesListener(proxy(listener), mutator),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addHasValueListener: (valueId: ValueId | null, listener: HasValueListener, mutator?: boolean): Id => store.addHasValueListener(valueId, proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

setContent: ([tables, values]: [Tables, Values]): S => fluent(() => store.setContent([tables, values])),

applyChanges: (changes: TransactionChanges): S => fluent(() => store.applyChanges(changes)),

getJson: (): Json => store.getJson() as Json,

setJson: (tablesAndValuesJson: Json): S => fluent(() => store.setJson(tablesAndValuesJson)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback): S => fluent(() => store.finishTransaction(doRollback)),

addStartTransactionListener: (listener: TransactionListener): Id => store.addStartTransactionListener(proxy(listener)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellId, CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, HasValueListener, HasValuesListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders a Cell. */
export type CellProps<TId extends TableId, CId extends CellId<TId>> = {readonly tableId?: TId; readonly rowId: Id; readonly cellId?: CId; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders a Row. */
export type RowProps<TId extends TableId> = {readonly tableId?: TId; readonly rowId: Id; readonly s?: S; readonly cellComponents?: {readonly [CId in CellId<TId>]?: ComponentType<CellProps<TId, CId>>;}; readonly getCellComponentProps?: (cellId: CellId<TId>) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Table. */
export type TableProps<TId extends TableId> = {readonly tableId?: TId; readonly s?: S; readonly rowComponent?: ComponentType<RowProps<TId>>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a sorted Table. */
export type SortedTableProps<TId extends TableId> = {readonly tableId?: TId; readonly cellId?: CellId<TId>; readonly descending?: boolean; readonly offset?: number; readonly limit?: number; readonly s?: S; readonly rowComponent?: ComponentType<RowProps<TId>>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the tabular content of the Store. */
export type TablesProps = {readonly s?: S; readonly tableComponents?: {readonly [TId in TableId]?: ComponentType<TableProps<TId>>;}; readonly getTableComponentProps?: (tableId: TableId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Value. */
export type ValueProps<VId extends ValueId> = {readonly valueId?: VId; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the keyed value content of the Store. */
export type ValuesProps = {readonly s?: S; readonly valueComponents?: {readonly [VId in ValueId]?: ComponentType<ValueProps<VId>>;}; readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the existence of the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasTables(sOrSId?: SOrSId): boolean;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/** Gets a callback that can set the tabular content of the Store, based on a parameter. */
export function useSetTablesCallback<Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the tabular content of the Store. */
export function useDelTablesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function TablesView({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): ComponentReturnType;

/** Gets the existence of the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Table(sOrSId?: SOrSId): boolean;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Cells in the whole of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1TableCellIds(sOrSId?: SOrSId): Ids;

/** Gets the number of Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowCount(sOrSId?: SOrSId): number;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the existence of the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Row(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/** Gets a callback that can set the content of the 't1' Table, based on a parameter. */
export function useSetT1TableCallback<Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the 't1' Table. */
export function useDelT1TableCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Gets a callback that can set the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1RowCallback<Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can add the content of the specified Row in the 't1' Table, based on a parameter. */
export function useAddT1RowCallback<Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList, reuseRowIds?: boolean): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1PartialRowCallback<Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the specified Row in the 't1' Table. */
export function useDelT1RowCallback(rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1RowView({rowId, s, cellComponents, getCellComponentProps, customCellIds, separator, debugIds}: RowProps<'t1'>): ComponentReturnType;

/** Renders the content of the 't1' Table, sorted, and registers a listener so that any changes to that result will cause a re-render. */
export function T1SortedTableView({cellId, descending, offset, limit, ...props}: SortedTableProps<'t1'>): ComponentReturnType;

/** Renders the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1TableView(props: TableProps<'t1'>): ComponentReturnType;

/** Gets the existence of the 'c1' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C1TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'c1' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c1' Cell for the specified Row in the 't1' Table. */
export function useDelT1C1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C1CellView({rowId, s, debugIds}: CellProps<'t1', 'c1'>): ComponentReturnType;

/** Gets the existence of the 'c2' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C2TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C2Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c2' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C2CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c2' Cell for the specified Row in the 't1' Table. */
export function useDelT1C2CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C2CellView({rowId, s, debugIds}: CellProps<'t1', 'c2'>): ComponentReturnType;

/** Gets the existence of the 'c3' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C3TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C3Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c3' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C3CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c3' Cell for the specified Row in the 't1' Table. */
export function useDelT1C3CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C3CellView({rowId, s, debugIds}: CellProps<'t1', 'c3'>): ComponentReturnType;

/** Gets the existence of the '' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Gets a callback that can set the '' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Cell for the specified Row in the 't1' Table. */
export function useDelT1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1CellView({rowId, s, debugIds}: CellProps<'t1', ''>): ComponentReturnType;

/** Registers a listener that will be called whenever the existence of the tabular content of the Store changes. */
export function useHasTablesListener(listener: HasTablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
export function useTablesListener(listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
export function useTableIdsListener(listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Table in the Store changes. */
export function useHasTableListener(tableId: TableId | null, listener: HasTableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Table in the Store changes. */
export function useTableListener(tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids anywhere in a Table change. */
export function useTableCellIdsListener(tableId: TableId | null, listener: TableCellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Cell anywhere in a Table changes. */
export function useHasTableCellListener(tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the number of Rows in a Table changes. */
export function useRowCountListener(tableId: TableId | null, listener: RowCountListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
export function useRowIdsListener(tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
export function useSortedRowIdsListener(tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Row in a Table changes. */
export function useHasRowListener(tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Row in a Table changes. */
export function useRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
export function useCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Cell in a Row changes. */
export function useHasCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
export function useCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Gets the existence of the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasValues(sOrSId?: SOrSId): boolean;

/** Gets the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValues(sOrSId?: SOrSId): Values;

/** Gets the Ids of the Values in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/** Gets a callback that can set the keyed value content of the Store, based on a parameter. */
export function useSetValuesCallback<Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the keyed value content of the Store, based on a parameter. */
export function useSetPartialValuesCallback<Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the keyed value content of the Store. */
export function useDelValuesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function ValuesView({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): ComponentReturnType;

/** Gets the existence of the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV1Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV1Value(sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'v1' Value, based on a parameter. */
export function useSetV1ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v1' Value. */
export function useDelV1ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V1ValueView({s, debugIds}: ValueProps<'v1'>): ComponentReturnType;

/** Gets the existence of the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV2Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV2Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v2' Value, based on a parameter. */
export function useSetV2ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v2' Value. */
export function useDelV2ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V2ValueView({s, debugIds}: ValueProps<'v2'>): ComponentReturnType;

/** Gets the existence of the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV3Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV3Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v3' Value, based on a parameter. */
export function useSetV3ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v3' Value. */
export function useDelV3ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V3ValueView({s, debugIds}: ValueProps<'v3'>): ComponentReturnType;

/** Gets the existence of the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasValue(sOrSId?: SOrSId): boolean;

/** Gets the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useValue(sOrSId?: SOrSId): string;

/** Gets a callback that can set the '' Value, based on a parameter. */
export function useSetValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Value. */
export function useDelValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function ValueView({s, debugIds}: ValueProps<''>): ComponentReturnType;

/** Registers a listener that will be called whenever the existence of the keyed value content of the Store changes. */
export function useHasValuesListener(listener: HasValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
export function useValuesListener(listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
export function useValueIdsListener(listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Value in the Store changes. */
export function useHasValueListener(valueId: ValueId | null, listener: HasValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Value in the Store changes. */
export function useValueListener(valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, HasValueListener, HasValuesListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {CellProps, Provider as ProviderDecl, ProviderProps, RowProps, SOrSId, SortedTableProps, T1C1CellView as T1C1CellViewDecl, T1C2CellView as T1C2CellViewDecl, T1C3CellView as T1C3CellViewDecl, T1CellView as T1CellViewDecl, T1RowView as T1RowViewDecl, T1SortedTableView as T1SortedTableViewDecl, T1TableView as T1TableViewDecl, TableProps, TablesProps, TablesView as TablesViewDecl, V1ValueView as V1ValueViewDecl, V2ValueView as V2ValueViewDecl, V3ValueView as V3ValueViewDecl, ValueProps, ValueView as ValueViewDecl, ValuesProps, ValuesView as ValuesViewDecl, useAddT1RowCallback as useAddT1RowCallbackDecl, useCellIdsListener as useCellIdsListenerDecl, useCellListener as useCellListenerDecl, useCreateS as useCreateSDecl, useDelT1C1CellCallback as useDelT1C1CellCallbackDecl, useDelT1C2CellCallback as useDelT1C2CellCallbackDecl, useDelT1C3CellCallback as useDelT1C3CellCallbackDecl, useDelT1CellCallback as useDelT1CellCallbackDecl, useDelT1RowCallback as useDelT1RowCallbackDecl, useDelT1TableCallback as useDelT1TableCallbackDecl, useDelTablesCallback as useDelTablesCallbackDecl, useDelV1ValueCallback as useDelV1ValueCallbackDecl, useDelV2ValueCallback as useDelV2ValueCallbackDecl, useDelV3ValueCallback as useDelV3ValueCallbackDecl, useDelValueCallback as useDelValueCallbackDecl, useDelValuesCallback as useDelValuesCallbackDecl, useHasCellListener as useHasCellListenerDecl, useHasRowListener as useHasRowListenerDecl, useHasT1C1Cell as useHasT1C1CellDecl, useHasT1C1TableCell as useHasT1C1TableCellDecl, useHasT1C2Cell as useHasT1C2CellDecl, useHasT1C2TableCell as useHasT1C2TableCellDecl, useHasT1C3Cell as useHasT1C3CellDecl, useHasT1C3TableCell as useHasT1C3TableCellDecl, useHasT1Cell as useHasT1CellDecl, useHasT1Row as useHasT1RowDecl, useHasT1TableCell as useHasT1TableCellDecl, useHasT1Table as useHasT1TableDecl, useHasTableCellListener as useHasTableCellListenerDecl, useHasTableListener as useHasTableListenerDecl, useHasTables as useHasTablesDecl, useHasTablesListener as useHasTablesListenerDecl, useHasV1Value as useHasV1ValueDecl, useHasV2Value as useHasV2ValueDecl, useHasV3Value as useHasV3ValueDecl, useHasValue as useHasValueDecl, useHasValueListener as useHasValueListenerDecl, useHasValues as useHasValuesDecl, useHasValuesListener as useHasValuesListenerDecl, useRowCountListener as useRowCountListenerDecl, useRowIdsListener as useRowIdsListenerDecl, useRowListener as useRowListenerDecl, useS as useSDecl, useSetPartialValuesCallback as useSetPartialValuesCallbackDecl, useSetT1C1CellCallback as useSetT1C1CellCallbackDecl, useSetT1C2CellCallback as useSetT1C2CellCallbackDecl, useSetT1C3CellCallback as useSetT1C3CellCallbackDecl, useSetT1CellCallback as useSetT1CellCallbackDecl, useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl, useSetT1RowCallback as useSetT1RowCallbackDecl, useSetT1TableCallback as useSetT1TableCallbackDecl, useSetTablesCallback as useSetTablesCallbackDecl, useSetV1ValueCallback as useSetV1ValueCallbackDecl, useSetV2ValueCallback as useSetV2ValueCallbackDecl, useSetV3ValueCallback as useSetV3ValueCallbackDecl, useSetValueCallback as useSetValueCallbackDecl, useSetValuesCallback as useSetValuesCallbackDecl, useSortedRowIdsListener as useSortedRowIdsListenerDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1RowCount as useT1RowCountDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1TableCellIds as useT1TableCellIdsDecl, useT1Table as useT1TableDecl, useTableCellIdsListener as useTableCellIdsListenerDecl, useTableIds as useTableIdsDecl, useTableIdsListener as useTableIdsListenerDecl, useTableListener as useTableListenerDecl, useTables as useTablesDecl, useTablesListener as useTablesListenerDecl, useV1Value as useV1ValueDecl, useV2Value as useV2ValueDecl, useV3Value as useV3ValueDecl, useValue as useValueDecl, useValueIds as useValueIdsDecl, useValueIdsListener as useValueIdsListenerDecl, useValueListener as useValueListenerDecl, useValues as useValuesDecl, useValuesListener as useValuesListenerDecl} from './s-ui-react.d';
import {ExtraProps, useAddRowCallback as useAddRowCallbackCore, useCell as useCellCore, useCellIds, useCellIds as useCellIdsCore, useCellIdsListener as useCellIdsListenerCore, useCellListener as useCellListenerCore, useDelCellCallback as useDelCellCallbackCore, useDelRowCallback as useDelRowCallbackCore, useDelTableCallback as useDelTableCallbackCore, useDelTablesCallback as useDelTablesCallbackCore, useDelValueCallback as useDelValueCallbackCore, useDelValuesCallback as useDelValuesCallbackCore, useHasCell as useHasCellCore, useHasCellListener as useHasCellListenerCore, useHasRow as useHasRowCore, useHasRowListener as useHasRowListenerCore, useHasTableCell as useHasTableCellCore, useHasTableCellListener as useHasTableCellListenerCore, useHasTable as useHasTableCore, useHasTableListener as useHasTableListenerCore, useHasTables as useHasTablesCore, useHasTablesListener as useHasTablesListenerCore, useHasValue as useHasValueCore, useHasValueListener as useHasValueListenerCore, useHasValues as useHasValuesCore, useHasValuesListener as useHasValuesListenerCore, useRow as useRowCore, useRowCount as useRowCountCore, useRowCountListener as useRowCountListenerCore, useRowIds as useRowIdsCore, useRowIdsListener as useRowIdsListenerCore, useRowListener as useRowListenerCore, useSetCellCallback as useSetCellCallbackCore, useSetPartialRowCallback as useSetPartialRowCallbackCore, useSetPartialValuesCallback as useSetPartialValuesCallbackCore, useSetRowCallback as useSetRowCallbackCore, useSetTableCallback as useSetTableCallbackCore, useSetTablesCallback as useSetTablesCallbackCore, useSetValueCallback as useSetValueCallbackCore, useSetValuesCallback as useSetValuesCallbackCore, useSortedRowIds as useSortedRowIdsCore, useSortedRowIdsListener as useSortedRowIdsListenerCore, useTableCellIds as useTableCellIdsCore, useTableCellIdsListener as useTableCellIdsListenerCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTableIdsListener as useTableIdsListenerCore, useTableListener as useTableListenerCore, useTables as useTablesCore, useTablesListener as useTablesListenerCore, useValue as useValueCore, useValueIds as useValueIdsCore, useValueIdsListener as useValueIdsListenerCore, useValueListener as useValueListenerCore, useValues as useValuesCore, useValuesListener as useValuesListenerCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (customCellIds: Ids | undefined, tableId: Id, rowId: Id, sOrSId?: SOrSId | undefined) => {
const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const tableView = ({s, rowComponent, getRowComponentProps, customCellIds, separator, debugIds}: any, rowIds: Ids, tableId: Id, defaultRowComponent: React.ComponentType<any>) => {
const Row = rowComponent ?? defaultRowComponent;
return wrap(rowIds.map((rowId) => (
<Row
{...getProps(getRowComponentProps, rowId)}
key={rowId}
tableId={tableId}
rowId={rowId}
customCellIds={customCellIds}
s={s}
debugIds={debugIds}
/>
))
, separator, debugIds
, tableId,
);
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) => tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) => tableId == T1 ? cellId == C1 ? T1C1CellView : cellId == C2 ? T1C2CellView : cellId == C3 ? T1C3CellView : cellId == _ ? T1CellView : NullComponent : NullComponent;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const getDefaultValueComponent = (valueId: Id) => valueId == V1 ? V1ValueView : valueId == V2 ? V2ValueView : valueId == V3 ? V3ValueView : valueId == _ ? ValueView : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useHasTables: typeof useHasTablesDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTablesCore, []);

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId[] =>
useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTablesCallbackCore, [getTables, getTablesDeps], [then, thenDeps]);

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): any =>
wrap(useTableIds(s).map((tableId) => {
const Table = (tableComponents?.[tableId] ?? getDefaultTableComponent(tableId)) as React.ComponentType<TableProps<typeof tableId>>;
return <Table
{...getProps(getTableComponentProps, tableId)}
tableId={tableId}
key={tableId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useHasT1Table: typeof useHasT1TableDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCore, [T1]);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, [T1]);

export const useT1TableCellIds: typeof useT1TableCellIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useTableCellIdsCore, [T1]);

export const useT1RowCount: typeof useT1RowCountDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useRowCountCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useHasT1Row: typeof useHasT1RowDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasRowCore, [T1, rowId]);

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): T1CellId[] =>
useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTableCallbackCore, [T1, getTable, getTableDeps], [then, thenDeps]);

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetRowCallbackCore, [T1, rowId, getRow, getRowDeps], [then, thenDeps]);

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList, reuseRowIds?: boolean): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useAddRowCallbackCore, [T1, getRow, getRowDeps], [then, thenDeps, reuseRowIds]);

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl = <Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialRowCallbackCore, [T1, rowId, getPartialRow, getPartialRowDeps], [then, thenDeps]);

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({rowId, s, cellComponents, getCellComponentProps, customCellIds, separator, debugIds}: RowProps<'t1'>): any =>
wrap(useCustomOrDefaultCellIds(customCellIds, T1, rowId, s).map((cellId: T1CellId) => {
const Cell = (cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId)) as React.ComponentType<CellProps<typeof T1, typeof cellId>>;
return <Cell
{...getProps(getCellComponentProps, cellId)} 
key={cellId}
tableId={T1}
rowId={rowId}
cellId={cellId}
s={s}
debugIds={debugIds}
/>;
}), separator, debugIds, rowId)

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({cellId, descending, offset, limit, ...props}: SortedTableProps<'t1'>): any =>
tableView(props, useT1SortedRowIds(cellId, descending, offset, limit, props.s), T1, T1RowView);

export const T1TableView: typeof T1TableViewDecl = (props: TableProps<'t1'>): any =>
tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useHasT1C1TableCell: typeof useHasT1C1TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C1]);

export const useHasT1C1Cell: typeof useHasT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C1]);

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C1, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C1, forceDel], [then, thenDeps]);

export const T1C1CellView: typeof T1C1CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c1'>): any =>
wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1)

export const useHasT1C2TableCell: typeof useHasT1C2TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C2]);

export const useHasT1C2Cell: typeof useHasT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C2]);

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C2, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C2, forceDel], [then, thenDeps]);

export const T1C2CellView: typeof T1C2CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c2'>): any =>
wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2)

export const useHasT1C3TableCell: typeof useHasT1C3TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C3]);

export const useHasT1C3Cell: typeof useHasT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C3]);

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C3, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C3, forceDel], [then, thenDeps]);

export const T1C3CellView: typeof T1C3CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c3'>): any =>
wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3)

export const useHasT1TableCell: typeof useHasT1TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, _]);

export const useHasT1Cell: typeof useHasT1CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, _]);

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, _, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, _, forceDel], [then, thenDeps]);

export const T1CellView: typeof T1CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', ''>): any =>
wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _)

export const useHasTablesListener: typeof useHasTablesListenerDecl = (listener: HasTablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTablesListener: typeof useTablesListenerDecl = (listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasTableListener: typeof useHasTableListenerDecl = (tableId: TableId | null, listener: HasTableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useTableCellIdsListener: typeof useTableCellIdsListenerDecl = (tableId: TableId | null, listener: TableCellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableCellIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useHasTableCellListener: typeof useHasTableCellListenerDecl = (tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTableCellListenerCore, [tableId, cellId, listener, listenerDeps, mutator]);

export const useRowCountListener: typeof useRowCountListenerDecl = (tableId: TableId | null, listener: RowCountListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowCountListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useSortedRowIdsListenerCore, [tableId, cellId, descending, offset, limit, listener, listenerDeps, mutator]);

export const useHasRowListener: typeof useHasRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useRowListener: typeof useRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellIdsListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useHasCellListener: typeof useHasCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const useCellListener: typeof useCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const useHasValues: typeof useHasValuesDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValuesCore, []);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (sOrSId?: SOrSId): ValueId[] =>
useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValuesCallbackCore, [getValues, getValuesDeps], [then, thenDeps]);

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl = <Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialValuesCallbackCore, [getPartialValues, getPartialValuesDeps], [then, thenDeps]);

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): any =>
wrap(useValueIds(s).map((valueId) => {
const Value = valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
return <Value
{...getProps(getValueComponentProps, valueId)}
key={valueId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useHasV1Value: typeof useHasV1ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V1]);

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V1, getValue, getValueDeps], [then, thenDeps]);

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({s, debugIds}: ValueProps<'v1'>): any =>
wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1)

export const useHasV2Value: typeof useHasV2ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V2]);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V2, getValue, getValueDeps], [then, thenDeps]);

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({s, debugIds}: ValueProps<'v2'>): any =>
wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2)

export const useHasV3Value: typeof useHasV3ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V3]);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V3, getValue, getValueDeps], [then, thenDeps]);

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({s, debugIds}: ValueProps<'v3'>): any =>
wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3)

export const useHasValue: typeof useHasValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [_]);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [_, getValue, getValueDeps], [then, thenDeps]);

export const useDelValueCallback: typeof useDelValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({s, debugIds}: ValueProps<''>): any =>
wrap('' + useValue(s) ?? '', undefined, debugIds, _)

export const useHasValuesListener: typeof useHasValuesListenerDecl = (listener: HasValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValuesListener: typeof useValuesListenerDecl = (listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasValueListener: typeof useHasValueListenerDecl = (valueId: ValueId | null, listener: HasValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty keyed value 1`] = `
[
  "import {DoRollback, GetTransactionChanges, GetTransactionLog, Id, IdOrNull, Json, Store, Tables, TransactionChanges, ValueChange} from 'tinybase';

/** Represents the keyed value content of the Store. */
export type Values = {'v1': number; 'v2': string; 'v3': string; ''?: string};

/** Represents the keyed value content of the Store when setting it. */
export type ValuesWhenSet = {'v1'?: number; 'v2'?: string; 'v3'?: string; ''?: string};

/** A Value Id in the Store. */
export type ValueId = keyof Values;

/** A Value Id in the Store. */
export type Value<VId extends ValueId> = NonNullable<Values[VId]>;

/** Value Ids and types in the Store. */
type ValueIdValueArray<VId = ValueId> = VId extends ValueId ? [valueId: VId, value: Value<VId>] : never;

/** A function that takes a Value Id, and Value. */
export type ValueCallback = (...[valueId, value]: ValueIdValueArray) => void;

/** A function for returning information about any Value's changes during a transaction. */
export type GetValueChange = (valueId: ValueId) => ValueChange;

/** A function for listening to changes to the existence of Values in the Store. */
export type HasValuesListener = (s: S, hasValues: boolean) => void;

/** A function for listening to changes to Values in the Store. */
export type ValuesListener = (s: S, getValueChange: GetValueChange | undefined) => void;

/** A function for listening to changes to the Value Ids in the Store. */
export type ValueIdsListener = (s: S) => void;

/** A function for listening to changes to the existence of a Value in the Store. */
export type HasValueListener = (s: S, valueId: ValueId, hasValue: boolean) => void;

/** Value args for ValueListener. */
type ValueListenerArgsArray<VId = ValueId> = VId extends ValueId ? [s: S, valueId: VId, newValue: Value<VId>  | undefined, oldValue: Value<VId>  | undefined, getValueChange: GetValueChange  | undefined] : never;

/** A function for listening to changes to a Value in the Store. */
export type ValueListener = (...[s, valueId, newValue, oldValue, getValueChange]: ValueListenerArgsArray) => void;

/** A function for listening to changes to invalid Value changes in the Store. */
export type InvalidValueListener = (s: S, valueId: Id, invalidValues: any[]) => void;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, getTransactionChanges: GetTransactionChanges, getTransactionLog: GetTransactionLog) => void;

export interface S {
/** Gets the keyed value content of the Store. */
getValues(): Values;

/** Checks existence of the keyed value content of the Store. */
hasValues(): boolean;

/** Sets the keyed value content of the Store. */
setValues(values: ValuesWhenSet): S;

/** Deletes the keyed value content of the Store. */
delValues(): S;

/** Sets part of the keyed value content of the Store. */
setPartialValues(partialValues: ValuesWhenSet): S;

/** Gets the Ids of the Values in the Store. */
getValueIds(): ValueId[];

/** Calls a function for each Value in the Store. */
forEachValue(valueCallback: ValueCallback): void;

/** Gets the 'v1' Value. */
getV1Value(): number;

/** Checks existence of the 'v1' Value. */
hasV1Value(): boolean;

/** Sets the 'v1' Value. */
setV1Value(value: number | MapNumber): S;

/** Deletes the 'v1' Value. */
delV1Value(): S;

/** Gets the 'v2' Value. */
getV2Value(): string;

/** Checks existence of the 'v2' Value. */
hasV2Value(): boolean;

/** Sets the 'v2' Value. */
setV2Value(value: string | MapString): S;

/** Deletes the 'v2' Value. */
delV2Value(): S;

/** Gets the 'v3' Value. */
getV3Value(): string;

/** Checks existence of the 'v3' Value. */
hasV3Value(): boolean;

/** Sets the 'v3' Value. */
setV3Value(value: string | MapString): S;

/** Deletes the 'v3' Value. */
delV3Value(): S;

/** Gets the '' Value. */
getValue(): string;

/** Checks existence of the '' Value. */
hasValue(): boolean;

/** Sets the '' Value. */
setValue(value: string | MapString): S;

/** Deletes the '' Value. */
delValue(): S;

/** Gets a string serialization of the keyed value content of the Store. */
getValuesJson(): Json;

/** Sets a string serialization of the keyed value content of the Store. */
setValuesJson(valuesJson: Json): S;

/** Registers a listener that will be called whenever the existence of the keyed value content of the Store changes. */
addHasValuesListener(listener: HasValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
addValuesListener(listener: ValuesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
addValueIdsListener(listener: ValueIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Value in the Store changes. */
addHasValueListener(valueId: ValueId | null, listener: HasValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Value in the Store changes. */
addValueListener(valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Value change was attempted. */
addInvalidValueListener(valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id;

/** Gets the content of the Store. */
getContent(): [Tables, Values];

/** Sets the content of the Store. */
setContent([tables, values]: [Tables, Values]): S;

/** Applies a set of TransactionChanges to the Store. */
applyChanges(changes: TransactionChanges): S;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(tablesAndValuesJson: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback): S;

/** Registers a listener that will be called just before the start of the transaction. */
addStartTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {DoRollback, Id, IdOrNull, Json, Store, Tables, TransactionChanges, createStore} from 'tinybase';
import {HasValueListener, HasValuesListener, InvalidValueListener, MapNumber, MapString, S, TransactionListener, ValueCallback, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet, createS as createSDecl} from './s.d';

export const createS: typeof createSDecl = () => {
const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setValuesSchema({
[V1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[V2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[V3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getValues: (): Values => store.getValues() as Values,

hasValues: (): boolean => store.hasValues(),

setValues: (values: ValuesWhenSet): S => fluent(() => store.setValues(values)),

delValues: (): S => fluent(() => store.delValues()),

setPartialValues: (partialValues: ValuesWhenSet): S => fluent(() => store.setPartialValues(partialValues)),

getValueIds: (): ValueId[] => store.getValueIds() as ValueId[],

forEachValue: (valueCallback: ValueCallback): void => store.forEachValue(valueCallback as any),

getV1Value: (): number => store.getValue(V1) as number,

hasV1Value: (): boolean => store.hasValue(V1),

setV1Value: (value: number | MapNumber): S => fluent(() => store.setValue(V1, value as any)),

delV1Value: (): S => fluent(() => store.delValue(V1)),

getV2Value: (): string => store.getValue(V2) as string,

hasV2Value: (): boolean => store.hasValue(V2),

setV2Value: (value: string | MapString): S => fluent(() => store.setValue(V2, value as any)),

delV2Value: (): S => fluent(() => store.delValue(V2)),

getV3Value: (): string => store.getValue(V3) as string,

hasV3Value: (): boolean => store.hasValue(V3),

setV3Value: (value: string | MapString): S => fluent(() => store.setValue(V3, value as any)),

delV3Value: (): S => fluent(() => store.delValue(V3)),

getValue: (): string => store.getValue(_) as string,

hasValue: (): boolean => store.hasValue(_),

setValue: (value: string | MapString): S => fluent(() => store.setValue(_, value as any)),

delValue: (): S => fluent(() => store.delValue(_)),

getValuesJson: (): Json => store.getValuesJson() as Json,

setValuesJson: (valuesJson: Json): S => fluent(() => store.setValuesJson(valuesJson)),

addHasValuesListener: (listener: HasValuesListener, mutator?: boolean): Id => store.addHasValuesListener(proxy(listener), mutator),

addValuesListener: (listener: ValuesListener, mutator?: boolean): Id => store.addValuesListener(proxy(listener), mutator),

addValueIdsListener: (listener: ValueIdsListener, mutator?: boolean): Id => store.addValueIdsListener(proxy(listener), mutator),

addHasValueListener: (valueId: ValueId | null, listener: HasValueListener, mutator?: boolean): Id => store.addHasValueListener(valueId, proxy(listener), mutator),

addValueListener: (valueId: ValueId | null, listener: ValueListener, mutator?: boolean): Id => store.addValueListener(valueId, proxy(listener), mutator),

addInvalidValueListener: (valueId: IdOrNull, listener: InvalidValueListener, mutator?: boolean): Id => store.addInvalidValueListener(valueId, proxy(listener), mutator),

getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

setContent: ([tables, values]: [Tables, Values]): S => fluent(() => store.setContent([tables, values])),

applyChanges: (changes: TransactionChanges): S => fluent(() => store.applyChanges(changes)),

getJson: (): Json => store.getJson() as Json,

setJson: (tablesAndValuesJson: Json): S => fluent(() => store.setJson(tablesAndValuesJson)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback): S => fluent(() => store.finishTransaction(doRollback)),

addStartTransactionListener: (listener: TransactionListener): Id => store.addStartTransactionListener(proxy(listener)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';
import {HasValueListener, HasValuesListener, MapNumber, MapString, S, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders a Value. */
export type ValueProps<VId extends ValueId> = {readonly valueId?: VId; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders the keyed value content of the Store. */
export type ValuesProps = {readonly s?: S; readonly valueComponents?: {readonly [VId in ValueId]?: ComponentType<ValueProps<VId>>;}; readonly getValueComponentProps?: (valueId: ValueId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the existence of the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasValues(sOrSId?: SOrSId): boolean;

/** Gets the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValues(sOrSId?: SOrSId): Values;

/** Gets the Ids of the Values in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useValueIds(sOrSId?: SOrSId): ValueId[];

/** Gets a callback that can set the keyed value content of the Store, based on a parameter. */
export function useSetValuesCallback<Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the keyed value content of the Store, based on a parameter. */
export function useSetPartialValuesCallback<Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the keyed value content of the Store. */
export function useDelValuesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the keyed value content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function ValuesView({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): ComponentReturnType;

/** Gets the existence of the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV1Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV1Value(sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'v1' Value, based on a parameter. */
export function useSetV1ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v1' Value. */
export function useDelV1ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v1' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V1ValueView({s, debugIds}: ValueProps<'v1'>): ComponentReturnType;

/** Gets the existence of the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV2Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV2Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v2' Value, based on a parameter. */
export function useSetV2ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v2' Value. */
export function useDelV2ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v2' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V2ValueView({s, debugIds}: ValueProps<'v2'>): ComponentReturnType;

/** Gets the existence of the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasV3Value(sOrSId?: SOrSId): boolean;

/** Gets the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useV3Value(sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'v3' Value, based on a parameter. */
export function useSetV3ValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'v3' Value. */
export function useDelV3ValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'v3' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function V3ValueView({s, debugIds}: ValueProps<'v3'>): ComponentReturnType;

/** Gets the existence of the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasValue(sOrSId?: SOrSId): boolean;

/** Gets the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function useValue(sOrSId?: SOrSId): string;

/** Gets a callback that can set the '' Value, based on a parameter. */
export function useSetValueCallback<Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Value. */
export function useDelValueCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Value, and registers a listener so that any changes to that result will cause a re-render. */
export function ValueView({s, debugIds}: ValueProps<''>): ComponentReturnType;

/** Registers a listener that will be called whenever the existence of the keyed value content of the Store changes. */
export function useHasValuesListener(listener: HasValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the keyed value content of the Store changes. */
export function useValuesListener(listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Value Ids in the Store change. */
export function useValueIdsListener(listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Value in the Store changes. */
export function useHasValueListener(valueId: ValueId | null, listener: HasValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Value in the Store changes. */
export function useValueListener(valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, ParameterizedCallback, Store} from 'tinybase';
import {ExtraProps, useCellIds, useDelValueCallback as useDelValueCallbackCore, useDelValuesCallback as useDelValuesCallbackCore, useHasValue as useHasValueCore, useHasValueListener as useHasValueListenerCore, useHasValues as useHasValuesCore, useHasValuesListener as useHasValuesListenerCore, useSetPartialValuesCallback as useSetPartialValuesCallbackCore, useSetValueCallback as useSetValueCallbackCore, useSetValuesCallback as useSetValuesCallbackCore, useValue as useValueCore, useValueIds as useValueIdsCore, useValueIdsListener as useValueIdsListenerCore, useValueListener as useValueListenerCore, useValues as useValuesCore, useValuesListener as useValuesListenerCore} from 'tinybase/ui-react';
import {HasValueListener, HasValuesListener, MapNumber, MapString, S, ValueId, ValueIdsListener, ValueListener, Values, ValuesListener, ValuesWhenSet} from './s.d';
import {Provider as ProviderDecl, ProviderProps, SOrSId, V1ValueView as V1ValueViewDecl, V2ValueView as V2ValueViewDecl, V3ValueView as V3ValueViewDecl, ValueProps, ValueView as ValueViewDecl, ValuesProps, ValuesView as ValuesViewDecl, useCreateS as useCreateSDecl, useDelV1ValueCallback as useDelV1ValueCallbackDecl, useDelV2ValueCallback as useDelV2ValueCallbackDecl, useDelV3ValueCallback as useDelV3ValueCallbackDecl, useDelValueCallback as useDelValueCallbackDecl, useDelValuesCallback as useDelValuesCallbackDecl, useHasV1Value as useHasV1ValueDecl, useHasV2Value as useHasV2ValueDecl, useHasV3Value as useHasV3ValueDecl, useHasValue as useHasValueDecl, useHasValueListener as useHasValueListenerDecl, useHasValues as useHasValuesDecl, useHasValuesListener as useHasValuesListenerDecl, useS as useSDecl, useSetPartialValuesCallback as useSetPartialValuesCallbackDecl, useSetV1ValueCallback as useSetV1ValueCallbackDecl, useSetV2ValueCallback as useSetV2ValueCallbackDecl, useSetV3ValueCallback as useSetV3ValueCallbackDecl, useSetValueCallback as useSetValueCallbackDecl, useSetValuesCallback as useSetValuesCallbackDecl, useV1Value as useV1ValueDecl, useV2Value as useV2ValueDecl, useV3Value as useV3ValueDecl, useValue as useValueDecl, useValueIds as useValueIdsDecl, useValueIdsListener as useValueIdsListenerDecl, useValueListener as useValueListenerDecl, useValues as useValuesDecl, useValuesListener as useValuesListenerDecl} from './s-ui-react.d';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (customCellIds: Ids | undefined, tableId: Id, rowId: Id, sOrSId?: SOrSId | undefined) => {
const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const V1 = 'v1';

const V2 = 'v2';

const V3 = 'v3';

const _ = '';

const getDefaultValueComponent = (valueId: Id) => valueId == V1 ? V1ValueView : valueId == V2 ? V2ValueView : valueId == V3 ? V3ValueView : valueId == _ ? ValueView : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useHasValues: typeof useHasValuesDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValuesCore, []);

export const useValues: typeof useValuesDecl = (sOrSId?: SOrSId): Values =>
useHook(sOrSId, useValuesCore, []);

export const useValueIds: typeof useValueIdsDecl = (sOrSId?: SOrSId): ValueId[] =>
useHook(sOrSId, useValueIdsCore, []);

export const useSetValuesCallback: typeof useSetValuesCallbackDecl = <Parameter,>(getValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, values: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValuesCallbackCore, [getValues, getValuesDeps], [then, thenDeps]);

export const useSetPartialValuesCallback: typeof useSetPartialValuesCallbackDecl = <Parameter,>(getPartialValues: (parameter: Parameter, store: Store) => ValuesWhenSet, getPartialValuesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialValues: ValuesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialValuesCallbackCore, [getPartialValues, getPartialValuesDeps], [then, thenDeps]);

export const useDelValuesCallback: typeof useDelValuesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValuesCallbackCore, [], [then, thenDeps]);

export const ValuesView: typeof ValuesViewDecl = ({s, valueComponents, getValueComponentProps, separator, debugIds}: ValuesProps): any =>
wrap(useValueIds(s).map((valueId) => {
const Value = valueComponents?.[valueId] ?? getDefaultValueComponent(valueId);
return <Value
{...getProps(getValueComponentProps, valueId)}
key={valueId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useHasV1Value: typeof useHasV1ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V1]);

export const useV1Value: typeof useV1ValueDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useValueCore, [V1]);

export const useSetV1ValueCallback: typeof useSetV1ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => number | MapNumber, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V1, getValue, getValueDeps], [then, thenDeps]);

export const useDelV1ValueCallback: typeof useDelV1ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V1], [then, thenDeps]);

export const V1ValueView: typeof V1ValueViewDecl = ({s, debugIds}: ValueProps<'v1'>): any =>
wrap('' + useV1Value(s) ?? '', undefined, debugIds, V1)

export const useHasV2Value: typeof useHasV2ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V2]);

export const useV2Value: typeof useV2ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V2]);

export const useSetV2ValueCallback: typeof useSetV2ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V2, getValue, getValueDeps], [then, thenDeps]);

export const useDelV2ValueCallback: typeof useDelV2ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V2], [then, thenDeps]);

export const V2ValueView: typeof V2ValueViewDecl = ({s, debugIds}: ValueProps<'v2'>): any =>
wrap('' + useV2Value(s) ?? '', undefined, debugIds, V2)

export const useHasV3Value: typeof useHasV3ValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [V3]);

export const useV3Value: typeof useV3ValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [V3]);

export const useSetV3ValueCallback: typeof useSetV3ValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [V3, getValue, getValueDeps], [then, thenDeps]);

export const useDelV3ValueCallback: typeof useDelV3ValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [V3], [then, thenDeps]);

export const V3ValueView: typeof V3ValueViewDecl = ({s, debugIds}: ValueProps<'v3'>): any =>
wrap('' + useV3Value(s) ?? '', undefined, debugIds, V3)

export const useHasValue: typeof useHasValueDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasValueCore, [_]);

export const useValue: typeof useValueDecl = (sOrSId?: SOrSId): string =>
useHook(sOrSId, useValueCore, [_]);

export const useSetValueCallback: typeof useSetValueCallbackDecl = <Parameter,>(getValue: (parameter: Parameter, store: Store) => string | MapString, getValueDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, value: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetValueCallbackCore, [_, getValue, getValueDeps], [then, thenDeps]);

export const useDelValueCallback: typeof useDelValueCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelValueCallbackCore, [_], [then, thenDeps]);

export const ValueView: typeof ValueViewDecl = ({s, debugIds}: ValueProps<''>): any =>
wrap('' + useValue(s) ?? '', undefined, debugIds, _)

export const useHasValuesListener: typeof useHasValuesListenerDecl = (listener: HasValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValuesListener: typeof useValuesListenerDecl = (listener: ValuesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValuesListenerCore, [listener, listenerDeps, mutator]);

export const useValueIdsListener: typeof useValueIdsListenerDecl = (listener: ValueIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasValueListener: typeof useHasValueListenerDecl = (valueId: ValueId | null, listener: HasValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const useValueListener: typeof useValueListenerDecl = (valueId: ValueId | null, listener: ValueListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useValueListenerCore, [valueId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;

exports[`API Unpretty tabular 1`] = `
[
  "import {CellChange, DoRollback, GetTransactionChanges, GetTransactionLog, Id, IdOrNull, Ids, Json, Store, TransactionChanges, Values} from 'tinybase';

/** Represents the tabular content of the Store. */
export type Tables = {'t1'?: {[rowId: Id]: {'c1': number; 'c2': string; 'c3': string; ''?: string}}};

/** Represents the tabular content of the Store when setting it. */
export type TablesWhenSet = {'t1'?: {[rowId: Id]: {'c1'?: number; 'c2'?: string; 'c3'?: string; ''?: string}}};

/** A Table Id in the Store. */
export type TableId = keyof Tables;

/** A Table in the Store. */
export type Table<TId extends TableId> = NonNullable<Tables[TId]>;

/** A Table in the Store when setting it. */
export type TableWhenSet<TId extends TableId> = NonNullable<TablesWhenSet[TId]>;

/** A Row in a Table. */
export type Row<TId extends TableId> = Table<TId>[Id];

/** A Row in a Table when setting it. */
export type RowWhenSet<TId extends TableId> = TableWhenSet<TId>[Id];

/** A Cell Id in a Row. */
export type CellId<TId extends TableId> = Extract<keyof Row<TId>, Id>;

/** A Cell in a Row. */
export type Cell<TId extends TableId, CId extends CellId<TId>> = NonNullable<Tables[TId]>[Id][CId];

/** Cell Ids and types in a Row. */
type CellIdCellArray<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [cellId: CId, cell: Cell<TId, CId>] : never;

/** A function that takes a Cell Id, and Cell. */
export type CellCallback<TId extends TableId> = (...[cellId, cell]: CellIdCellArray<TId>) => void;

/** A function that takes a Row Id, and a Cell iterator. */
export type RowCallback<TId extends TableId> = (rowId: Id, forEachCell: (cellCallback: CellCallback<TId>)  => void)  => void;

/** A function that takes a Cell Id, and count of how many times it appears. */
export type TableCellCallback<TId extends TableId> = (cellId: CellId<TId>, count: number)  => void;

/** Table Ids and callback types. */
type TableIdForEachRowArray<TId = TableId> = TId extends TableId ? [tableId: TId, forEachRow: (rowCallback: RowCallback<TId>) => void] : never;

/** A function that takes a Table Id, and a Row iterator. */
export type TableCallback = (...[tableId, forEachRow]: TableIdForEachRowArray) => void;

/** Ids for GetCellChange. */
type TableIdRowIdCellIdArray<TId = TableId> = TId extends TableId ? [tableId: TId, rowId: Id, cellId: CellId<TId>] : never;

/** A function for returning information about any Cell's changes during a transaction. */
export type GetCellChange = (...[tableId, rowId, cellId]: TableIdRowIdCellIdArray) => CellChange;

/** A function for listening to changes to the existence of Tables in the Store. */
export type HasTablesListener = (s: S, hasTables: boolean) => void;

/** A function for listening to changes to Tables in the Store. */
export type TablesListener = (s: S, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Table Ids in the Store. */
export type TableIdsListener = (s: S) => void;

/** A function for listening to changes to the existence of a Table in the Store. */
export type HasTableListener = (s: S, tableId: TableId, hasTable: boolean) => void;

/** A function for listening to changes to a Table in the Store. */
export type TableListener = (s: S, tableId: TableId, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids anywhere in a Table. */
export type TableCellIdsListener = (s: S, tableId: TableId) => void;

/** Cell args for HasTableCellListener. */
type HasTableCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, cellId: CId, hasTableCell: boolean] : never;

/** Table args for HasTableCellListener. */
type HasTableCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? HasTableCellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to the existence of a Cell anywhere in a Table. */
export type HasTableCellListener = (...[s, tableId, cellId, hasTableCell]: HasTableCellListenerArgsArrayOuter) => void;

/** A function for listening to changes to the number of Rows in a Table. */
export type RowCountListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the Row Ids in a Table. */
export type RowIdsListener = (s: S, tableId: TableId) => void;

/** A function for listening to changes to the sorted Row Ids in a Table. */
export type SortedRowIdsListener = (s: S, tableId: TableId, cellId: Id | undefined, descending: boolean, offset: number, limit: number | undefined, sortedRowIds: Ids) => void;

/** A function for listening to changes to the existence of a Row in a Table. */
export type HasRowListener = (s: S, tableId: TableId, rowId: Id, hasRow: boolean) => void;

/** A function for listening to changes to a Row in a Table. */
export type RowListener = (s: S, tableId: TableId, rowId: Id, getCellChange: GetCellChange | undefined) => void;

/** A function for listening to changes to the Cell Ids in a Row. */
export type CellIdsListener = (s: S, tableId: TableId, rowId: Id) => void;

/** Cell args for HasCellListener. */
type HasCellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, hasCell: boolean] : never;

/** Table args for HasCellListener. */
type HasCellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? HasCellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to the existence of a Cell in a Row. */
export type HasCellListener = (...[s, tableId, rowId, cellId, hasCell]: HasCellListenerArgsArrayOuter) => void;

/** Cell args for CellListener. */
type CellListenerArgsArrayInner<TId extends TableId, CId = CellId<TId>> = CId extends CellId<TId> ? [s: S, tableId: TId, rowId: Id, cellId: CId, newCell: Cell<TId, CId>  | undefined, oldCell: Cell<TId, CId>  | undefined, getCellChange: GetCellChange  | undefined] : never;

/** Table args for CellListener. */
type CellListenerArgsArrayOuter<TId = TableId> = TId extends TableId ? CellListenerArgsArrayInner<TId> : never;

/** A function for listening to changes to a Cell in a Row. */
export type CellListener = (...[s, tableId, rowId, cellId, newCell, oldCell, getCellChange]: CellListenerArgsArrayOuter) => void;

/** A function for listening to changes to invalid Cell changes in the Store. */
export type InvalidCellListener = (s: S, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[]) => void;

/** Represents the 't1' Table. */
export type T1Table = Table<'t1'>;

/** Represents the 't1' Table when setting it. */
export type T1TableWhenSet = TableWhenSet<'t1'>;

/** Represents a Row when getting the content of the 't1' Table. */
export type T1Row = Row<'t1'>;

/** Represents a Row when setting the content of the 't1' Table. */
export type T1RowWhenSet = RowWhenSet<'t1'>;

/** A Cell Id for the 't1' Table. */
export type T1CellId = CellId<'t1'>;

/** A function that takes a Cell Id and value from a Row in the 't1' Table. */
export type T1CellCallback = CellCallback<'t1'>;

/** A function that takes a Row Id from the 't1' Table, and a Cell iterator. */
export type T1RowCallback = RowCallback<'t1'>;

/** A function that takes a Cell Id from anywhere in the 't1' Table, and a count of how many times it appears. */
export type T1TableCellCallback = TableCellCallback<'t1'>;

/** Takes a number Cell value and returns another. */
export type MapNumber = (cell: number | undefined) => number;

/** Takes a string Cell value and returns another. */
export type MapString = (cell: string | undefined) => string;

/** A function for listening to the completion of a transaction. */
export type TransactionListener = (s: S, getTransactionChanges: GetTransactionChanges, getTransactionLog: GetTransactionLog) => void;

export interface S {
/** Gets the tabular content of the Store. */
getTables(): Tables;

/** Checks existence of the tabular content of the Store. */
hasTables(): boolean;

/** Sets the tabular content of the Store. */
setTables(tables: TablesWhenSet): S;

/** Deletes the tabular content of the Store. */
delTables(): S;

/** Gets the Ids of the Tables in the Store. */
getTableIds(): TableId[];

/** Calls a function for each Table in the Store. */
forEachTable(tableCallback: TableCallback): void;

/** Gets the content of the 't1' Table. */
getT1Table(): T1Table;

/** Checks existence of the content of the 't1' Table. */
hasT1Table(): boolean;

/** Sets the content of the 't1' Table. */
setT1Table(table: T1TableWhenSet): S;

/** Deletes the content of the 't1' Table. */
delT1Table(): S;

/** Gets the Ids of the Cells in the whole of the 't1' Table. */
getT1TableCellIds(): Ids;

/** Calls a function for each TableCell in the whole of the 't1' Table. */
forEachT1TableCell(tableCellCallback: T1TableCellCallback): void;

/** Gets the number of Rows in the the 't1' Table. */
getT1RowCount(): number;

/** Gets the Ids of the Rows in the 't1' Table. */
getT1RowIds(): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table. */
getT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids;

/** Calls a function for each Row in the 't1' Table. */
forEachT1Row(rowCallback: T1RowCallback): void;

/** Gets the content of the specified Row in the 't1' Table. */
getT1Row(rowId: Id): T1Row;

/** Checks existence of the content of the specified Row in the 't1' Table. */
hasT1Row(rowId: Id): boolean;

/** Sets the content of the specified Row in the 't1' Table. */
setT1Row(rowId: Id, row: T1RowWhenSet): S;

/** Deletes the content of the specified Row in the 't1' Table. */
delT1Row(rowId: Id): S;

/** Sets part of the content of the specified Row in the 't1' Table. */
setT1PartialRow(rowId: Id, partialRow: T1RowWhenSet): S;

/** Add a new Row to the 't1' Table. */
addT1Row(row: T1RowWhenSet, reuseIds?: boolean): Id | undefined;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table. */
getT1CellIds(rowId: Id): T1CellId[];

/** Calls a function for each Cell in the specified Row in the 't1' Table. */
forEachT1Cell(rowId: Id, cellCallback: T1CellCallback): void;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table. */
getT1C1Cell(rowId: Id): number;

/** Checks existence of the 'c1' Cell for the specified Row in the 't1' Table. */
hasT1C1Cell(rowId: Id): boolean;

/** Sets the 'c1' Cell for the specified Row in the 't1' Table. */
setT1C1Cell(rowId: Id, cell: number | MapNumber): S;

/** Deletes the 'c1' Cell for the specified Row in the 't1' Table. */
delT1C1Cell(rowId: Id): S;

/** Checks existence of the 'c1' Cell anywhere in the 't1' Table. */
hasT1C1TableCell(): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table. */
getT1C2Cell(rowId: Id): string;

/** Checks existence of the 'c2' Cell for the specified Row in the 't1' Table. */
hasT1C2Cell(rowId: Id): boolean;

/** Sets the 'c2' Cell for the specified Row in the 't1' Table. */
setT1C2Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c2' Cell for the specified Row in the 't1' Table. */
delT1C2Cell(rowId: Id): S;

/** Checks existence of the 'c2' Cell anywhere in the 't1' Table. */
hasT1C2TableCell(): boolean;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table. */
getT1C3Cell(rowId: Id): string;

/** Checks existence of the 'c3' Cell for the specified Row in the 't1' Table. */
hasT1C3Cell(rowId: Id): boolean;

/** Sets the 'c3' Cell for the specified Row in the 't1' Table. */
setT1C3Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the 'c3' Cell for the specified Row in the 't1' Table. */
delT1C3Cell(rowId: Id): S;

/** Checks existence of the 'c3' Cell anywhere in the 't1' Table. */
hasT1C3TableCell(): boolean;

/** Gets the '' Cell for the specified Row in the 't1' Table. */
getT1Cell(rowId: Id): string | undefined;

/** Checks existence of the '' Cell for the specified Row in the 't1' Table. */
hasT1Cell(rowId: Id): boolean;

/** Sets the '' Cell for the specified Row in the 't1' Table. */
setT1Cell(rowId: Id, cell: string | MapString): S;

/** Deletes the '' Cell for the specified Row in the 't1' Table. */
delT1Cell(rowId: Id): S;

/** Checks existence of the '' Cell anywhere in the 't1' Table. */
hasT1TableCell(): boolean;

/** Gets a string serialization of the tabular content of the Store. */
getTablesJson(): Json;

/** Sets a string serialization of the tabular content of the Store. */
setTablesJson(tablesJson: Json): S;

/** Registers a listener that will be called whenever the existence of the tabular content of the Store changes. */
addHasTablesListener(listener: HasTablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
addTablesListener(listener: TablesListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
addTableIdsListener(listener: TableIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Table in the Store changes. */
addHasTableListener(tableId: TableId | null, listener: HasTableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Table in the Store changes. */
addTableListener(tableId: TableId | null, listener: TableListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids anywhere in a Table change. */
addTableCellIdsListener(tableId: TableId | null, listener: TableCellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Cell anywhere in a Table changes. */
addHasTableCellListener(tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the number of Rows in a Table changes. */
addRowCountListener(tableId: TableId | null, listener: RowCountListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
addRowIdsListener(tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
addSortedRowIdsListener<TId extends TableId>(tableId: TId, cellId: CellId<TId> | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Row in a Table changes. */
addHasRowListener(tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Row in a Table changes. */
addRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
addCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever the existence of a Cell in a Row changes. */
addHasCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
addCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id;

/** Registers a listener that will be called whenever an invalid Cell change was attempted. */
addInvalidCellListener(tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id;

/** Gets the content of the Store. */
getContent(): [Tables, Values];

/** Sets the content of the Store. */
setContent([tables, values]: [Tables, Values]): S;

/** Applies a set of TransactionChanges to the Store. */
applyChanges(changes: TransactionChanges): S;

/** Gets a string serialization of the content of the Store. */
getJson(): Json;

/** Sets a string serialization of the content of the Store. */
setJson(tablesAndValuesJson: Json): S;

/** Execute a transaction to make multiple mutations. */
transaction<Return>(actions: () => Return, doRollback?: DoRollback): Return;

/** Explicitly starts a transaction. */
startTransaction(): S;

/** Explicitly finishes a transaction. */
finishTransaction(doRollback?: DoRollback): S;

/** Registers a listener that will be called just before the start of the transaction. */
addStartTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just before the end of the transaction. */
addWillFinishTransactionListener(listener: TransactionListener): Id;

/** Registers a listener that will be called just after the end of the transaction. */
addDidFinishTransactionListener(listener: TransactionListener): Id;

/** Manually provoke a listener to be called. */
callListener(listenerId: Id): S;

/** Remove a listener that was previously added to the Store. */
delListener(listenerId: Id): S;

/** Gets the underlying Store object. */
getStore(): Store;

}

/** Creates a S object. */
export function createS(): S;",
  "import {CellId, CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, InvalidCellListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellCallback, T1CellId, T1Row, T1RowCallback, T1RowWhenSet, T1Table, T1TableCellCallback, T1TableWhenSet, TableCallback, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet, TransactionListener, createS as createSDecl} from './s.d';
import {DoRollback, Id, IdOrNull, Ids, Json, Store, TransactionChanges, Values, createStore} from 'tinybase';

export const createS: typeof createSDecl = () => {
const T1 = 't1';

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const TYPE = 'type';

const NUMBER = 'number';

const DEFAULT = 'default';

const STRING = 'string';

const TWO = 'two';

const _3 = '3';

const store = createStore()
.setTablesSchema({
[T1]: {
[C1]: {[TYPE]: NUMBER, [DEFAULT]: 1},
[C2]: {[TYPE]: STRING, [DEFAULT]: TWO},
[C3]: {[TYPE]: STRING, [DEFAULT]: _3},
[_]: {[TYPE]: STRING},
},
});

const fluent = (actions: () => Store) => {
actions();
return s;
};

const proxy = (listener: any) => (_: Store, ...params: any[]) => listener(s, ...params);

const s = {
getTables: (): Tables => store.getTables() as Tables,

hasTables: (): boolean => store.hasTables(),

setTables: (tables: TablesWhenSet): S => fluent(() => store.setTables(tables)),

delTables: (): S => fluent(() => store.delTables()),

getTableIds: (): TableId[] => store.getTableIds() as TableId[],

forEachTable: (tableCallback: TableCallback): void => store.forEachTable(tableCallback as any),

getT1Table: (): T1Table => store.getTable(T1) as T1Table,

hasT1Table: (): boolean => store.hasTable(T1),

setT1Table: (table: T1TableWhenSet): S => fluent(() => store.setTable(T1, table)),

delT1Table: (): S => fluent(() => store.delTable(T1)),

getT1TableCellIds: (): Ids => store.getTableCellIds(T1) as Ids,

forEachT1TableCell: (tableCellCallback: T1TableCellCallback): void => store.forEachTableCell(T1, tableCellCallback as any),

getT1RowCount: (): number => store.getRowCount(T1) as number,

getT1RowIds: (): Ids => store.getRowIds(T1) as Ids,

getT1SortedRowIds: (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number): Ids => store.getSortedRowIds(T1, cellId, descending, offset, limit) as Ids,

forEachT1Row: (rowCallback: T1RowCallback): void => store.forEachRow(T1, rowCallback as any),

getT1Row: (rowId: Id): T1Row => store.getRow(T1, rowId) as T1Row,

hasT1Row: (rowId: Id): boolean => store.hasRow(T1, rowId),

setT1Row: (rowId: Id, row: T1RowWhenSet): S => fluent(() => store.setRow(T1, rowId, row)),

delT1Row: (rowId: Id): S => fluent(() => store.delRow(T1, rowId)),

setT1PartialRow: (rowId: Id, partialRow: T1RowWhenSet): S => fluent(() => store.setPartialRow(T1, rowId, partialRow)),

addT1Row: (row: T1RowWhenSet, reuseIds?: boolean): Id | undefined => store.addRow(T1, row, reuseIds),

getT1CellIds: (rowId: Id): T1CellId[] => store.getCellIds(T1, rowId) as T1CellId[],

forEachT1Cell: (rowId: Id, cellCallback: T1CellCallback): void => store.forEachCell(T1, rowId, cellCallback as any),

getT1C1Cell: (rowId: Id): number => store.getCell(T1, rowId, C1) as number,

hasT1C1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C1),

setT1C1Cell: (rowId: Id, cell: number | MapNumber): S => fluent(() => store.setCell(T1, rowId, C1, cell as any)),

delT1C1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C1)),

hasT1C1TableCell: (): boolean => store.hasTableCell(T1, C1),

getT1C2Cell: (rowId: Id): string => store.getCell(T1, rowId, C2) as string,

hasT1C2Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C2),

setT1C2Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C2, cell as any)),

delT1C2Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C2)),

hasT1C2TableCell: (): boolean => store.hasTableCell(T1, C2),

getT1C3Cell: (rowId: Id): string => store.getCell(T1, rowId, C3) as string,

hasT1C3Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, C3),

setT1C3Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, C3, cell as any)),

delT1C3Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, C3)),

hasT1C3TableCell: (): boolean => store.hasTableCell(T1, C3),

getT1Cell: (rowId: Id): string | undefined => store.getCell(T1, rowId, _) as string | undefined,

hasT1Cell: (rowId: Id): boolean => store.hasCell(T1, rowId, _),

setT1Cell: (rowId: Id, cell: string | MapString): S => fluent(() => store.setCell(T1, rowId, _, cell as any)),

delT1Cell: (rowId: Id): S => fluent(() => store.delCell(T1, rowId, _)),

hasT1TableCell: (): boolean => store.hasTableCell(T1, _),

getTablesJson: (): Json => store.getTablesJson() as Json,

setTablesJson: (tablesJson: Json): S => fluent(() => store.setTablesJson(tablesJson)),

addHasTablesListener: (listener: HasTablesListener, mutator?: boolean): Id => store.addHasTablesListener(proxy(listener), mutator),

addTablesListener: (listener: TablesListener, mutator?: boolean): Id => store.addTablesListener(proxy(listener), mutator),

addTableIdsListener: (listener: TableIdsListener, mutator?: boolean): Id => store.addTableIdsListener(proxy(listener), mutator),

addHasTableListener: (tableId: TableId | null, listener: HasTableListener, mutator?: boolean): Id => store.addHasTableListener(tableId, proxy(listener), mutator),

addTableListener: (tableId: TableId | null, listener: TableListener, mutator?: boolean): Id => store.addTableListener(tableId, proxy(listener), mutator),

addTableCellIdsListener: (tableId: TableId | null, listener: TableCellIdsListener, mutator?: boolean): Id => store.addTableCellIdsListener(tableId, proxy(listener), mutator),

addHasTableCellListener: (tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, mutator?: boolean): Id => store.addHasTableCellListener(tableId,  cellId, proxy(listener), mutator),

addRowCountListener: (tableId: TableId | null, listener: RowCountListener, mutator?: boolean): Id => store.addRowCountListener(tableId, proxy(listener), mutator),

addRowIdsListener: (tableId: TableId | null, listener: RowIdsListener, mutator?: boolean): Id => store.addRowIdsListener(tableId, proxy(listener), mutator),

addSortedRowIdsListener: <TId extends TableId>(tableId: TId, cellId: CellId<TId> | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, mutator?: boolean): Id => store.addSortedRowIdsListener(tableId, cellId, descending, offset, limit, proxy(listener), mutator),

addHasRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, mutator?: boolean): Id => store.addHasRowListener(tableId, rowId, proxy(listener), mutator),

addRowListener: (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, mutator?: boolean): Id => store.addRowListener(tableId, rowId, proxy(listener), mutator),

addCellIdsListener: (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, mutator?: boolean): Id => store.addCellIdsListener(tableId, rowId, proxy(listener), mutator),

addHasCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, mutator?: boolean): Id => store.addHasCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addCellListener: (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, mutator?: boolean): Id => store.addCellListener(tableId, rowId, cellId, proxy(listener), mutator),

addInvalidCellListener: (tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, listener: InvalidCellListener, mutator?: boolean): Id => store.addInvalidCellListener(tableId, rowId, cellId, proxy(listener), mutator),

getContent: (): [Tables, Values] => store.getContent() as [Tables, Values],

setContent: ([tables, values]: [Tables, Values]): S => fluent(() => store.setContent([tables, values])),

applyChanges: (changes: TransactionChanges): S => fluent(() => store.applyChanges(changes)),

getJson: (): Json => store.getJson() as Json,

setJson: (tablesAndValuesJson: Json): S => fluent(() => store.setJson(tablesAndValuesJson)),

transaction: <Return>(actions: () => Return, doRollback?: DoRollback): Return => store.transaction(actions, doRollback),

startTransaction: (): S => fluent(() => store.startTransaction()),

finishTransaction: (doRollback?: DoRollback): S => fluent(() => store.finishTransaction(doRollback)),

addStartTransactionListener: (listener: TransactionListener): Id => store.addStartTransactionListener(proxy(listener)),

addWillFinishTransactionListener: (listener: TransactionListener): Id => store.addWillFinishTransactionListener(proxy(listener)),

addDidFinishTransactionListener: (listener: TransactionListener): Id => store.addDidFinishTransactionListener(proxy(listener)),

callListener: (listenerId: Id): S => fluent(() => store.callListener(listenerId)),

delListener: (listenerId: Id): S => fluent(() => store.delListener(listenerId)),

getStore: (): Store => store,

};

return Object.freeze(s);
};",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellId, CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet} from './s.d';
import {ComponentReturnType, ExtraProps} from 'tinybase/ui-react';
import {ComponentType, ReactElement} from 'react';

/** Used when you need to refer to a S in a React hook or component. */
export type SOrSId = S | Id;

/** Used with the Provider component, so that a S can be passed into the context of an application. */
export type ProviderProps = {readonly s?: S; readonly sById?: {[sId: Id]: S}};

/** The props passed to a component that renders a Cell. */
export type CellProps<TId extends TableId, CId extends CellId<TId>> = {readonly tableId?: TId; readonly rowId: Id; readonly cellId?: CId; readonly s?: S; readonly debugIds?: boolean};

/** The props passed to a component that renders a Row. */
export type RowProps<TId extends TableId> = {readonly tableId?: TId; readonly rowId: Id; readonly s?: S; readonly cellComponents?: {readonly [CId in CellId<TId>]?: ComponentType<CellProps<TId, CId>>;}; readonly getCellComponentProps?: (cellId: CellId<TId>) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a Table. */
export type TableProps<TId extends TableId> = {readonly tableId?: TId; readonly s?: S; readonly rowComponent?: ComponentType<RowProps<TId>>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders a sorted Table. */
export type SortedTableProps<TId extends TableId> = {readonly tableId?: TId; readonly cellId?: CellId<TId>; readonly descending?: boolean; readonly offset?: number; readonly limit?: number; readonly s?: S; readonly rowComponent?: ComponentType<RowProps<TId>>; readonly getRowComponentProps?: (rowId: Id) => ExtraProps; readonly customCellIds?: CellId<TId>[]; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** The props passed to a component that renders the tabular content of the Store. */
export type TablesProps = {readonly s?: S; readonly tableComponents?: {readonly [TId in TableId]?: ComponentType<TableProps<TId>>;}; readonly getTableComponentProps?: (tableId: TableId) => ExtraProps; readonly separator?: ReactElement | string; readonly debugIds?: boolean};

/** Create a S within a React application with convenient memoization. */
export function useCreateS(create: () => S, createDeps?: React.DependencyList): S;

/** Get a reference to a S from within a Provider component context. */
export function useS(id?: Id): S | undefined;

/** Gets the existence of the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasTables(sOrSId?: SOrSId): boolean;

/** Gets the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTables(sOrSId?: SOrSId): Tables;

/** Gets the Ids of the Tables in the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function useTableIds(sOrSId?: SOrSId): TableId[];

/** Gets a callback that can set the tabular content of the Store, based on a parameter. */
export function useSetTablesCallback<Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the tabular content of the Store. */
export function useDelTablesCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the tabular content of the Store, and registers a listener so that any changes to that result will cause a re-render. */
export function TablesView({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): ComponentReturnType;

/** Gets the existence of the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Table(sOrSId?: SOrSId): boolean;

/** Gets the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Table(sOrSId?: SOrSId): T1Table;

/** Gets the Ids of the Cells in the whole of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1TableCellIds(sOrSId?: SOrSId): Ids;

/** Gets the number of Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowCount(sOrSId?: SOrSId): number;

/** Gets the Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1RowIds(sOrSId?: SOrSId): Ids;

/** Gets sorted, paginated Ids of the Rows in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1SortedRowIds(cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids;

/** Gets the existence of the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Row(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Row(rowId: Id, sOrSId?: SOrSId): T1Row;

/** Gets the Ids of the Cells in the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1CellIds(rowId: Id, sOrSId?: SOrSId): T1CellId[];

/** Gets a callback that can set the content of the 't1' Table, based on a parameter. */
export function useSetT1TableCallback<Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the 't1' Table. */
export function useDelT1TableCallback(sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Gets a callback that can set the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1RowCallback<Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can add the content of the specified Row in the 't1' Table, based on a parameter. */
export function useAddT1RowCallback<Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList, reuseRowIds?: boolean): ParameterizedCallback<Parameter>;

/** Gets a callback that can set part of the content of the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1PartialRowCallback<Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the content of the specified Row in the 't1' Table. */
export function useDelT1RowCallback(rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the content of the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1RowView({rowId, s, cellComponents, getCellComponentProps, customCellIds, separator, debugIds}: RowProps<'t1'>): ComponentReturnType;

/** Renders the content of the 't1' Table, sorted, and registers a listener so that any changes to that result will cause a re-render. */
export function T1SortedTableView({cellId, descending, offset, limit, ...props}: SortedTableProps<'t1'>): ComponentReturnType;

/** Renders the content of the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1TableView(props: TableProps<'t1'>): ComponentReturnType;

/** Gets the existence of the 'c1' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C1TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C1Cell(rowId: Id, sOrSId?: SOrSId): number;

/** Gets a callback that can set the 'c1' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c1' Cell for the specified Row in the 't1' Table. */
export function useDelT1C1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c1' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C1CellView({rowId, s, debugIds}: CellProps<'t1', 'c1'>): ComponentReturnType;

/** Gets the existence of the 'c2' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C2TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C2Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C2Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c2' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C2CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c2' Cell for the specified Row in the 't1' Table. */
export function useDelT1C2CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c2' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C2CellView({rowId, s, debugIds}: CellProps<'t1', 'c2'>): ComponentReturnType;

/** Gets the existence of the 'c3' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C3TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1C3Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1C3Cell(rowId: Id, sOrSId?: SOrSId): string;

/** Gets a callback that can set the 'c3' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1C3CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the 'c3' Cell for the specified Row in the 't1' Table. */
export function useDelT1C3CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the 'c3' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1C3CellView({rowId, s, debugIds}: CellProps<'t1', 'c3'>): ComponentReturnType;

/** Gets the existence of the '' Cell anywhere in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1TableCell(sOrSId?: SOrSId): boolean;

/** Gets the existence of the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useHasT1Cell(rowId: Id, sOrSId?: SOrSId): boolean;

/** Gets the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function useT1Cell(rowId: Id, sOrSId?: SOrSId): string | undefined;

/** Gets a callback that can set the '' Cell for the specified Row in the 't1' Table, based on a parameter. */
export function useSetT1CellCallback<Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter>;

/** Gets a callback that can delete the '' Cell for the specified Row in the 't1' Table. */
export function useDelT1CellCallback(rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback;

/** Renders the '' Cell for the specified Row in the 't1' Table, and registers a listener so that any changes to that result will cause a re-render. */
export function T1CellView({rowId, s, debugIds}: CellProps<'t1', ''>): ComponentReturnType;

/** Registers a listener that will be called whenever the existence of the tabular content of the Store changes. */
export function useHasTablesListener(listener: HasTablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the tabular content of the Store changes. */
export function useTablesListener(listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Table Ids in the Store change. */
export function useTableIdsListener(listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Table in the Store changes. */
export function useHasTableListener(tableId: TableId | null, listener: HasTableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Table in the Store changes. */
export function useTableListener(tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids anywhere in a Table change. */
export function useTableCellIdsListener(tableId: TableId | null, listener: TableCellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Cell anywhere in a Table changes. */
export function useHasTableCellListener(tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the number of Rows in a Table changes. */
export function useRowCountListener(tableId: TableId | null, listener: RowCountListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Row Ids in a Table change. */
export function useRowIdsListener(tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the sorted Row Ids in a Table change. */
export function useSortedRowIdsListener(tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Row in a Table changes. */
export function useHasRowListener(tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Row in a Table changes. */
export function useRowListener(tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the Cell Ids in a Row change. */
export function useCellIdsListener(tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever the existence of a Cell in a Row changes. */
export function useHasCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Registers a listener that will be called whenever a Cell in a Row changes. */
export function useCellListener(tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void;

/** Wraps part of an application in a context that provides default objects to be used by hooks and components within. */
export function Provider({s, sById, children}: ProviderProps & {children: React.ReactNode}): ComponentReturnType;
",
  "import {Callback, Id, IdOrNull, Ids, ParameterizedCallback, Store} from 'tinybase';
import {CellIdsListener, CellListener, HasCellListener, HasRowListener, HasTableCellListener, HasTableListener, HasTablesListener, MapNumber, MapString, RowCountListener, RowIdsListener, RowListener, S, SortedRowIdsListener, T1CellId, T1Row, T1RowWhenSet, T1Table, T1TableWhenSet, TableCellIdsListener, TableId, TableIdsListener, TableListener, Tables, TablesListener, TablesWhenSet} from './s.d';
import {CellProps, Provider as ProviderDecl, ProviderProps, RowProps, SOrSId, SortedTableProps, T1C1CellView as T1C1CellViewDecl, T1C2CellView as T1C2CellViewDecl, T1C3CellView as T1C3CellViewDecl, T1CellView as T1CellViewDecl, T1RowView as T1RowViewDecl, T1SortedTableView as T1SortedTableViewDecl, T1TableView as T1TableViewDecl, TableProps, TablesProps, TablesView as TablesViewDecl, useAddT1RowCallback as useAddT1RowCallbackDecl, useCellIdsListener as useCellIdsListenerDecl, useCellListener as useCellListenerDecl, useCreateS as useCreateSDecl, useDelT1C1CellCallback as useDelT1C1CellCallbackDecl, useDelT1C2CellCallback as useDelT1C2CellCallbackDecl, useDelT1C3CellCallback as useDelT1C3CellCallbackDecl, useDelT1CellCallback as useDelT1CellCallbackDecl, useDelT1RowCallback as useDelT1RowCallbackDecl, useDelT1TableCallback as useDelT1TableCallbackDecl, useDelTablesCallback as useDelTablesCallbackDecl, useHasCellListener as useHasCellListenerDecl, useHasRowListener as useHasRowListenerDecl, useHasT1C1Cell as useHasT1C1CellDecl, useHasT1C1TableCell as useHasT1C1TableCellDecl, useHasT1C2Cell as useHasT1C2CellDecl, useHasT1C2TableCell as useHasT1C2TableCellDecl, useHasT1C3Cell as useHasT1C3CellDecl, useHasT1C3TableCell as useHasT1C3TableCellDecl, useHasT1Cell as useHasT1CellDecl, useHasT1Row as useHasT1RowDecl, useHasT1TableCell as useHasT1TableCellDecl, useHasT1Table as useHasT1TableDecl, useHasTableCellListener as useHasTableCellListenerDecl, useHasTableListener as useHasTableListenerDecl, useHasTables as useHasTablesDecl, useHasTablesListener as useHasTablesListenerDecl, useRowCountListener as useRowCountListenerDecl, useRowIdsListener as useRowIdsListenerDecl, useRowListener as useRowListenerDecl, useS as useSDecl, useSetT1C1CellCallback as useSetT1C1CellCallbackDecl, useSetT1C2CellCallback as useSetT1C2CellCallbackDecl, useSetT1C3CellCallback as useSetT1C3CellCallbackDecl, useSetT1CellCallback as useSetT1CellCallbackDecl, useSetT1PartialRowCallback as useSetT1PartialRowCallbackDecl, useSetT1RowCallback as useSetT1RowCallbackDecl, useSetT1TableCallback as useSetT1TableCallbackDecl, useSetTablesCallback as useSetTablesCallbackDecl, useSortedRowIdsListener as useSortedRowIdsListenerDecl, useT1C1Cell as useT1C1CellDecl, useT1C2Cell as useT1C2CellDecl, useT1C3Cell as useT1C3CellDecl, useT1Cell as useT1CellDecl, useT1CellIds as useT1CellIdsDecl, useT1RowCount as useT1RowCountDecl, useT1Row as useT1RowDecl, useT1RowIds as useT1RowIdsDecl, useT1SortedRowIds as useT1SortedRowIdsDecl, useT1TableCellIds as useT1TableCellIdsDecl, useT1Table as useT1TableDecl, useTableCellIdsListener as useTableCellIdsListenerDecl, useTableIds as useTableIdsDecl, useTableIdsListener as useTableIdsListenerDecl, useTableListener as useTableListenerDecl, useTables as useTablesDecl, useTablesListener as useTablesListenerDecl} from './s-ui-react.d';
import {ExtraProps, useAddRowCallback as useAddRowCallbackCore, useCell as useCellCore, useCellIds, useCellIds as useCellIdsCore, useCellIdsListener as useCellIdsListenerCore, useCellListener as useCellListenerCore, useDelCellCallback as useDelCellCallbackCore, useDelRowCallback as useDelRowCallbackCore, useDelTableCallback as useDelTableCallbackCore, useDelTablesCallback as useDelTablesCallbackCore, useHasCell as useHasCellCore, useHasCellListener as useHasCellListenerCore, useHasRow as useHasRowCore, useHasRowListener as useHasRowListenerCore, useHasTableCell as useHasTableCellCore, useHasTableCellListener as useHasTableCellListenerCore, useHasTable as useHasTableCore, useHasTableListener as useHasTableListenerCore, useHasTables as useHasTablesCore, useHasTablesListener as useHasTablesListenerCore, useRow as useRowCore, useRowCount as useRowCountCore, useRowCountListener as useRowCountListenerCore, useRowIds as useRowIdsCore, useRowIdsListener as useRowIdsListenerCore, useRowListener as useRowListenerCore, useSetCellCallback as useSetCellCallbackCore, useSetPartialRowCallback as useSetPartialRowCallbackCore, useSetRowCallback as useSetRowCallbackCore, useSetTableCallback as useSetTableCallbackCore, useSetTablesCallback as useSetTablesCallbackCore, useSortedRowIds as useSortedRowIdsCore, useSortedRowIdsListener as useSortedRowIdsListenerCore, useTableCellIds as useTableCellIdsCore, useTableCellIdsListener as useTableCellIdsListenerCore, useTable as useTableCore, useTableIds as useTableIdsCore, useTableIdsListener as useTableIdsListenerCore, useTableListener as useTableListenerCore, useTables as useTablesCore, useTablesListener as useTablesListenerCore} from 'tinybase/ui-react';
import React from 'react';

const {createContext, useContext, useMemo} = React;

const Context = createContext<[S?, {[sId: Id]: S}?]>([]);

const useHook = (sOrSId: SOrSId | undefined, hook: (...params: any[]) => any, preParams: any[], postParams: any[] = []) => {
const s = useS(sOrSId as Id);
return hook(...preParams, ((sOrSId == null || typeof sOrSId == 'string')
? s : sOrSId)?.getStore(), ...postParams)
};

const getProps = (getProps: ((id: any) => ExtraProps) | undefined, id: Id) => (getProps == null) ? ({} as ExtraProps) : getProps(id);

const wrap = (children: any, separator?: any, encloseWithId?: boolean, id?: Id) => {
const separated = separator==null || !Array.isArray(children)
 ? children
 : children.map((child, c) => (c > 0 ? [separator, child] : child));
return encloseWithId ? [id, ':{', separated, '}'] : separated;
};

const useCustomOrDefaultCellIds = (customCellIds: Ids | undefined, tableId: Id, rowId: Id, sOrSId?: SOrSId | undefined) => {
const defaultCellIds = useHook(sOrSId, useCellIds, [tableId, rowId]);
return customCellIds ?? defaultCellIds;
};

const NullComponent = () => null;

const tableView = ({s, rowComponent, getRowComponentProps, customCellIds, separator, debugIds}: any, rowIds: Ids, tableId: Id, defaultRowComponent: React.ComponentType<any>) => {
const Row = rowComponent ?? defaultRowComponent;
return wrap(rowIds.map((rowId) => (
<Row
{...getProps(getRowComponentProps, rowId)}
key={rowId}
tableId={tableId}
rowId={rowId}
customCellIds={customCellIds}
s={s}
debugIds={debugIds}
/>
))
, separator, debugIds
, tableId,
);
};

const T1 = 't1';

const getDefaultTableComponent = (tableId: Id) => tableId == T1 ? T1TableView : NullComponent;

const C1 = 'c1';

const C2 = 'c2';

const C3 = 'c3';

const _ = '';

const getDefaultCellComponent = (tableId: Id, cellId: Id) => tableId == T1 ? cellId == C1 ? T1C1CellView : cellId == C2 ? T1C2CellView : cellId == C3 ? T1C3CellView : cellId == _ ? T1CellView : NullComponent : NullComponent;

export const useCreateS: typeof useCreateSDecl = (create: () => S, createDeps?: React.DependencyList): S =>

// eslint-disable-next-line react-hooks/exhaustive-deps
useMemo(create, createDeps)

export const useS: typeof useSDecl = (id?: Id): S | undefined =>
{
const contextValue = useContext(Context);
return id == null ? contextValue[0] : contextValue[1]?.[id];
}

export const useHasTables: typeof useHasTablesDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTablesCore, []);

export const useTables: typeof useTablesDecl = (sOrSId?: SOrSId): Tables =>
useHook(sOrSId, useTablesCore, []);

export const useTableIds: typeof useTableIdsDecl = (sOrSId?: SOrSId): TableId[] =>
useHook(sOrSId, useTableIdsCore, []);

export const useSetTablesCallback: typeof useSetTablesCallbackDecl = <Parameter,>(getTables: (parameter: Parameter, store: Store) => TablesWhenSet, getTablesDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, tables: TablesWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTablesCallbackCore, [getTables, getTablesDeps], [then, thenDeps]);

export const useDelTablesCallback: typeof useDelTablesCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTablesCallbackCore, [], [then, thenDeps]);

export const TablesView: typeof TablesViewDecl = ({s, tableComponents, getTableComponentProps, separator, debugIds}: TablesProps): any =>
wrap(useTableIds(s).map((tableId) => {
const Table = (tableComponents?.[tableId] ?? getDefaultTableComponent(tableId)) as React.ComponentType<TableProps<typeof tableId>>;
return <Table
{...getProps(getTableComponentProps, tableId)}
tableId={tableId}
key={tableId}
s={s}
debugIds={debugIds}
/>;
}), separator)

export const useHasT1Table: typeof useHasT1TableDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCore, [T1]);

export const useT1Table: typeof useT1TableDecl = (sOrSId?: SOrSId): T1Table =>
useHook(sOrSId, useTableCore, [T1]);

export const useT1TableCellIds: typeof useT1TableCellIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useTableCellIdsCore, [T1]);

export const useT1RowCount: typeof useT1RowCountDecl = (sOrSId?: SOrSId): number =>
useHook(sOrSId, useRowCountCore, [T1]);

export const useT1RowIds: typeof useT1RowIdsDecl = (sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useRowIdsCore, [T1]);

export const useT1SortedRowIds: typeof useT1SortedRowIdsDecl = (cellId?: T1CellId, descending?: boolean, offset?: number, limit?: number, sOrSId?: SOrSId): Ids =>
useHook(sOrSId, useSortedRowIdsCore, [T1, cellId, descending, offset, limit]);

export const useHasT1Row: typeof useHasT1RowDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasRowCore, [T1, rowId]);

export const useT1Row: typeof useT1RowDecl = (rowId: Id, sOrSId?: SOrSId): T1Row =>
useHook(sOrSId, useRowCore, [T1, rowId]);

export const useT1CellIds: typeof useT1CellIdsDecl = (rowId: Id, sOrSId?: SOrSId): T1CellId[] =>
useHook(sOrSId, useCellIdsCore, [T1, rowId]);

export const useSetT1TableCallback: typeof useSetT1TableCallbackDecl = <Parameter,>(getTable: (parameter: Parameter, store: Store) => T1TableWhenSet, getTableDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, table: T1TableWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetTableCallbackCore, [T1, getTable, getTableDeps], [then, thenDeps]);

export const useDelT1TableCallback: typeof useDelT1TableCallbackDecl = (sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelTableCallbackCore, [T1], [then, thenDeps]);

export const useSetT1RowCallback: typeof useSetT1RowCallbackDecl = <Parameter,>(rowId: Id, getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetRowCallbackCore, [T1, rowId, getRow, getRowDeps], [then, thenDeps]);

export const useAddT1RowCallback: typeof useAddT1RowCallbackDecl = <Parameter,>(getRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (rowId: Id | undefined, store: Store, row: T1RowWhenSet) => void, thenDeps?: React.DependencyList, reuseRowIds?: boolean): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useAddRowCallbackCore, [T1, getRow, getRowDeps], [then, thenDeps, reuseRowIds]);

export const useSetT1PartialRowCallback: typeof useSetT1PartialRowCallbackDecl = <Parameter,>(rowId: Id, getPartialRow: (parameter: Parameter, store: Store) => T1RowWhenSet, getPartialRowDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, partialRow: T1RowWhenSet) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetPartialRowCallbackCore, [T1, rowId, getPartialRow, getPartialRowDeps], [then, thenDeps]);

export const useDelT1RowCallback: typeof useDelT1RowCallbackDecl = (rowId: Id, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelRowCallbackCore, [T1, rowId], [then, thenDeps]);

export const T1RowView: typeof T1RowViewDecl = ({rowId, s, cellComponents, getCellComponentProps, customCellIds, separator, debugIds}: RowProps<'t1'>): any =>
wrap(useCustomOrDefaultCellIds(customCellIds, T1, rowId, s).map((cellId: T1CellId) => {
const Cell = (cellComponents?.[cellId] ?? getDefaultCellComponent(T1, cellId)) as React.ComponentType<CellProps<typeof T1, typeof cellId>>;
return <Cell
{...getProps(getCellComponentProps, cellId)} 
key={cellId}
tableId={T1}
rowId={rowId}
cellId={cellId}
s={s}
debugIds={debugIds}
/>;
}), separator, debugIds, rowId)

export const T1SortedTableView: typeof T1SortedTableViewDecl = ({cellId, descending, offset, limit, ...props}: SortedTableProps<'t1'>): any =>
tableView(props, useT1SortedRowIds(cellId, descending, offset, limit, props.s), T1, T1RowView);

export const T1TableView: typeof T1TableViewDecl = (props: TableProps<'t1'>): any =>
tableView(props, useT1RowIds(props.s), T1, T1RowView);

export const useHasT1C1TableCell: typeof useHasT1C1TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C1]);

export const useHasT1C1Cell: typeof useHasT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C1]);

export const useT1C1Cell: typeof useT1C1CellDecl = (rowId: Id, sOrSId?: SOrSId): number =>
useHook(sOrSId, useCellCore, [T1, rowId, C1]);

export const useSetT1C1CellCallback: typeof useSetT1C1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => number | MapNumber, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: number | MapNumber) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C1, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C1CellCallback: typeof useDelT1C1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C1, forceDel], [then, thenDeps]);

export const T1C1CellView: typeof T1C1CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c1'>): any =>
wrap('' + useT1C1Cell(rowId, s) ?? '', undefined, debugIds, C1)

export const useHasT1C2TableCell: typeof useHasT1C2TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C2]);

export const useHasT1C2Cell: typeof useHasT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C2]);

export const useT1C2Cell: typeof useT1C2CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C2]);

export const useSetT1C2CellCallback: typeof useSetT1C2CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C2, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C2CellCallback: typeof useDelT1C2CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C2, forceDel], [then, thenDeps]);

export const T1C2CellView: typeof T1C2CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c2'>): any =>
wrap('' + useT1C2Cell(rowId, s) ?? '', undefined, debugIds, C2)

export const useHasT1C3TableCell: typeof useHasT1C3TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, C3]);

export const useHasT1C3Cell: typeof useHasT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, C3]);

export const useT1C3Cell: typeof useT1C3CellDecl = (rowId: Id, sOrSId?: SOrSId): string =>
useHook(sOrSId, useCellCore, [T1, rowId, C3]);

export const useSetT1C3CellCallback: typeof useSetT1C3CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, C3, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1C3CellCallback: typeof useDelT1C3CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, C3, forceDel], [then, thenDeps]);

export const T1C3CellView: typeof T1C3CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', 'c3'>): any =>
wrap('' + useT1C3Cell(rowId, s) ?? '', undefined, debugIds, C3)

export const useHasT1TableCell: typeof useHasT1TableCellDecl = (sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasTableCellCore, [T1, _]);

export const useHasT1Cell: typeof useHasT1CellDecl = (rowId: Id, sOrSId?: SOrSId): boolean =>
useHook(sOrSId, useHasCellCore, [T1, rowId, _]);

export const useT1Cell: typeof useT1CellDecl = (rowId: Id, sOrSId?: SOrSId): string | undefined =>
useHook(sOrSId, useCellCore, [T1, rowId, _]);

export const useSetT1CellCallback: typeof useSetT1CellCallbackDecl = <Parameter,>(rowId: Id, getCell: (parameter: Parameter, store: Store) => string | MapString, getCellDeps?: React.DependencyList, sOrSId?: SOrSId, then?: (store: Store, cell: string | MapString) => void, thenDeps?: React.DependencyList): ParameterizedCallback<Parameter> =>
useHook(sOrSId, useSetCellCallbackCore, [T1, rowId, _, getCell, getCellDeps], [then, thenDeps]);

export const useDelT1CellCallback: typeof useDelT1CellCallbackDecl = (rowId: Id, forceDel?: boolean, sOrSId?: SOrSId, then?: (store: Store) => void, thenDeps?: React.DependencyList): Callback =>
useHook(sOrSId, useDelCellCallbackCore, [T1, rowId, _, forceDel], [then, thenDeps]);

export const T1CellView: typeof T1CellViewDecl = ({rowId, s, debugIds}: CellProps<'t1', ''>): any =>
wrap('' + useT1Cell(rowId, s) ?? '', undefined, debugIds, _)

export const useHasTablesListener: typeof useHasTablesListenerDecl = (listener: HasTablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTablesListener: typeof useTablesListenerDecl = (listener: TablesListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTablesListenerCore, [listener, listenerDeps, mutator]);

export const useTableIdsListener: typeof useTableIdsListenerDecl = (listener: TableIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableIdsListenerCore, [listener, listenerDeps, mutator]);

export const useHasTableListener: typeof useHasTableListenerDecl = (tableId: TableId | null, listener: HasTableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useTableListener: typeof useTableListenerDecl = (tableId: TableId | null, listener: TableListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useTableCellIdsListener: typeof useTableCellIdsListenerDecl = (tableId: TableId | null, listener: TableCellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useTableCellIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useHasTableCellListener: typeof useHasTableCellListenerDecl = (tableId: TableId | null, cellId: T1CellId | null, listener: HasTableCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasTableCellListenerCore, [tableId, cellId, listener, listenerDeps, mutator]);

export const useRowCountListener: typeof useRowCountListenerDecl = (tableId: TableId | null, listener: RowCountListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowCountListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useRowIdsListener: typeof useRowIdsListenerDecl = (tableId: TableId | null, listener: RowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowIdsListenerCore, [tableId, listener, listenerDeps, mutator]);

export const useSortedRowIdsListener: typeof useSortedRowIdsListenerDecl = (tableId: TableId | null, cellId: T1CellId | undefined, descending: boolean, offset: number, limit: number | undefined, listener: SortedRowIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useSortedRowIdsListenerCore, [tableId, cellId, descending, offset, limit, listener, listenerDeps, mutator]);

export const useHasRowListener: typeof useHasRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: HasRowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useRowListener: typeof useRowListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: RowListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useRowListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useCellIdsListener: typeof useCellIdsListenerDecl = (tableId: TableId | null, rowId: IdOrNull, listener: CellIdsListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellIdsListenerCore, [tableId, rowId, listener, listenerDeps, mutator]);

export const useHasCellListener: typeof useHasCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: HasCellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useHasCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const useCellListener: typeof useCellListenerDecl = (tableId: TableId | null, rowId: IdOrNull, cellId: T1CellId | null, listener: CellListener, listenerDeps?: React.DependencyList, mutator?: boolean, sOrSId?: SOrSId): void =>
useHook(sOrSId, useCellListenerCore, [tableId, rowId, cellId, listener, listenerDeps, mutator]);

export const Provider: typeof ProviderDecl = ({s, sById, children}: ProviderProps & {children: React.ReactNode}): any =>
{
const contextValue = useContext(Context);
return (
<Context.Provider
value={useMemo(
() => [s ?? contextValue[0], {...contextValue[1], ...sById}],
[s, sById, contextValue],
)}>
{children}
</Context.Provider>
);
}
",
]
`;
