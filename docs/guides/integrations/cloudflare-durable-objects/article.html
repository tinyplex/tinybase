<nav><ul><li><a href="/">TinyBase</a></li><li><a href="/guides/">Guides</a></li><li><a href="/guides/integrations/">Integrations</a></li><li><a href="/guides/integrations/cloudflare-durable-objects/">Cloudflare Durable Objects</a></li></ul></nav><section class="s1" id="/guides/integrations/cloudflare-durable-objects/" data-id="CDO"><h1>Cloudflare Durable Objects</h1><p><a href="https://developers.cloudflare.com/durable-objects/">Durable Objects</a> are a new type of serverless compute platform from Cloudflare, and provide a way to run stateful applications in a serverless environment, without needing to manage infrastructure.</p><h3 id="what-are-durable-objects">What Are Durable Objects?</h3><p>Each Durable Object can function as a WebSocket server, so it can co-ordinate messages between multiple clients. But importantly, it also has private, transactional and strongly consistent storage attached. Combined with a TinyBase <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> on the client, and using the built-in synchronization and persistence functionality, this gives you an full-stack way to build complex, real-time, multi-device (and even collaborative) apps.</p><p><embed src="/durable.svg" title="Durable Objects"></p><p>As this guide hopefully shows, this can be done with minimal effort!</p><h3 id="getting-started-with-vite"><a href="/guides/the-basics/getting-started/">Getting Started</a> with Vite</h3><p>The quickest way to get started with TinyBase and Cloudflare Durable Objects is to use the Durable Objects option in the <a href="https://github.com/tinyplex/create-tinybase"><code>create-tinybase</code> tool</a>. This will set up a Vite app with synchronization to a Durable Object on a local server, and local persistence in the browser.</p><h3 id="how-it-all-works">How It All Works</h3><h4 id="client-persistence-and-synchronization">Client: <a href="/guides/persistence/">Persistence</a> and <a href="/guides/synchronization/">Synchronization</a></h4><p>On the client, we create a simple TinyBase <a href="/api/mergeable-store/interfaces/mergeable/mergeablestore/"><code>MergeableStore</code></a> to encapsulate the data we need for the app. The following are simplified extracts of the code in the <code>App.tsx</code> file of the Vite template:</p><pre><code><span class="keyword">export</span> <span class="keyword">const</span> <span class="function-variable">App</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">=></span> <span class="punctuation">{</span>
  <span class="keyword">const</span> store <span class="operator">=</span> <span class="function"><a href="/api/ui-react/functions/store-hooks/usecreatemergeablestore/">useCreateMergeableStore</a></span><span class="punctuation">(</span>createMergeableStore<span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="comment">// ...</span>
</code></pre><p>(Because the template is using React, we use the <code>useCreateMergeableStore</code> hook so it&#x27;s not re-created on every render.)</p><p>We also create a local <a href="/api/the-essentials/persisting-stores/persister/"><code>Persister</code></a> so that if the client goes offline, and the browser window is refreshed, changes will have been cached locally in session storage, with a key &#x27;foo&#x27;:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/ui-react/functions/persister-hooks/usecreatepersister/">useCreatePersister</a></span><span class="punctuation">(</span>
  store<span class="punctuation">,</span>
  <span class="punctuation">(</span><span class="parameter">store</span><span class="punctuation">)</span> <span class="operator">=></span> <span class="function"><a href="/api/the-essentials/persisting-stores/createlocalpersister/">createLocalPersister</a></span><span class="punctuation">(</span>store<span class="punctuation">,</span> <span class="string">'foo'</span><span class="punctuation">)</span><span class="punctuation">,</span>
  <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>
  <span class="punctuation">(</span><span class="parameter">persister</span><span class="punctuation">)</span> <span class="operator">=></span> persister<span class="punctuation">.</span><span class="function"><a href="/api/persisters/interfaces/persister/persister/methods/lifecycle/startautopersisting/">startAutoPersisting</a></span><span class="punctuation">(</span><span class="comment">/* any initial contents */</span><span class="punctuation">)</span><span class="punctuation">,</span>
<span class="punctuation">)</span><span class="punctuation">;</span>
<span class="comment">// ...</span>
</code></pre><p>More interestingly, we also set up a <a href="/api/the-essentials/synchronizing-stores/synchronizer/"><code>Synchronizer</code></a> that connects to the Cloudflare installation, on a path that also happens to be called &#x27;foo&#x27;:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/ui-react/functions/synchronizer-hooks/usecreatesynchronizer/">useCreateSynchronizer</a></span><span class="punctuation">(</span>store<span class="punctuation">,</span> <span class="keyword">async</span> <span class="punctuation">(</span><span class="parameter">store</span><span class="punctuation">)</span> <span class="operator">=></span> <span class="punctuation">{</span>
  <span class="keyword">const</span> synchronizer <span class="operator">=</span> <span class="keyword">await</span> <span class="function"><a href="/api/the-essentials/synchronizing-stores/createwssynchronizer/">createWsSynchronizer</a></span><span class="punctuation">(</span>
    store<span class="punctuation">,</span>
    <span class="keyword">new</span> <span class="class-name">WebSocket</span><span class="punctuation">(</span><span class="string">'wss://example.com/foo'</span><span class="punctuation">)</span><span class="punctuation">,</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="keyword">await</span> synchronizer<span class="punctuation">.</span><span class="function"><a href="/api/synchronizers/interfaces/synchronizer/synchronizer/methods/synchronization/startsync/">startSync</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">;</span>
  <span class="keyword">return</span> synchronizer<span class="punctuation">;</span>
<span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span>
</code></pre><p>Those simple lines are enough to have the <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> attempt to synchronize itself with the common Durable Object called <code>/foo</code> on the server.</p><h4 id="server-worker-and-durable-object">Server: Worker and Durable Object</h4><p>On the server, Cloudflare needs us to configure a worker and Durable Object. It will help if you are familiar with these concepts already - and if not, start with the documentation <a href="https://developers.cloudflare.com/durable-objects/get-started/walkthrough/">here</a>.</p><p>Following the instructions above, you&#x27;ll have a <code>wrangler.toml</code> file containing the configuration for your worker and the Durable Object. In there you&#x27;ll need to bind a namespace of Durable Objects to a class, something like:</p><pre><code><span class="punctuation">[</span><span class="punctuation">[</span><span class="table">durable_objects.bindings</span><span class="punctuation">]</span><span class="punctuation">]</span>
<span class="key">name</span> <span class="punctuation">=</span> <span class="string">"TinyBaseDurableObjects"</span>
<span class="key">class_name</span> <span class="punctuation">=</span> <span class="string">"TinyBaseDurableObject"</span>

<span class="punctuation">[</span><span class="punctuation">[</span><span class="table">migrations</span><span class="punctuation">]</span><span class="punctuation">]</span>
<span class="key">tag</span> <span class="punctuation">=</span> <span class="string">"v1"</span>
<span class="key">new_classes</span> <span class="punctuation">=</span> <span class="punctuation">[</span><span class="string">"TinyBaseDurableObject"</span><span class="punctuation">]</span>
</code></pre><p>(Again, take a look at the contents of the Vite template for the full configuration file.)</p><p>In the main worker file, probably called <code>index.js</code> or <code>index.ts</code>, you&#x27;ll need to configure the worker as the default export from the file. TinyBase provides a convenience <a href="/api/synchronizer-ws-server-durable-object/functions/creation/getwsserverdurableobjectfetch/"><code>getWsServerDurableObjectFetch</code></a> function that will create a <code>fetch</code> method that routes WebSocket requests based on the path of the URL:</p><pre><code><span class="keyword">export</span> <span class="keyword">default</span> <span class="punctuation">{</span>
  <span class="literal-property">fetch</span><span class="operator">:</span> <span class="function"><a href="/api/synchronizer-ws-server-durable-object/functions/creation/getwsserverdurableobjectfetch/">getWsServerDurableObjectFetch</a></span><span class="punctuation">(</span><span class="string">'TinyBaseDurableObjects'</span><span class="punctuation">)</span><span class="punctuation">,</span>
<span class="punctuation">}</span><span class="punctuation">;</span>
</code></pre><p>In here, the argument is the namespace containing your bound Durable Objects.</p><p>Now we need to create the Durable Object itself. This can be as simple as simply extending TinyBase&#x27;s <a href="/api/the-essentials/synchronizing-stores/wsserverdurableobject/"><code>WsServerDurableObject</code></a> class:</p><pre><code><span class="keyword">export</span> <span class="keyword">class</span> <span class="class-name">TinyBaseDurableObject</span> <span class="keyword">extends</span> <span class="class-name"><a href="/api/the-essentials/synchronizing-stores/wsserverdurableobject/">WsServerDurableObject</a></span> <span class="punctuation">{</span>
  <span class="comment">// ...</span>
<span class="punctuation">}</span>
</code></pre><p>This sets up synchronization between any clients that connect to this common <code>/foo</code> path so that their <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> data stays in sync.</p><p>But if all your clients disconnect and flush their locally-stored data, it is technically possible to lose it all! So it&#x27;s also a good idea to have the Durable Object store a synchronized copy too. We do this by overriding the <a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/"><code>createPersister</code></a> method.</p><p>For new Durable Object namespaces, Cloudflare recommends using SQLite storage, which offers better pricing and performance compared to the legacy key-value storage. To use SQLite storage, you&#x27;ll need to configure your Durable Object class in your <code>wrangler.toml</code> file:</p><pre><code><span class="punctuation">[</span><span class="punctuation">[</span><span class="table">migrations</span><span class="punctuation">]</span><span class="punctuation">]</span>
<span class="key">tag</span> <span class="punctuation">=</span> <span class="string">"v1"</span>
<span class="key">new_sqlite_classes</span> <span class="punctuation">=</span> <span class="punctuation">[</span><span class="string">"TinyBaseDurableObject"</span><span class="punctuation">]</span>
</code></pre><p>Then create the persister using the recommended SQL storage. The <code>createDurableObjectSqlStoragePersister</code> supports several persistence modes:</p><h5 id="json-mode-default">JSON Mode (Default)</h5><p>Stores the entire <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> as JSON in a single database row. This is efficient for smaller stores and uses fewer database writes, but may hit Cloudflare&#x27;s 2MB row limit for very large stores.</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/the-essentials/persisting-stores/createdurableobjectsqlstoragepersister/">createDurableObjectSqlStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">.</span>sql<span class="punctuation">,</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><h5 id="fragmented-mode">Fragmented Mode</h5><p>Stores each table, row, cell, and value as separate database rows. Use this mode if you&#x27;re concerned about hitting Cloudflare&#x27;s 2MB row limit with large stores in JSON mode. This mode creates more database writes but avoids row size limitations:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/the-essentials/persisting-stores/createdurableobjectsqlstoragepersister/">createDurableObjectSqlStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">.</span>sql<span class="punctuation">,</span>
    <span class="punctuation">{</span><span class="literal-property">mode</span><span class="operator">:</span> <span class="string">'fragmented'</span><span class="punctuation">}</span><span class="punctuation">,</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><p>The <code>createDurableObjectSqlStoragePersister</code> function supports several optional parameters for more advanced use cases.</p><p>If you need a custom table name, you can specify a custom table name for the JSON serialization mode:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/the-essentials/persisting-stores/createdurableobjectsqlstoragepersister/">createDurableObjectSqlStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">.</span>sql<span class="punctuation">,</span>
    <span class="string">'my_app_data'</span><span class="punctuation">,</span> <span class="comment">// Custom table name</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><p>You can use fragmented mode with a custom storage prefix:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/the-essentials/persisting-stores/createdurableobjectsqlstoragepersister/">createDurableObjectSqlStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">.</span>sql<span class="punctuation">,</span>
    <span class="punctuation">{</span><span class="literal-property">mode</span><span class="operator">:</span> <span class="string">'fragmented'</span><span class="punctuation">,</span> <span class="literal-property">storagePrefix</span><span class="operator">:</span> <span class="string">'my_app_'</span><span class="punctuation">}</span><span class="punctuation">,</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><p>And for debugging and logging, you can add SQL command logging and error handling. This is useful for development:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/the-essentials/persisting-stores/createdurableobjectsqlstoragepersister/">createDurableObjectSqlStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">.</span>sql<span class="punctuation">,</span>
    <span class="string">'my_app_data'</span><span class="punctuation">,</span>
    <span class="punctuation">(</span><span class="parameter">sql<span class="punctuation">,</span> params</span><span class="punctuation">)</span> <span class="operator">=></span> console<span class="punctuation">.</span><span class="function">log</span><span class="punctuation">(</span><span class="string">'SQL:'</span><span class="punctuation">,</span> sql<span class="punctuation">,</span> params<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">// Log SQL commands</span>
    <span class="punctuation">(</span><span class="parameter">error</span><span class="punctuation">)</span> <span class="operator">=></span> console<span class="punctuation">.</span><span class="function">error</span><span class="punctuation">(</span><span class="string">'Persistence error:'</span><span class="punctuation">,</span> error<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">// Handle errors</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><p>Alternatively, if you&#x27;re using an existing Durable Object namespace with key-value storage, you can use the legacy persister:</p><pre><code><span class="comment">// ...</span>
<span class="function"><a href="/api/synchronizer-ws-server-durable-object/classes/creation/wsserverdurableobject/methods/creation/createpersister/">createPersister</a></span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="function"><a href="/api/persister-durable-object-storage/functions/creation/createdurableobjectstoragepersister/">createDurableObjectStoragePersister</a></span><span class="punctuation">(</span>
    <span class="function"><a href="/api/the-essentials/creating-stores/createmergeablestore/">createMergeableStore</a></span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>
    <span class="keyword">this</span><span class="punctuation">.</span>ctx<span class="punctuation">.</span>storage<span class="punctuation">,</span>
  <span class="punctuation">)</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
<span class="comment">// ...</span>
</code></pre><p>In this method, all we need to do is create a <a href="/api/mergeable-store/interfaces/mergeable/mergeablestore/"><code>MergeableStore</code></a> (that will reside in the Durable Object memory whenever it is running and not hibernated), and indicate how it will be persisted. The <a href="/api/persister-durable-object-sql-storage/interfaces/persister/durableobjectsqlstoragepersister/"><code>DurableObjectSqlStoragePersister</code></a> is dedicated to storing a TinyBase <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> in Durable Object SQLite storage, while the <a href="/api/persister-durable-object-storage/interfaces/persister/durableobjectstoragepersister/"><code>DurableObjectStoragePersister</code></a> uses the legacy key-value storage.</p><p>With this in place you now have the full set up! The clients are storing a local copy of the TinyBase data so they can go offline and reload without loss of data; and the server is also storing a copy of the data in Durable Object storage. When online, the clients will connect to the worker, which routes the request to the Durable Object indicated by the URL path, and synchronization between them all keeps them each up-to-date!</p><h3 id="final-notes">Final Notes</h3><p>The choice between SQLite and key-value storage affects the data limitations and configuration options:</p><ul><li><p><strong>SQLite storage</strong> (recommended): Uses SQL tables to store TinyBase data with structured tables for tables and values, including proper CRDT metadata. This provides better performance and pricing. The SQLite persister supports JSON serialization mode (default), fragmented mode for avoiding the 2MB row limit.</p></li><li><p><strong>Key-value storage</strong> (legacy): Has limitations on the data that can be stored in each key. The <a href="/api/persister-durable-object-storage/interfaces/persister/durableobjectstoragepersister/"><code>DurableObjectStoragePersister</code></a> uses one key per TinyBase <a href="/api/store/type-aliases/store/value/"><code>Value</code></a>, one key per <a href="/api/store/type-aliases/store/cell/"><code>Cell</code></a>, one key per <a href="/api/store/type-aliases/store/row/"><code>Row</code></a>, and one key per <a href="/api/store/type-aliases/store/table/"><code>Table</code></a>. The main caution is to ensure that each individual TinyBase <a href="/api/store/type-aliases/store/cell/"><code>Cell</code></a> and <a href="/api/store/type-aliases/store/value/"><code>Value</code></a> data does not exceed the 128 KiB limit.</p></li></ul><p><strong>When to use SQLite Fragmented Mode</strong>: If you have a large TinyBase <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> that might approach or exceed Cloudflare&#x27;s 2MB row limit when serialized as JSON, use SQLite storage in fragmented mode. JSON mode uses significantly fewer database writes and is more efficient for smaller stores, but fragmented mode provides better scalability for very large datasets by storing each piece of data in separate rows.</p><p>The <a href="/api/the-essentials/synchronizing-stores/wsserverdurableobject/"><code>WsServerDurableObject</code></a> is an overridden implementation of the DurableObject class, so you can have access to its members as well as the TinyBase-specific methods. If you are using the storage for other data, you may want to configure a custom table name or use tabular mode to ensure you don&#x27;t accidentally collide with other data.</p><p>Also, always remember to call the <code>super</code> implementations of the methods that TinyBase uses (the constructor, <code>fetch</code>, <code>webSocketMessage</code>, and <code>webSocketClose</code>) if you further override them.</p><p>Finally, the <a href="/api/the-essentials/synchronizing-stores/wsserverdurableobject/"><code>WsServerDurableObject</code></a> uses hibernation, which is a Cloudflare feature to minimize the amount of memory used by your Durable Object. After a small amount of time with no WebSocket activity, it will be &#x27;hibernated&#x27; even though the WebSockets stay connected. This means that the in-memory TinyBase <a href="/api/the-essentials/creating-stores/store/"><code>Store</code></a> will be removed (which is a good thing for your Cloudflare usage!) and then re-created with the <a href="/api/the-essentials/persisting-stores/persister/"><code>Persister</code></a> when new activity arrives. This lifecycle should be transparent, but should be understood if you want to debug certain Durable Object behaviors.</p></section>