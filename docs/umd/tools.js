var e,a;e=this,a=function(e){"use strict";const a=e=>typeof e,l="",t=a(l),s=a(!0),o=a(0),n="type",d="default",r=(e,a)=>e.every(a),$=(e,a)=>e.sort(a),i=(e,a)=>e.forEach(a),u=(e,a)=>e.map(a),I=e=>e.length,c=e=>0==I(e),b=(e,...a)=>e.push(...a),w=e=>e.pop(),h=(e,...a)=>e.unshift(...a),g=e=>e.shift(),C=JSON.parse,T=isFinite,f=(e,a)=>e instanceof a,V=e=>null==e,R=e=>e==t||e==s,m=e=>a(e)==t,p=e=>Array.isArray(e),v=e=>{const l=a(e);return R(l)||l==o&&T(e)?l:void 0},L=(e,a)=>e?.has(a)??!1,y=e=>[...e?.values()??[]],S=(e,a)=>e?.forEach(a),k=(e,a)=>e?.delete(a),J=e=>new Map(e),E=(e,a)=>e?.get(a),j=(e,a)=>S(e,((e,l)=>a(l,e))),x=(e,a)=>u([...e?.entries()??[]],(([e,l])=>a(l,e))),A=(e,a,l)=>V(l)?(k(e,a),e):e?.set(a,l),O=(e,a,l)=>(L(e,a)||A(e,a,l()),E(e,a)),D=e=>new Set(p(e)||V(e)?e:[e]),N=(e,a)=>e?.add(a),G=e=>[e,e],z=()=>[J(),J()],F=/[^A-Za-z]+/,P=/[^A-Za-z0-9]+/,W=/^( *)\/\*\* *(.*?) *\*\/$/gm,M=(e,a,l)=>e.substring(a,l),Z=e=>e.toUpperCase(),_=e=>e.toLowerCase(),B=(e,a,l,t=1)=>{const s=`${a}${1==t?"":t}`;return L(e,s)?B(e,a,l,t+1):(A(e,s,l),s)},Q=e=>e.replace(W,((e,a,l)=>{const t=77-U(a);return`${a}/**\n${l.replace(RegExp(`([^\\n]{1,${t}})(\\s|$)`,"g"),a+" * $1\n")}${a} */`})),U=e=>e.length,q=(e,a=l)=>e.join(a),H=e=>e.flat(1e3),K=(e,a=0)=>q(u(e.split(P),((e,l)=>(l>0||a?Z:_)(M(e,0,1))+M(e,1)))),X=e=>Z(q((e&&!F.test(e[0])?e:" "+e).split(P),"_")),Y=e=>`/** ${e}. */`,ee=()=>{const e=z(),a=J(),t=J(),s=J();return[(...e)=>q(H(e),"\n"),(a,l,...t)=>i(t,(t=>N(O(e[a],l,D),t))),(e,l,t)=>B(a,e,[l,t]),(e,a,l,s,o,n="")=>B(t,e,[a,l,s,o,n]),(e,a,l)=>B(s,e,p(l)?[`(${a}) => {`,l,"}"]:[`(${a}) => ${l}`]),(e,a)=>E(s,e)===a?e:B(s,e,a),a=>[...$(x(e[a],((e,a)=>`import {${q($(y(e)),", ")}} from '${a}';`))),l],()=>x(a,(([e,a],t)=>[Y(a),`export type ${t} = ${e};`,l])),e=>x(t,(([a,t,s,o,n],d)=>{const r=e?[`${d}: ${n}(${a}): ${t} => ${s},`]:[`${d}${n}(${a}): ${t};`];return e||h(r,Y(o)),b(r,l),r})),()=>x(s,((e,a)=>(e=p(e)?e:[e],b(e,w(e)+";"),[`const ${a} = ${g(e)}`,e,l])))]},ae=Object,le=ae.keys,te=ae.freeze,se=e=>f(e,ae)&&e.constructor==ae,oe=(e,a)=>u(ae.entries(e),(([e,l])=>a(l,e))),ne=e=>se(e)&&c(le(e)),de="the Store",re="A function for",$e="export",ie="listener",ue=" | undefined",Ie=`Registers a ${ie} that will be called`,ce="Represents",be=" => void",we="the end of the transaction",he="the specified Row",ge="a string serialization of",Ce=(e=0,a=0)=>`the ${Ne[e]}content of${a?" "+de:""}`,Te=(e,a=0,l=0)=>`${Oe[e]} ${Ce(a,1)}${l?" when set":""}`,fe=(e,a=0)=>`${ce} a Row when ${a?"s":"g"}etting ${Ce()} the '${e}' Table`,Ve=(e,a,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in ${a}`,Re=(e,a)=>`Calls a function for each ${e} in ${a}`,me=(e,a=de)=>`Gets whether ${e} exists in ${a}`,pe=e=>"A function that takes "+e,ve=(e,a=0)=>`${re} listening to changes to ${De[e]} in ${De[a]}`,Le=(e,a,t=0)=>`${Ie} whenever ${e} in ${a} change`+(t?l:"s"),ye=e=>`the '${e}' Table`,Se=e=>`${he} in ${ye(e)}`,ke=e=>`the '${e}' Cell`,Je=e=>`the '${e}' Value`,Ee=(e,a=0)=>`${Oe[a]} ${Ce()} ${ye(e)}`,je=(e,a=0)=>`${Oe[a]} ${Ce()} ${Se(e)}`,xe=(e,a,l=0)=>`${Oe[l]} ${ke(a)} for ${Se(e)}`,Ae=(e,a=0)=>`${Oe[a]} ${Je(e)}`,Oe=["Gets","Sets","Sets part of","Deletes",ce,"Gets "+ge,"Sets "+ge,Ie+" whenever"],De=[de,"Tables","Table Ids","a Table","Row Ids","a Row","Cell Ids","a Cell","invalid Cell changes","Values","Value Ids","a Value","invalid Value changes"],Ne=["","tabular ","keyed value "],Ge=["DoRollback","Id","IdOrNull","Ids","Json","Store"],ze=(e,a=l,t=l)=>`store.${e}(${a})${t?" as "+t:l}`,Fe=(e,a=l)=>`fluent(() => ${ze(e,a)})`,Pe=(e,a=l,t=l)=>`store.${e}(${a?a+", ":l}proxy(${ie})${t?", "+t:l})`,We=(e,a,t)=>{if(ne(e)&&ne(a))return G(l);const[o,r,$,i,u,I,c,w,h,g]=ee(),C=`./${K(t)}.d`,T=K(t,1),f=K(T),R=[],p=J(),v=a=>oe(e,((e,t)=>a(t,O(p,t,(()=>{const e=K(t,1);return[$(e+"Table",`{[rowId: Id]: ${e}Row}`,`${ce} the '${t}' Table`),$(e+"Row",`{${q(L(t,((e,a,t)=>`'${e}'${V(t)?"?":l}: ${a};`))," ")}}`,fe(t)),$(e+"RowWhenSet",`{${q(L(t,((e,a)=>`'${e}'?: ${a};`))," ")}}`,fe(t,1)),$(e+"CellId",q(L(t,(e=>`'${e}'`))," | "),`A Cell Id for the '${t}' Table`),$(e+"CellCallback",`(...[cellId, cell]: ${q(L(t,((e,a)=>`[cellId: '${e}', cell: ${a}]`))," | ")})${be}`,pe(`a Cell Id and value from a Row in the '${t}' Table`)),$(e+"RowCallback",`(rowId: Id, forEachCell: (cellCallback: ${e}CellCallback)${be})${be}`,pe(`a Row Id from the '${t}' Table, and a Cell iterator`))]})),K(t,1),I(X(t),`'${t}'`)))),L=(a,l)=>oe(e[a],((e,a)=>l(a,e[n],e[d],I(X(a),`'${a}'`),K(a,1)))),S=e=>oe(a,((a,l)=>e(l,a[n],a[d],I(X(l),`'${l}'`),K(l,1))));if(r(1,C,T,`create${T} as create${T}Decl`),!ne(e)){const e=$("Tables",`{${q(v(((e,a)=>`'${e}'?: ${a[0]};`))," ")}}`,Te(4,1)),a=$("TableId",q(v((e=>`'${e}'`))," | "),"A Table Id in "+de),t=$("TableCallback",`(...[tableId, rowCallback]: ${q(v(((e,a)=>`[tableId: '${e}', forEachRow: (rowCallback: ${a[5]})${be}]`))," | ")})${be}`,pe("a Table Id, and a Row iterator")),o=$("GetCellChange",`(...[tableId, rowId, cellId]: ${q(v(((e,a)=>`[tableId: '${e}', rowId: Id, cellId: ${a[3]}]`))," | ")}) => CellChange`,re+" returning information about any Cell's changes during a transaction"),u=$("TablesListener",`(${f}: ${T}, getCellChange: ${o}${ue})${be}`,ve(1)),c=$("TableIdsListener",`(${f}: ${T})${be}`,ve(2)),w=$("TableListener",`(${f}: ${T}, tableId: ${a}, getCellChange: ${o}${ue})${be}`,ve(3)),h=$("RowIdsListener",`(${f}: ${T}, tableId: ${a})`+be,ve(4,3)),g=$("RowListener",`(${f}: ${T}, tableId: ${a}, rowId: Id, getCellChange: ${o}${ue})${be}`,ve(5,3)),p=$("CellIdsListener",`(${f}: ${T}, tableId: ${a}, rowId: Id)`+be,ve(6,5)),S=$("CellListener",`(...[${f}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${q(H(v((e=>L(e,((a,l)=>`[${f}: ${T}, tableId: '${e}', rowId: Id, cellId: '${a}', newCell: ${l}${ue}, oldCell: ${l}${ue}, getCellChange: ${o} | undefined]`)))))," | ")})${be}`,ve(7,5)),k=$("InvalidCellListener",`(${f}: ${T}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${be}`,ve(8));i("hasTables",l,s,ze("hasTables"),me("any Table")),i("getTables",l,e,ze("getTables"),Te(0,1)),i("setTables","tables: "+e,T,Fe("setTables","tables"),Te(1,1)),i("delTables",l,T,Fe("delTables"),Te(3,1)),i("getTableIds",l,a+"[]",ze("getTableIds",l,a+"[]"),Ve("Table",de)),i("forEachTable","tableCallback: "+t,"void",ze("forEachTable","tableCallback as any"),Re("Table",de));const E=J();v(((e,[a,t,o,n,d,$],u,I)=>{r(1,C,a,t,o,n,d,$),i(`has${u}Table`,l,s,ze("hasTable",I),me(ye(e))),i(`get${u}Table`,l,a,ze("getTable",I,a),Ee(e)),i(`set${u}Table`,"table: "+a,T,Fe("setTable",I+", table"),Ee(e,1)),i(`del${u}Table`,l,T,Fe("delTable",I),Ee(e,3)),i(`get${u}RowIds`,l,"Ids",ze("getRowIds",I),Ve("Row",ye(e))),i(`get${u}SortedRowIds`,`cellId?: ${n}, descending?: boolean, offset?: number, limit?: number`,"Ids",ze("getSortedRowIds",I+", cellId, descending, offset, limit"),Ve("Row",ye(e),1)),i(`forEach${u}Row`,"rowCallback: "+$,"void",ze("forEachRow",I+", rowCallback as any"),Re("Row",ye(e))),i(`has${u}Row`,"rowId: Id",s,ze("hasRow",I+", rowId"),me(he,ye(e))),i(`get${u}Row`,"rowId: Id",t,ze("getRow",I+", rowId",t),je(e)),i(`set${u}Row`,"rowId: Id, row: "+o,T,Fe("setRow",I+", rowId, row"),je(e,1)),i(`add${u}Row`,"row: "+o,"Id"+ue,ze("addRow",I+", row"),"Adds a new Row to "+ye(e)),i(`set${u}PartialRow`,"rowId: Id, partialRow: "+o,T,Fe("setPartialRow",I+", rowId, partialRow"),je(e,2)),i(`del${u}Row`,"rowId: Id",T,Fe("delRow",I+", rowId"),je(e,3)),i(`get${u}CellIds`,"rowId: Id",n+"[]",ze("getCellIds",I+", rowId",n+"[]"),Ve("Cell",Se(e))),i(`forEach${u}Cell`,"rowId: Id, cellCallback: "+d,"void",ze("forEachCell",I+", rowId, cellCallback as any"),Re("Cell",Se(e))),L(e,((a,t,o,n,d)=>{const r="Map"+K(t,1);A(E,t,r),i(`has${u}${d}Cell`,"rowId: Id",s,ze("hasCell",`${I}, rowId, ${n}`),me(ke(a),Se(e)));const $=`${t}${V(o)?ue:l}`;i(`get${u}${d}Cell`,"rowId: Id",$,ze("getCell",`${I}, rowId, ${n}`,$),xe(e,a)),i(`set${u}${d}Cell`,`rowId: Id, cell: ${t} | ${r}`,T,Fe("setCell",`${I}, rowId, ${n}, cell as any`),xe(e,a,1)),i(`del${u}${d}Cell`,"rowId: Id",T,Fe("delCell",`${I}, rowId, ${n}`),xe(e,a,3))}))})),i("getTablesJson",l,"Json",ze("getTablesJson"),Te(5,1)),i("setTablesJson","tablesJson: Json",T,Fe("setTablesJson","tablesJson"),Te(6,1)),i("addTablesListener",`${ie}: ${u}, mutator?: boolean`,"Id",Pe("addTablesListener",l,"mutator"),Te(7,1)+" changes"),i("addTableIdsListener",`${ie}: ${c}, mutator?: boolean`,"Id",Pe("addTableIdsListener",l,"mutator"),Le("the Table Ids",de,1)),i("addTableListener",`tableId: ${a} | null, ${ie}: ${w}, mutator?: boolean`,"Id",Pe("addTableListener","tableId","mutator"),Le("a Table",de)),i("addRowIdsListener",`tableId: ${a} | null, ${ie}: ${h}, mutator?: boolean`,"Id",Pe("addRowIdsListener","tableId","mutator"),Le("the Row Ids","a Table",1)),i("addRowListener",`tableId: ${a} | null, rowId: IdOrNull, ${ie}: ${g}, mutator?: boolean`,"Id",Pe("addRowListener","tableId, rowId","mutator"),Le("a Row","a Table")),i("addCellIdsListener",`tableId: ${a} | null, rowId: IdOrNull, ${ie}: ${p}, mutator?: boolean`,"Id",Pe("addCellIdsListener","tableId, rowId","mutator"),Le("the Cell Ids","a Row",1)),i("addCellListener",`tableId: ${a} | null, rowId: IdOrNull, cellId: ${q(v(((e,a)=>a[3]))," | ")} | null, ${ie}: ${S}, mutator?: boolean`,"Id",Pe("addCellListener","tableId, rowId, cellId","mutator"),Le("a Cell","a Row")),i("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${ie}: ${k}, mutator?: boolean`,"Id",Pe("addInvalidCellListener","tableId, rowId, cellId","mutator"),Ie+" whenever an invalid Cell change was attempted"),j(E,((e,a)=>$(a,`(cell: ${e}${ue}) => ${e}`,`Takes a ${e} Cell value and returns another`))),r(1,C,e,a,t,u,c,w,h,g,p,S,k,...y(E)),r(0,"tinybase","CellChange"),b(R,".setTablesSchema({",H(v(((e,a,t,s)=>[`[${s}]: {`,...L(e,((e,a,t,s)=>`[${s}]: {[${I(X(n),`'${n}'`)}]: ${I(X(a),`'${a}'`)}${V(t)?l:`, [${I(X(d),`'${d}'`)}]: ${m(t)?I(X(t),`'${t}'`):t}`}},`)),"},"]))),"})")}if(!ne(a)){const e=$("Values",`{${q(S(((e,a,t)=>`'${e}'${V(t)?"?":l}: ${a};`))," ")}}`,Te(4,2)),a=$("ValuesWhenSet",`{${q(S(((e,a)=>`'${e}'?: ${a};`))," ")}}`,Te(4,2,1)),t=$("ValueId",q(S((e=>`'${e}'`))," | "),"A Value Id in "+de),o=$("ValueCallback",`(...[valueId, rowCallback]: ${q(S(((e,a)=>`[valueId: '${e}', value: ${a}]`))," | ")})${be}`,pe("a Value Id, and value")),u=$("GetValueChange",`(valueId: ${t}) => ValueChange`,re+" returning information about any Value's changes during a transaction"),c=$("ValuesListener",`(${f}: ${T}, getValueChange: ${u}${ue})`+be,ve(9)),w=$("ValueIdsListener",`(${f}: ${T})${be}`,ve(10)),h=$("ValueListener",`(...[${f}, valueId, newValue, oldValue, getValueChange]: ${q(S(((e,a)=>`[${f}: ${T}, valueId: '${e}', newValue: ${a}${ue}, oldValue: ${a}${ue}, getValueChange: ${u} | undefined]`))," | ")})${be}`,ve(11)),g=$("InvalidValueListener",`(${f}: ${T}, valueId: Id, invalidValues: any[])${be}`,ve(12));i("hasValues",l,s,ze("hasValues"),me("any Value")),i("getValues",l,e,ze("getValues"),Te(0,2)),i("setValues","values: "+a,T,Fe("setValues","values"),Te(1,2)),i("setPartialValues","partialValues: "+a,T,Fe("setPartialValues","partialValues"),Te(2,2)),i("delValues",l,T,Fe("delValues"),Te(3,2)),i("getValueIds",l,t+"[]",ze("getValueIds",l,t+"[]"),Ve("Value",de)),i("forEachValue","valueCallback: "+o,"void",ze("forEachValue","valueCallback as any"),Re("Value",de)),S(((e,a,t,o,n)=>{i(`has${n}Value`,l,s,ze("hasValue",o),me(Je(e))),i(`get${n}Value`,l,a,ze("getValue",o,a),Ae(e)),i(`set${n}Value`,"value: "+a,T,Fe("setValue",o+", value"),Ae(e,1)),i(`del${n}Value`,l,T,Fe("delValue",o),Ae(e,3))})),i("getValuesJson",l,"Json",ze("getValuesJson"),Te(5,2)),i("setValuesJson","valuesJson: Json",T,Fe("setValuesJson","valuesJson"),Te(6,2)),i("addValuesListener",`${ie}: ${c}, mutator?: boolean`,"Id",Pe("addValuesListener",l,"mutator"),Te(7,2)+" changes"),i("addValueIdsListener",`${ie}: ${w}, mutator?: boolean`,"Id",Pe("addValueIdsListener",l,"mutator"),Le("the Value Ids",de,1)),i("addValueListener",`valueId: ${t} | null, ${ie}: ${h}, mutator?: boolean`,"Id",Pe("addValueListener","valueId","mutator"),Le("a Value",de)),i("addInvalidValueListener",`valueId: IdOrNull, ${ie}: ${g}, mutator?: boolean`,"Id",Pe("addInvalidValueListener","valueId","mutator"),Ie+" whenever an invalid Cell change was attempted"),r(1,C,e,t,o,c,w,h,g),r(0,"tinybase","ValueChange"),b(R,".setValuesSchema({",S(((e,a,t,s)=>[`[${s}]: {[${I(X(n),`'${n}'`)}]: ${I(X(a),`'${a}'`)}${V(t)?l:`, [${I(X(d),`'${d}'`)}]: ${m(t)?I(X(t),`'${t}'`):t}`}},`])),"})")}r(0,"tinybase",...Ge);const k=$("TransactionListener",`(${f}: ${T}, cellsTouched: boolean, valuesTouched: boolean)${be}`,re+" listening to the completion of a transaction");return i("getJson",l,"Json",ze("getJson"),Te(5)),i("setJson","json: Json",T,Fe("setJson","json"),Te(6)),i("transaction","actions: () => Return, doRollback?: DoRollback","Return",ze("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),i("startTransaction",l,T,Fe("startTransaction"),"Explicitly starts a transaction"),i("finishTransaction","doRollback?: DoRollback,",T,Fe("finishTransaction","doRollback"),"Explicitly finishes a transaction"),i("addWillFinishTransactionListener",`${ie}: ${k}`,"Id",Pe("addWillFinishTransactionListener"),`${Ie} just before ${we}`),i("addDidFinishTransactionListener",`${ie}: ${k}`,"Id",Pe("addDidFinishTransactionListener"),`${Ie} just after ${we}`),i("callListener",ie+"Id: Id",T,Fe("callListener",ie+"Id"),`Manually provoke a ${ie} to be called`),i("delListener",ie+"Id: Id",T,Fe("delListener",ie+"Id"),`Remove a ${ie} that was previously added to ${de}`),i("getStore",l,"Store","store",Oe[0]+" the underlying Store object"),r(1,"tinybase","createStore",...Ge),r(1,C,T,`create${T} as create${T}Decl`,k),I("store",["createStore()",...R]),u("fluent","actions: () => Store",["actions();",`return ${f};`]),u("proxy",ie+": any",`(_: Store, ...args: any[]) => ${ie}(${f}, ...args)`),I(f,["{",...h(1),"}"]),[o(...c(0),...w(),`${$e} interface ${T} {`,...h(0),"}",l,Y(`Creates a ${T} object`),`${$e} function create${T}(): ${T};`),o(...c(1),`${$e} const create${T}: typeof create${T}Decl = () => {`,...g(),`return Object.freeze(${f});`,"};")]},Me={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Ze=(e=>{const a=new WeakMap;return l=>(a.has(l)||a.set(l,e(l)),a.get(l))})((e=>{const a=()=>{const a=C(e.getTablesSchemaJson());return!ne(a)||r(e.getTableIds(),(l=>{const t=e.getRowIds(l),s=J();if(r(t,(a=>r(e.getCellIds(l,a),(t=>{const o=e.getCell(l,a,t),n=O(s,t,(()=>[v(o),J(),[0],0])),[d,r,[$]]=n,i=O(r,o,(()=>0))+1;return i>$&&(n[2]=[i,o]),A(r,o,i),n[3]++,d==v(o)})))))return a[l]={},S(s,(([e,,[,s],o],r)=>{a[l][r]={[n]:e,...o==I(t)?{[d]:s}:{}}})),1}))?a:{}},l=()=>{const a=C(e.getValuesSchemaJson());return ne(a)&&e.forEachValue(((e,l)=>{a[e]={[n]:v(l)}})),a},t=e=>We(a(),l(),e),s=async e=>{let a;try{a=(await import("prettier")).format}catch{a=e=>e}return u(t(e),(e=>Q(a(e,Me))))};return te({getStoreStats:a=>{let l=0,t=0,s=0;const o={};return e.forEachTable(((e,n)=>{l++;let d=0,r=0;const $={};n(((e,l)=>{d++;let t=0;l((()=>t++)),r+=t,a&&($[e]={rowCells:t})})),t+=d,s+=r,a&&(o[e]={tableRows:d,tableCells:r,rows:$})})),{totalTables:l,totalRows:t,totalCells:s,totalValues:I(e.getValueIds()),jsonLength:U(e.getJson()),...a?{detail:{tables:o}}:{}}},getStoreTablesSchema:a,getStoreValuesSchema:l,getStoreApi:t,getPrettyStoreApi:s,getStore:()=>e})}));e.createTools=Ze},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBaseTools={});
