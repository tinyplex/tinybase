var t,e;t=this,e=function(t){"use strict";const e=t=>typeof t,a=e(""),n=t=>null==t,s=(t,e,a)=>n(t)?a?.():e(t),o=Object,i=t=>o.getPrototypeOf(t),r=o.entries,c=o.keys,d=o.freeze,y=(t,e)=>s(t,(t=>t[e])),u=(t,e)=>e in t,l=(t,e)=>(delete t[e],t),p=(t,e)=>((t,e)=>t.map(e))(r(t),(([t,a])=>e(a,t))),g=t=>c(t).length,h=t=>(t=>!n(t)&&s(i(t),(t=>t==o.prototype||n(i(t))),(()=>!0)))(t)&&0==g(t),v=t=>new Map(t),f=(t,e)=>t?.get(e),w=(t,e,a)=>{return n(a)?(s=t,o=e,s?.delete(o),t):t?.set(e,a);var s,o},A=(t,e,a,n)=>{var s,o;return s=t,o=e,s?.has(o)||w(t,e,a()),f(t,e)},L=v(),b=v(),C=(t,e)=>[t[e].t,t[e].v],S=(t,e,a,s)=>{const o=n(e)?t:((t,e,a)=>(u(t,e)||(t[e]={}),t[e]))(t,e);let i;return p(a,((t,e)=>{s(o,e,t)&&(i=1)})),p(o,((t,e)=>{u(a,e)||(l(o,e),i=1)})),!n(e)&&h(o)&&l(t,e),i};t.createAutomergePersister=(t,o,i="tinybase",r)=>(o.change((t=>t[i]={})),((t,o,i,r,c,y,u,l={},p=[])=>{let g,v,C,S=0;A(L,p,(()=>0)),A(b,p,(()=>[]));const[m,T,x,M,P]=((t,e)=>[0,e.getContent,e.getTransactionChanges,([t,e])=>!h(t)||!h(e),e.setContent])(0,t),j=async t=>(2!=S&&(S=1,await O.schedule((async()=>{await t(),S=0}))),O),D=n=>{var s;(m&&(s=n?.[0],e(s)==a)?1===n?.[1][2]?t.applyMergeableChanges:t.setMergeableContent:1===n?.[2]?t.applyChanges:t.setContent)(n)},O={load:async t=>await j((async()=>{try{D(await o())}catch(e){y?.(e),t&&P(t)}})),startAutoLoad:async t=>(await O.stopAutoLoad().load(t),v=r((async(t,e)=>{const a=e?.();await j((async()=>{try{D(a??t?.()??await o())}catch(t){y?.(t)}}))})),O),stopAutoLoad:()=>(v&&(c(v),v=void 0),O),isAutoLoading:()=>!n(v),save:async t=>(1!=S&&(S=2,await O.schedule((async()=>{try{await i(T,t)}catch(t){y?.(t)}S=0}))),O),startAutoSave:async()=>(await O.stopAutoSave().save(),C=t.addDidFinishTransactionListener((()=>{const t=x();M(t)&&O.save((()=>t))})),O),stopAutoSave:()=>(s(C,t.delListener),C=void 0,O),isAutoSaving:()=>!n(C),schedule:async(...t)=>(((t,...e)=>{t.push(...e)})(f(b,p),...t),await(async()=>{if(!f(L,p)){for(w(L,p,1);!n((t=f(b,p),g=t.shift()));)try{await g()}catch(t){y?.(t)}w(L,p,0)}var t})(),O),getStore:()=>t,destroy:()=>O.stopAutoLoad().stopAutoSave(),getStats:()=>({}),...l};return d(O)})(t,(async()=>{const t=await o.doc();return 2==g(t[i])?C(t,i):void 0}),(async(t,e)=>o.change((a=>((t,e,a,o)=>{((t,e)=>{h(t[e])&&(t[e]={t:{},v:{}})})(t,e);const[i,r]=C(t,e),c=()=>{d=1};let d=1;if(s(o?.(),(([t,e])=>{d=0,p(t,((t,e)=>d?0:n(t)?l(i,e):s(i[e],(e=>p(t,((t,a)=>d?0:n(t)?l(e,a):s(y(e,a),(e=>p(t,((t,a)=>n(t)?l(e,a):e[a]=t))),c)))),c))),p(e,((t,e)=>d?0:n(t)?l(r,e):r[e]=t))})),d){const[t,e]=a();S(i,void 0,t,((t,e,a)=>S(i,e,a,((t,e,a)=>S(t,e,a,((t,e,a)=>{if(y(t,e)!==a)return t[e]=a,1})))))),S(r,void 0,e,((t,e,a)=>{y(r,e)!==a&&(r[e]=a)}))}})(a,i,t,e)))),(t=>{const e=({doc:e})=>t((()=>C(e,i)));return o.on("change",e),e}),(t=>{o.removeListener("change",t)}),r,0,{getDocHandle:()=>o}))},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterAutomerge={});
