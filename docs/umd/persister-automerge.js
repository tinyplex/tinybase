var e,t;e=this,t=function(e){"use strict";const t=e=>null==e,a=(e,a,n)=>t(e)?n?.():a(e),n=Object,s=e=>n.getPrototypeOf(e),o=n.entries,r=n.keys,i=n.freeze,c=(e,t)=>a(e,(e=>e[t])),d=(e,t)=>t in e,y=(e,t)=>(delete e[t],e),g=(e,t)=>((e,t)=>e.map(t))(o(e),(([e,a])=>t(a,e))),l=e=>r(e).length,u=e=>(e=>!t(e)&&a(s(e),(e=>e==n.prototype||t(s(e))),(()=>!0)))(e)&&0==l(e),p=e=>new Map(e),h=(e,t)=>e?.get(t),f=(e,a,n)=>{return t(n)?(s=e,o=a,s?.delete(o),e):e?.set(a,n);var s,o},v=(e,t,a,n)=>{var s,o;return s=e,o=t,s?.has(o)||f(e,t,a()),h(e,t)},w=p(),b=p(),A=(e,t)=>[e[t].t,e[t].v],C=(e,a,n,s)=>{const o=t(a)?e:((e,t,a)=>(d(e,t)||(e[t]={}),e[t]))(e,a);let r;return g(n,((e,t)=>{s(o,t,e)&&(r=1)})),g(o,((e,t)=>{d(n,t)||(y(o,t),r=1)})),!t(a)&&u(o)&&y(e,a),r};e.createAutomergePersister=(e,n,s="tinybase",o)=>(n.change((e=>e[s]={})),((e,n,s,o,r,c,d,y={},g=[])=>{let l,p,A,C=0;v(w,g,(()=>0)),v(b,g,(()=>[]));const[S,m,L,M,T]=((e=1,t)=>e>1&&t.isMergeable()?[1,t.getMergeableContent,t.getTransactionMergeableChanges,([[e],[t]])=>!u(e)||!u(t),t.setDefaultContent]:2!=e?[0,t.getContent,t.getTransactionChanges,([e,t])=>!u(e)||!u(t),t.setContent]:(e=>{throw Error("Store type not supported by this Persister")})())(d,e),P=t=>{var a;(S&&(a=t?.[0],Array.isArray(a))?1===t?.[2]?e.applyMergeableChanges:e.setMergeableContent:1===t?.[2]?e.applyChanges:e.setContent)(t)},x=async e=>(2!=C&&(C=1,await k((async()=>{try{P(await n())}catch(t){c?.(t),e&&T(e)}C=0}))),z),D=()=>(p&&(r(p),p=void 0),z),j=async e=>(1!=C&&(C=2,await k((async()=>{try{await s(m,e)}catch(e){c?.(e)}C=0}))),z),O=()=>(a(A,e.delListener),A=void 0,z),k=async(...e)=>(((e,...t)=>{e.push(...t)})(h(b,g),...e),await(async()=>{if(!h(w,g)){for(f(w,g,1);!t((e=h(b,g),l=e.shift()));)try{await l()}catch(e){c?.(e)}f(w,g,0)}var e})(),z),z={load:x,startAutoLoad:async e=>(await D().load(e),p=o((async(e,t)=>{t||e?2!=C&&(C=1,P(t??e),C=0):await x()})),z),stopAutoLoad:D,isAutoLoading:()=>!t(p),save:j,startAutoSave:async()=>(await O().save(),A=e.addDidFinishTransactionListener((()=>{const e=L();M(e)&&j(e)})),z),stopAutoSave:O,isAutoSaving:()=>!t(A),schedule:k,getStore:()=>e,destroy:()=>D().stopAutoSave(),getStats:()=>({}),...y};return i(z)})(e,(async()=>{const e=await n.doc();return 2==l(e[s])?A(e,s):void 0}),(async(e,o)=>n.change((n=>((e,n,s,o)=>{((e,t)=>{u(e[t])&&(e[t]={t:{},v:{}})})(e,n);const[r,i]=A(e,n),d=()=>{l=1};let l=1;if(a(o,(([e,n])=>{l=0,g(e,((e,n)=>l?0:t(e)?y(r,n):a(r[n],(n=>g(e,((e,s)=>l?0:t(e)?y(n,s):a(c(n,s),(a=>g(e,((e,n)=>t(e)?y(a,n):a[n]=e))),d)))),d))),g(n,((e,a)=>l?0:t(e)?y(i,a):i[a]=e))})),l){const[e,t]=s();C(r,void 0,e,((e,t,a)=>C(r,t,a,((e,t,a)=>C(e,t,a,((e,t,a)=>{if(c(e,t)!==a)return e[t]=a,1})))))),C(i,void 0,t,((e,t,a)=>{c(i,t)!==a&&(i[t]=a)}))}})(n,s,e,o)))),(e=>{const t=({doc:t})=>e(A(t,s));return n.on("change",t),t}),(e=>{n.removeListener("change",e)}),o,1,{getDocHandle:()=>n}))},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterAutomerge={});
