var e,t;e=this,t=function(e){"use strict";globalThis.EventTarget&&globalThis.Event||console.error("\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  ```\n  import 'partysocket/event-target-polyfill';\n  ```\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n");var t=class extends Event{message;error;constructor(e,t){super("error",t),this.message=e.message,this.error=e}},s=class extends Event{code;reason;wasClean=!0;constructor(e=1e3,t="",s){super("close",s),this.code=e,this.reason=t}},o=(Event,t),n=s,r="undefined"!=typeof process&&void 0!==process.versions?.node&&"undefined"==typeof document?function(e){return"data"in e?new MessageEvent(e.type,e):"code"in e||"reason"in e?new s(e.code||1999,e.reason||"unknown reason",e):"error"in e?new t(e.error,e):new Event(e.type,e)}:function(e){return new e.constructor(e.type,e)},i={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+4e3*Math.random(),minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:1/0,maxEnqueuedMessages:1/0,startClosed:!1,debug:!1},h=!1,c=class e extends EventTarget{_ws;_retryCount=-1;_uptimeTimeout;_connectTimeout;_shouldReconnect=!0;_connectLock=!1;_binaryType="blob";_closeCalled=!1;_messageQueue=[];_debugLogger=console.log.bind(console);_url;_protocols;_options;constructor(e,t,s={}){super(),this._url=e,this._protocols=t,this._options=s,this._options.startClosed&&(this._shouldReconnect=!1),this._options.debugLogger&&(this._debugLogger=this._options.debugLogger),this._connect()}static get CONNECTING(){return 0}static get OPEN(){return 1}static get CLOSING(){return 2}static get CLOSED(){return 3}get CONNECTING(){return e.CONNECTING}get OPEN(){return e.OPEN}get CLOSING(){return e.CLOSING}get CLOSED(){return e.CLOSED}get binaryType(){return this._ws?this._ws.binaryType:this._binaryType}set binaryType(e){this._binaryType=e,this._ws&&(this._ws.binaryType=e)}get retryCount(){return Math.max(this._retryCount,0)}get bufferedAmount(){return this._messageQueue.reduce(((e,t)=>("string"==typeof t?e+=t.length:t instanceof Blob?e+=t.size:e+=t.byteLength,e)),0)+(this._ws?this._ws.bufferedAmount:0)}get extensions(){return this._ws?this._ws.extensions:""}get protocol(){return this._ws?this._ws.protocol:""}get readyState(){return this._ws?this._ws.readyState:this._options.startClosed?e.CLOSED:e.CONNECTING}get url(){return this._ws?this._ws.url:""}get shouldReconnect(){return this._shouldReconnect}onclose=null;onerror=null;onmessage=null;onopen=null;close(e=1e3,t){this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),this._ws?this._ws.readyState!==this.CLOSED?this._ws.close(e,t):this._debug("close: already closed"):this._debug("close enqueued: no ws instance")}reconnect(e,t){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,this._ws&&this._ws.readyState!==this.CLOSED?(this._disconnect(e,t),this._connect()):this._connect()}send(e){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",e),this._ws.send(e);else{const{maxEnqueuedMessages:t=i.maxEnqueuedMessages}=this._options;this._messageQueue.length<t&&(this._debug("enqueue",e),this._messageQueue.push(e))}}_debug(...e){this._options.debug&&this._debugLogger("RWS>",...e)}_getNextDelay(){const{reconnectionDelayGrowFactor:e=i.reconnectionDelayGrowFactor,minReconnectionDelay:t=i.minReconnectionDelay,maxReconnectionDelay:s=i.maxReconnectionDelay}=this._options;let o=0;return this._retryCount>0&&(o=t*Math.pow(e,this._retryCount-1),o>s&&(o=s)),this._debug("next delay",o),o}_wait(){return new Promise((e=>{setTimeout(e,this._getNextDelay())}))}_getNextProtocols(e){if(!e)return Promise.resolve(null);if("string"==typeof e||Array.isArray(e))return Promise.resolve(e);if("function"==typeof e){const t=e();if(!t)return Promise.resolve(null);if("string"==typeof t||Array.isArray(t))return Promise.resolve(t);if(t.then)return t}throw Error("Invalid protocols")}_getNextUrl(e){if("string"==typeof e)return Promise.resolve(e);if("function"==typeof e){const t=e();if("string"==typeof t)return Promise.resolve(t);if(t.then)return t}throw Error("Invalid URL")}_connect(){if(this._connectLock||!this._shouldReconnect)return;this._connectLock=!0;const{maxRetries:e=i.maxRetries,connectionTimeout:t=i.connectionTimeout}=this._options;this._retryCount>=e?this._debug("max retries reached",this._retryCount,">=",e):(this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),this._wait().then((()=>Promise.all([this._getNextUrl(this._url),this._getNextProtocols(this._protocols||null)]))).then((([e,s])=>{if(this._closeCalled)return void(this._connectLock=!1);this._options.WebSocket||"undefined"!=typeof WebSocket||h||(console.error("‼️ No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run `npm install ws`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n"),h=!0);const o=this._options.WebSocket||WebSocket;this._debug("connect",{url:e,protocols:s}),this._ws=s?new o(e,s):new o(e),this._ws.binaryType=this._binaryType,this._connectLock=!1,this._addListeners(),this._connectTimeout=setTimeout((()=>this._handleTimeout()),t)})).catch((e=>{this._connectLock=!1,this._handleError(new o(Error(e.message),this))})))}_handleTimeout(){this._debug("timeout event"),this._handleError(new o(Error("TIMEOUT"),this))}_disconnect(e=1e3,t){if(this._clearTimeouts(),this._ws){this._removeListeners();try{this._ws.close(e,t),this._handleClose(new n(e,t,this))}catch(e){}}}_acceptOpen(){this._debug("accept open"),this._retryCount=0}_handleOpen=e=>{this._debug("open event");const{minUptime:t=i.minUptime}=this._options;clearTimeout(this._connectTimeout),this._uptimeTimeout=setTimeout((()=>this._acceptOpen()),t),function(e,t){if(!e)throw new Error(t)}(this._ws,"WebSocket is not defined"),this._ws.binaryType=this._binaryType,this._messageQueue.forEach((e=>this._ws?.send(e))),this._messageQueue=[],this.onopen&&this.onopen(e),this.dispatchEvent(r(e))};_handleMessage=e=>{this._debug("message event"),this.onmessage&&this.onmessage(e),this.dispatchEvent(r(e))};_handleError=e=>{this._debug("error event",e.message),this._disconnect(void 0,"TIMEOUT"===e.message?"timeout":void 0),this.onerror&&this.onerror(e),this._debug("exec error listeners"),this.dispatchEvent(r(e)),this._connect()};_handleClose=e=>{this._debug("close event"),this._clearTimeouts(),this._shouldReconnect&&this._connect(),this.onclose&&this.onclose(e),this.dispatchEvent(r(e))};_removeListeners(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))}_addListeners(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))}_clearTimeouts(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)}},a=e=>null!==e[1]&&void 0!==e[1];function u(e,t,s={}){const{host:o,path:n,protocol:r,room:i,party:h,query:c}=e;let u=o.replace(/^(http|https|ws|wss):\/\//,"");if(u.endsWith("/")&&(u=u.slice(0,-1)),n&&n.startsWith("/"))throw new Error("path must not start with a slash");const l=h??"main",_=n?`/${n}`:"",p=r||(u.startsWith("localhost:")||u.startsWith("127.0.0.1:")||u.startsWith("192.168.")||u.startsWith("10.")||u.startsWith("172.")&&u.split(".")[1]>="16"&&u.split(".")[1]<="31"||u.startsWith("[::ffff:7f00:1]:")?t:t+"s"),d=`${p}://${u}/${h?`parties/${h}`:"party"}/${i}${_}`,m=(e={})=>`${d}?${new URLSearchParams([...Object.entries(s),...Object.entries(e).filter(a)])}`,y="function"==typeof c?async()=>m(await c()):m(c);return{host:u,path:_,room:i,name:l,protocol:p,partyUrl:d,urlProvider:y}}var l=class extends c{constructor(e){const t=_(e);super(t.urlProvider,t.protocols,t.socketOptions),this.partySocketOptions=e,this.setWSProperties(t)}_pk;_pkurl;name;room;host;path;updateProperties(e){const t=_({...this.partySocketOptions,...e,host:e.host??this.host,room:e.room??this.room,path:e.path??this.path});this._url=t.urlProvider,this._protocols=t.protocols,this._options=t.socketOptions,this.setWSProperties(t)}setWSProperties(e){const{_pk:t,_pkurl:s,name:o,room:n,host:r,path:i}=e;this._pk=t,this._pkurl=s,this.name=o,this.room=n,this.host=r,this.path=i}reconnect(e,t){if(!this.room||!this.host)throw new Error("The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.");super.reconnect(e,t)}get id(){return this._pk}get roomUrl(){return this._pkurl}static async fetch(e,t){const s=u(e,"http"),o="string"==typeof s.urlProvider?s.urlProvider:await s.urlProvider();return(e.fetch??fetch)(o,t)}};function _(e){const{id:t,host:s,path:o,party:n,room:r,protocol:i,query:h,protocols:c,...a}=e,l=t||function(){if("undefined"!=typeof crypto&&crypto.randomUUID)return crypto.randomUUID();let e=(new Date).getTime(),t="undefined"!=typeof performance&&performance.now&&1e3*performance.now()||0;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(s){let o=16*Math.random();return e>0?(o=(e+o)%16|0,e=Math.floor(e/16)):(o=(t+o)%16|0,t=Math.floor(t/16)),("x"===s?o:3&o|8).toString(16)}))}(),_=u(e,"ws",{_pk:l});return{_pk:l,_pkurl:_.partyUrl,name:_.name,room:_.room,host:_.host,path:_.path,protocols:c,socketOptions:a,urlProvider:_.urlProvider}}e.PartySocket=l,e.WebSocket=c,e.default=l,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).PartySocketModule={});
