var t,e;t=this,e=function(t){"use strict";const e=Promise,a=clearInterval,s=t=>null==t,n=(t,e,a)=>s(t)?a?.():e(t),o=t=>new e(t),r=async t=>e.all(t),c=(t,e)=>t.map(e),i=(t,...e)=>t.push(...e),d=Object,y=t=>d.getPrototypeOf(t),l=d.entries,u=d.keys,w=d.freeze,p=t=>(t=>!s(t)&&n(y(t),(t=>t==d.prototype||s(y(t))),(()=>!0)))(t)&&0==(t=>u(t).length)(t),h=t=>new Map(t),f=(t,e)=>t?.get(e),v=(t,e,a)=>{return s(a)?(n=t,o=e,n?.delete(o),t):t?.set(e,a);var n,o},g=(t,e,a)=>{var s,n;return s=t,n=e,s?.has(n)||v(t,e,a()),f(t,e)},b=h(),A=h(),S=globalThis.window,x=["t","v"],D={keyPath:"k"},j=async(t,e)=>{const a=((e,a)=>c(l(e),(([e,a])=>m(t,"put",{k:e,v:a}))))(e);c(await m(t,"getAllKeys"),(o=>((t,e)=>!s(((t,e)=>n(t,(t=>t[e])))(t,e)))(e,o)?0:i(a,m(t,"delete",o)))),await r(a)},m=async(t,e,a)=>o(((s,n)=>{const o=t[e](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${e} error`)}));t.createIndexedDbPersister=(t,e,y=1,l)=>{const u=async(t,a=[],s=0)=>o(((n,o)=>{const i=(S?S.indexedDB:indexedDB).open(e,s?2:void 0);i.onupgradeneeded=()=>s&&c(x,(t=>{try{i.result.createObjectStore(t,D)}catch{}})),i.onsuccess=async()=>{try{const e=i.result.transaction(x,"readwrite"),s=await r(c(x,(async(s,n)=>await t(e.objectStore(s),a[n]))));i.result.close(),n(s)}catch(t){i.result.close(),o(t)}},i.onerror=()=>o("indexedDB.open error")}));return((t,e,a,o,r,c,[d,y]=[],l=[])=>{let u,h,S,x=0,D=0;g(b,l,(()=>0)),g(A,l,(()=>[]));const j=async t=>(2!=x&&(x=1,await m.schedule((async()=>{await t(),x=0}))),m),m={load:async(a,s)=>await j((async()=>{try{t.setContent(await e())}catch{t.setContent([a,s])}})),startAutoLoad:async(a={},s={})=>(m.stopAutoLoad(),await m.load(a,s),D=1,S=o((async(a,s)=>{if(s){const e=s();await j((async()=>t.setTransactionChanges(e)))}else await j((async()=>{try{t.setContent(a?.()??await e())}catch(t){c?.(t)}}))})),m),stopAutoLoad:()=>(D&&(r(S),S=void 0,D=0),m),save:async e=>(1!=x&&(x=2,await m.schedule((async()=>{try{await a(t.getContent,e)}catch(t){c?.(t)}x=0}))),m),startAutoSave:async()=>(await m.stopAutoSave().save(),u=t.addDidFinishTransactionListener(((t,e)=>{const[a,s]=e();p(a)&&p(s)||m.save((()=>[a,s]))})),m),stopAutoSave:()=>(n(u,t.delListener),u=void 0,m),schedule:async(...t)=>(i(f(A,l),...t),await(async()=>{if(!f(b,l)){for(v(b,l,1);!s((t=f(A,l),h=t.shift()));)try{await h()}catch(t){c?.(t)}v(b,l,0)}var t})(),m),getStore:()=>t,destroy:()=>m.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return d&&(m[d]=()=>y),w(m)})(t,(async()=>await u((async t=>((t=[])=>d.fromEntries(t))(c(await m(t,"getAll"),(({k:t,v:e})=>[t,e])))))),(async t=>await u((async(t,e)=>await j(t,e)),t(),1)),(t=>setInterval(t,1e3*y)),(t=>a(t)),l,["getDbName",e])},t.objectStoreMatch=j},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterIndexedDb={});
