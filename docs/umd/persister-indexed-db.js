var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,a=t(""),s=Promise,n=clearInterval,o=e=>null==e,r=(e,t,a)=>o(e)?a?.():t(e),c=e=>new s(e),i=async e=>s.all(e),d=(e,t)=>e.map(t),y=(e,...t)=>e.push(...t),l=Object,u=e=>l.getPrototypeOf(e),p=l.entries,w=l.keys,h=l.freeze,f=e=>(e=>!o(e)&&r(u(e),(e=>e==l.prototype||o(u(e))),(()=>!0)))(e)&&0==(e=>w(e).length)(e),g=e=>new Map(e),v=(e,t)=>e?.get(t),b=(e,t,a)=>{return o(a)?(s=e,n=t,s?.delete(n),e):e?.set(t,a);var s,n},A=(e,t,a)=>{var s,n;return s=e,n=t,s?.has(n)||b(e,t,a()),v(e,t)},S=g(),C=g(),x=e=>{return s=e?.[0],t(s)==a;var s},D=globalThis.window,j=["t","v"],m={keyPath:"k"},L=async(e,t)=>{const a=((t,a)=>d(p(t),(([t,a])=>T(e,"put",{k:t,v:a}))))(t);d(await T(e,"getAllKeys"),(s=>((e,t)=>t in e)(t,s)?0:y(a,T(e,"delete",s)))),await i(a)},T=async(e,t,a)=>c(((s,n)=>{const o=e[t](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,t,a=1,s)=>{const u=async(e,a=[],s=0)=>c(((n,o)=>{const r=(D?D.indexedDB:indexedDB).open(t,s?2:void 0);r.onupgradeneeded=()=>s&&d(j,(e=>{try{r.result.createObjectStore(e,m)}catch{}})),r.onsuccess=async()=>{try{const t=r.result.transaction(j,"readwrite"),s=await i(d(j,(async(s,n)=>await e(t.objectStore(s),a[n]))));r.result.close(),n(s)}catch(e){r.result.close(),o(e)}},r.onerror=()=>o("indexedDB.open error")}));return((e,t,a,s,n,c,i,[d,l]=[],u=[])=>{let p,w,g,D=0,j=0;A(S,u,(()=>0)),A(C,u,(()=>[]));const[m,L,T,k]=((e,t)=>[0,t.getContent,t.getTransactionChanges,([e,t])=>!f(e)||!f(t)])(0,e),M=async e=>(2!=D&&(D=1,await P.schedule((async()=>{await e(),D=0}))),P),P={load:async(a,s)=>await M((async()=>{try{const a=await t();(m&&x(a)?e.setMergeableContent:e.setContent)(a)}catch{e.setContent([a,s])}})),startAutoLoad:async(a={},n={})=>(P.stopAutoLoad(),await P.load(a,n),j=1,g=s((async(a,s)=>{if(s){const t=s();await M((async()=>(m&&x(t)?e.applyMergeableChanges:e.applyChanges)(t)))}else await M((async()=>{try{const s=a?.()??await t();(m&&x(s)?e.setMergeableContent:e.setContent)(s)}catch(e){c?.(e)}}))})),P),stopAutoLoad:()=>(j&&(n(g),g=void 0,j=0),P),save:async e=>(1!=D&&(D=2,await P.schedule((async()=>{try{await a(L,e)}catch(e){c?.(e)}D=0}))),P),startAutoSave:async()=>(await P.stopAutoSave().save(),p=e.addDidFinishTransactionListener((()=>{const e=T();k(e)&&P.save((()=>e))})),P),stopAutoSave:()=>(r(p,e.delListener),p=void 0,P),schedule:async(...e)=>(y(v(C,u),...e),await(async()=>{if(!v(S,u)){for(b(S,u,1);!o((e=v(C,u),w=e.shift()));)try{await w()}catch(e){c?.(e)}b(S,u,0)}var e})(),P),getStore:()=>e,destroy:()=>P.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return d&&(P[d]=()=>l),h(P)})(e,(async()=>await u((async e=>((e=[])=>l.fromEntries(e))(d(await T(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await u((async(e,t)=>await L(e,t)),e(),1)),(e=>setInterval(e,1e3*a)),(e=>n(e)),s,0,["getDbName",t])},e.objectStoreMatch=L},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
