var e,t;e=this,t=function(e){"use strict";const t=e=>typeof e,a=t(""),s=Promise,n=clearInterval,o=e=>null==e,r=(e,t,a)=>o(e)?a?.():t(e),c=e=>new s(e),i=async e=>s.all(e),d=(e,t)=>e.map(t),y=(e,...t)=>e.push(...t),l=Object,u=e=>l.getPrototypeOf(e),p=l.entries,w=l.keys,h=l.freeze,f=e=>(e=>!o(e)&&r(u(e),(e=>e==l.prototype||o(u(e))),(()=>!0)))(e)&&0==(e=>w(e).length)(e),v=e=>new Map(e),g=(e,t)=>e?.get(t),b=(e,t,a)=>{return o(a)?(s=e,n=t,s?.delete(n),e):e?.set(t,a);var s,n},A=(e,t,a)=>{var s,n;return s=e,n=t,s?.has(n)||b(e,t,a()),g(e,t)},S=v(),x=v(),C=globalThis.window,D=["t","v"],j={keyPath:"k"},m=async(e,t)=>{const a=((t,a)=>d(p(t),(([t,a])=>L(e,"put",{k:t,v:a}))))(t);d(await L(e,"getAllKeys"),(s=>((e,t)=>t in e)(t,s)?0:y(a,L(e,"delete",s)))),await i(a)},L=async(e,t,a)=>c(((s,n)=>{const o=e[t](a);o.onsuccess=()=>s(o.result),o.onerror=()=>n(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,s,u=1,p)=>{const w=async(e,t=[],a=0)=>c(((n,o)=>{const r=(C?C.indexedDB:indexedDB).open(s,a?2:void 0);r.onupgradeneeded=()=>a&&d(D,(e=>{try{r.result.createObjectStore(e,j)}catch{}})),r.onsuccess=async()=>{try{const a=r.result.transaction(D,"readwrite"),s=await i(d(D,(async(s,n)=>await e(a.objectStore(s),t[n]))));r.result.close(),n(s)}catch(e){r.result.close(),o(e)}},r.onerror=()=>o("indexedDB.open error")}));return((e,s,n,c,i,d,l,[u,p]=[],w=[])=>{let v,C,D,j=0,m=0;A(S,w,(()=>0)),A(x,w,(()=>[]));const L=e.getContent,T=e.getTransactionChanges,k=async e=>(2!=j&&(j=1,await P.schedule((async()=>{await e(),j=0}))),P),P={load:async(n,o)=>await k((async()=>{try{const n=await s();(l&&(e=>t(e)==a)(n[0])?e.applyMergeableChanges:e.setContent)(n)}catch{e.setContent([n,o])}})),startAutoLoad:async(t={},a={})=>(P.stopAutoLoad(),await P.load(t,a),m=1,D=c((async(t,a)=>{if(a){const t=a();await k((async()=>e.applyChanges(t)))}else await k((async()=>{try{e.setContent(t?.()??await s())}catch(e){d?.(e)}}))})),P),stopAutoLoad:()=>(m&&(i(D),D=void 0,m=0),P),save:async e=>(1!=j&&(j=2,await P.schedule((async()=>{try{await n(L,e)}catch(e){d?.(e)}j=0}))),P),startAutoSave:async()=>(await P.stopAutoSave().save(),v=e.addDidFinishTransactionListener((()=>{const[e,t]=T();f(e)&&f(t)||P.save((()=>[e,t]))})),P),stopAutoSave:()=>(r(v,e.delListener),v=void 0,P),schedule:async(...e)=>(y(g(x,w),...e),await(async()=>{if(!g(S,w)){for(b(S,w,1);!o((e=g(x,w),C=e.shift()));)try{await C()}catch(e){d?.(e)}b(S,w,0)}var e})(),P),getStore:()=>e,destroy:()=>P.stopAutoLoad().stopAutoSave(),getStats:()=>({})};return u&&(P[u]=()=>p),h(P)})(e,(async()=>await w((async e=>((e=[])=>l.fromEntries(e))(d(await L(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await w((async(e,t)=>await m(e,t)),e(),1)),(e=>setInterval(e,1e3*u)),(e=>n(e)),p,!1,["getDbName",s])},e.objectStoreMatch=m},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
