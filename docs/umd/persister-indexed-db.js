var e,t;e=this,t=function(e){"use strict";const t=Promise,a=clearInterval,s=e=>null==e,n=(e,t,a)=>s(e)?a?.():t(e),r=e=>new t(e),o=async e=>t.all(e),i=(e,t)=>e.map(t),c=(e,...t)=>e.push(...t),l=Object,d=e=>l.getPrototypeOf(e),y=l.entries,u=l.keys,g=l.freeze,p=e=>(e=>!s(e)&&n(d(e),(e=>e==l.prototype||s(d(e))),(()=>!0)))(e)&&0==(e=>u(e).length)(e),h=e=>new Map(e),w=(e,t)=>e?.get(t),f=(e,t,a)=>{return s(a)?(n=e,r=t,n?.delete(r),e):e?.set(t,a);var n,r},v=(e,t,a,s)=>{var n,r;return n=e,r=t,n?.has(r)||f(e,t,a()),w(e,t)},b=h(),A=h(),S=globalThis.window,C=["t","v"],x={keyPath:"k"},D=async(e,t)=>{const a=((t,a)=>i(y(t),(([t,a])=>M(e,"put",{k:t,v:a}))))(t);i(await M(e,"getAllKeys"),(s=>((e,t)=>t in e)(t,s)?0:c(a,M(e,"delete",s)))),await o(a)},M=async(e,t,a)=>r(((s,n)=>{const r=e[t](a);r.onsuccess=()=>s(r.result),r.onerror=()=>n(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,t,d=1,y)=>{const u=async(e,a=[],s=0)=>r(((n,r)=>{const c=(S?S.indexedDB:indexedDB).open(t,s?2:void 0);c.onupgradeneeded=()=>s&&i(C,(e=>{try{c.result.createObjectStore(e,x)}catch{}})),c.onsuccess=async()=>{try{const t=c.result.transaction(C,"readwrite"),s=await o(i(C,(async(s,n)=>await e(t.objectStore(s),a[n]))));c.result.close(),n(s)}catch(e){c.result.close(),r(e)}},c.onerror=()=>r("indexedDB.open error")}));return((e,t,a,r,o,i,l,d={},y=[])=>{let u,h,S,C=0;v(b,y,(()=>0)),v(A,y,(()=>[]));const[x,D,M,T,j]=((e=1,t)=>e>1&&t.isMergeable()?[1,t.getMergeableContent,t.getTransactionMergeableChanges,([[e],[t]])=>!p(e)||!p(t),t.setDefaultContent]:2!=e?[0,t.getContent,t.getTransactionChanges,([e,t])=>!p(e)||!p(t),t.setContent]:(e=>{throw Error("Store type not supported by this Persister")})())(l,e),m=t=>{var a;(x&&(a=t?.[0],Array.isArray(a))?1===t?.[2]?e.applyMergeableChanges:e.setMergeableContent:1===t?.[2]?e.applyChanges:e.setContent)(t)},P=async e=>(2!=C&&(C=1,await I((async()=>{try{m(await t())}catch(t){i?.(t),e&&j(e)}C=0}))),O),k=()=>(h&&(o(h),h=void 0),O),L=async e=>(1!=C&&(C=2,await I((async()=>{try{await a(D,e)}catch(e){i?.(e)}C=0}))),O),B=()=>(n(S,e.delListener),S=void 0,O),I=async(...e)=>(c(w(A,y),...e),await(async()=>{if(!w(b,y)){for(f(b,y,1);!s((e=w(A,y),u=e.shift()));)try{await u()}catch(e){i?.(e)}f(b,y,0)}var e})(),O),O={load:P,startAutoLoad:async e=>(await k().load(e),h=r((async(e,t)=>{t||e?2!=C&&(C=1,m(t??e),C=0):await P()})),O),stopAutoLoad:k,isAutoLoading:()=>!s(h),save:L,startAutoSave:async()=>(await B().save(),S=e.addDidFinishTransactionListener((()=>{const e=M();T(e)&&L(e)})),O),stopAutoSave:B,isAutoSaving:()=>!s(S),schedule:I,getStore:()=>e,destroy:()=>k().stopAutoSave(),getStats:()=>({}),...d};return g(O)})(e,(async()=>await u((async e=>((e=[])=>l.fromEntries(e))(i(await M(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await u((async(e,t)=>await D(e,t)),e(),1)),(e=>setInterval(e,1e3*d)),(e=>a(e)),y,1,{getDbName:()=>t})},e.objectStoreMatch=D},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
