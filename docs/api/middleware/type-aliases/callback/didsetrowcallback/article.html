<nav><ul><li><a href="/">TinyBase</a></li><li><a href="/api/">API</a></li><li><a href="/api/middleware/"><code>middleware</code></a></li><li><a href="/api/middleware/type-aliases/">Type Aliases</a></li><li><a href="/api/middleware/type-aliases/callback/didsetrowcallback/"><code>DidSetRowCallback</code></a></li></ul></nav><section class="s1" id="/api/middleware/type-aliases/callback/didsetrowcallback/" data-id="DSRC"><h1><code>DidSetRowCallback</code></h1><p>The <code>DidSetRowCallback</code> type describes a function called after a <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> is changed during a transaction, and after mutator listeners have fired.</p><pre><code><span class="punctuation">(</span>
  tableId<span class="operator">:</span> <span class="type"><a href="/api/common/type-aliases/identity/id/">Id</a></span><span class="punctuation">,</span>
  rowId<span class="operator">:</span> <span class="type"><a href="/api/common/type-aliases/identity/id/">Id</a></span><span class="punctuation">,</span>
  oldRow<span class="operator">:</span> <span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span><span class="punctuation">,</span>
  newRow<span class="operator">:</span> <span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span><span class="punctuation">,</span>
<span class="punctuation">)</span><span class="operator">:</span> <span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span></code></pre><div class="table"><table><tr><th></th><th>Type</th><th>Description</th></tr><tr><th><code>tableId</code></th><td><code><span class="type"><a href="/api/common/type-aliases/identity/id/">Id</a></span></code></td><td><p>The <a href="/api/common/type-aliases/identity/id/"><code>Id</code></a> of the <a href="/api/store/type-aliases/store/table/"><code>Table</code></a> containing the changed <a href="/api/store/type-aliases/store/row/"><code>Row</code></a>.</p></td></tr><tr><th><code>rowId</code></th><td><code><span class="type"><a href="/api/common/type-aliases/identity/id/">Id</a></span></code></td><td><p>The <a href="/api/common/type-aliases/identity/id/"><code>Id</code></a> of the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> that was changed.</p></td></tr><tr><th><code>oldRow</code></th><td><code><span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span></code></td><td><p>The <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> as it was at the start of the transaction.</p></td></tr><tr><th><code>newRow</code></th><td><code><span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span></code></td><td><p>The <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> as it is now, after all cell writes including those made by mutating listeners.</p></td></tr><tr><th class="right">returns</th><td><code><span class="type"><a href="/api/store/type-aliases/store/row/">Row</a></span></code></td><td><p></p><p>The <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> to use as the final state.</p><p></p></td></tr></table></div><p>Unlike the <code>willSet*</code> callbacks, which intercept writes as they happen, <code>didSetRow</code> fires once per touched <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> after all cell writes in the transaction have completed. This means multiple cell changes to the same <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> within a single transaction result in just one <code>didSetRow</code> call, with the full before-transaction and after-transaction <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> states.</p><p>The callback receives the <a href="/api/store/type-aliases/store/table/"><code>Table</code></a> <a href="/api/common/type-aliases/identity/id/"><code>Id</code></a>, <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> <a href="/api/common/type-aliases/identity/id/"><code>Id</code></a>, the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> as it was at the start of the transaction (<code>oldRow</code>), and the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> as it is now (<code>newRow</code>). It must return a <a href="/api/store/type-aliases/store/row/"><code>Row</code></a>:</p><ul><li><code>newRow</code> to accept the changes.</li><li>a different <code>[</code>Row<code>](/api/store/type-aliases/store/row/)</code> to replace the final state.</li><li><code>oldRow</code> to revert all changes to the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a>.</li><li>an empty object to delete the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a>.</li></ul><p>Multiple <code>DidSetRowCallback</code> functions can be registered for the same table and they will be called sequentially, each receiving the <a href="/api/store/type-aliases/store/row/"><code>Row</code></a> returned by the previous callback. The chain never short-circuits: all registered callbacks always run.</p><p>Note that <code>addDidSetRowCallback</code> is table-scoped: you must specify the table <a href="/api/common/type-aliases/identity/id/"><code>Id</code></a> when registering. Callbacks are only invoked for rows in the specified table, keeping overhead to zero for other tables.</p><section class="s2"><h2>Since</h2><p>v8.0.0</p></section></section>