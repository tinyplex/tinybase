{"title":"Car Analysis","description":"In this demo, we build an app that showcases the query capabilities of TinyBase\nv2.0, grouping and sorting dimensional data for lightweight analytical usage.","html":"","css":"#loading {\n  animation: spin 1s infinite linear;\n  height: 2rem;\n  margin: 40vh auto;\n  width: 2rem;\n  &::before {\n    content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"2rem\" viewBox=\"0 0 100 100\"><path d=\"M50 10A40 40 0 1 1 10 50\" stroke=\"black\" fill=\"none\" stroke-width=\"4\" /></svg>');\n  }\n}\n\n@keyframes spin {\n  from {\n    transform: rotate(0);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\nbody {\n  display: flex;\n  height: 100vh;\n}\n\naside {\n  background: #ddd;\n  flex: 0;\n  padding: 0.5rem 0.5rem 0;\n}\n\nmain {\n  background: #fff;\n  flex: 1;\n  max-height: 100vh;\n  padding: 0.5rem;\n}\n\ninput {\n  height: 1.5rem;\n  margin: 0 0.25rem 0 0;\n  vertical-align: bottom;\n}\n\nhr {\n  margin: 0.5rem 0 0.1rem;\n}\n\ntable {\n  width: 100%;\n  table-layout: fixed;\n  font-size: inherit;\n  line-height: inherit;\n  border-collapse: collapse;\n  align-self: flex-start;\n  margin: 0.5rem;\n  caption {\n    text-align: left;\n    height: 1.75rem;\n    button {\n      border: 0;\n      margin-right: 0.25rem;\n    }\n  }\n  th,\n  td {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n  th {\n    padding: 0.25rem;\n    cursor: pointer;\n    border: solid #ddd;\n    border-width: 1px 0;\n    text-align: left;\n  }\n  td {\n    border-bottom: 1px solid #eee;\n    span {\n      border-left: 2px solid transparent;\n      padding: 0.25rem;\n      line-height: 1.75rem;\n    }\n  }\n}\n\nsvg {\n  stroke: #666;\n  stroke-width: 1;\n  fill: #333;\n  text {\n    stroke: #fff;\n    stroke-width: 4;\n    paint-order: stroke;\n    font-size: 12;\n  }\n  path {\n    fill: none;\n  }\n  circle {\n    stroke-width: 2;\n    fill: #fff;\n    opacity: 0;\n    & + text {\n      text-anchor: middle;\n      display: none;\n    }\n    &:hover {\n      opacity: 1;\n      & + text {\n        display: block;\n      }\n    }\n  }\n}\n\n.measure(@color) {\n  stroke-width: 2;\n  stroke: @color;\n  border-color: @color;\n  fill: @color;\n}\n\n.MPG {\n  .measure(#FFB300);\n}\n.Cylinders {\n  .measure(#803e75);\n}\n.Displacement {\n  .measure(#FF6800);\n}\n.Horsepower {\n  .measure(#A6BDD7);\n}\n.Weight {\n  .measure(#C10020);\n}\n.Acceleration {\n  .measure(#98ce62);\n}\n\nselect {\n  border: 1px solid #ccc;\n  display: block;\n  font: inherit;\n  letter-spacing: inherit;\n  width: 10rem;\n  option {\n    border-left: 2px solid transparent;\n  }\n}\n\n@font-face {\n  font-family: Inter;\n  src: url(https://tinybase.org/fonts/inter.woff2) format(\"woff2\");\n}\n\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  color: #333;\n  font-family: Inter, sans-serif;\n  letter-spacing: -0.04rem;\n  font-size: 0.8rem;\n  line-height: 1.4rem;\n  margin: 0;\n  user-select: none;\n}","js":"const {createQueries, createStore} = TinyBase;\nconst {\n  Provider,\n  useCreateQueries,\n  useCreateStore,\n  useQueries,\n  useResultCell,\n  useResultSortedRowIds,\n  useResultTable,\n} = TinyBaseUiReact;\nconst {createElement, useCallback, useEffect, useMemo, useRef, useState} =\n  React;\nconst {Inspector} = TinyBaseUiReactInspector;\nconst {ResultSortedTableInHtmlTable} = TinyBaseUiReactDom;\n\nconst DIMENSION_CELL_IDS = ['Manufacturer', 'Name', 'Year', 'Region'];\n\nconst MEASURE_CELL_IDS = [\n  'MPG',\n  'Cylinders',\n  'Displacement',\n  'Horsepower',\n  'Weight',\n  'Acceleration',\n];\n\nconst AGGREGATES = {\n  Maximum: 'max',\n  Average: 'avg',\n  Minimum: 'min',\n};\n\nconst GRAPH_FONT = 11;\nconst GRAPH_PADDING = 5;\nconst NUMERIC = /^[\\d\\.]+$/;\n\nconst round = (value) => Math.round(value * 100) / 100;\n\nconst App = () => {\n  const store = useCreateStore(createStore);\n  const queries = useCreateQueries(store, createQueries);\n  // ...\n\n  // ...\n  const [isLoading, setIsLoading] = useState(true);\n  useMemo(async () => {\n    await loadTable(store);\n    setIsLoading(false);\n  }, []);\n\n  return (\n    <Provider store={store} queries={queries}>\n      {isLoading ? <Loading /> : <Body />}\n      <Inspector />\n    </Provider>\n  );\n};\n\nconst Loading = () => <div id=\"loading\" />;\n\naddEventListener('load', () =>\n  ReactDOM.createRoot(document.body).render(<App />),\n);\n\nconst loadTable = async (store) => {\n  const rows = (\n    await (await fetch(`https://tinybase.org/assets/cars.tsv`)).text()\n  ).split('\\n');\n  const cellIds = rows.shift().split('\\t');\n  store.transaction(() =>\n    rows.forEach((row, rowId) => {\n      const cells = row.split('\\t');\n      if (cells.length == cellIds.length) {\n        cells.forEach((cell, c) => {\n          if (cell != '') {\n            if (NUMERIC.test(cell)) {\n              cell = parseFloat(cell);\n            }\n            store.setCell('cars', rowId, cellIds[c], cell);\n          }\n        });\n      }\n    }),\n  );\n};\n\nconst Body = () => {\n  const [dimensions, setDimensions] = useState(['Manufacturer']);\n  const [measures, setMeasures] = useState(['MPG', 'Horsepower']);\n  const [aggregate, setAggregate] = useState('Average');\n  const [showTable, setAsGraph] = useState(false);\n  // ...\n\n  const queryId = useBuildQuery(dimensions, measures, aggregate);\n\n  return (\n    <>\n      <aside>\n        <b>Dimensions</b>\n        <Select\n          options={DIMENSION_CELL_IDS}\n          selected={dimensions}\n          onOptionsChange={setDimensions}\n        />\n        <hr />\n        <b>Measures</b>\n        <Select\n          options={MEASURE_CELL_IDS}\n          selected={measures}\n          onOptionsChange={setMeasures}\n        />\n        <hr />\n        <b>Aggregate</b>\n        <Select\n          options={Object.keys(AGGREGATES)}\n          selected={[aggregate]}\n          onOptionsChange={setAggregate}\n          multiple={false}\n        />\n        <hr />\n        <input\n          id=\"showTable\"\n          type=\"checkbox\"\n          checked={showTable}\n          onChange={useCallback(({target}) => setAsGraph(target.checked), [])}\n        />\n        <label for=\"showTable\">Show table</label>\n        <br />\n        <small>\n          <a href=\"https://github.com/vega/vega-datasets/blob/next/data/cars.json\">\n            Source\n          </a>\n        </small>\n      </aside>\n      {/* ... */}\n\n      {/* ... */}\n      {showTable ? (\n        <ResultTable queryId={queryId} columns={[...dimensions, ...measures]} />\n      ) : (\n        <ResultGraph\n          queryId={queryId}\n          dimensions={dimensions}\n          measures={measures}\n        />\n      )}\n    </>\n  );\n};\n\nconst useBuildQuery = (dimensions, measures, aggregate) =>\n  useMemo(() => {\n    useQueries().setQueryDefinition('query', 'cars', ({select, group}) => {\n      dimensions.forEach((cellId) => select(cellId));\n      measures.forEach((cellId) => {\n        select(cellId);\n        group(cellId, AGGREGATES[aggregate]);\n      });\n    });\n    return 'query';\n  }, [dimensions, measures, aggregate]);\n\nconst ResultTable = ({queryId, columns}) => (\n  <ResultSortedTableInHtmlTable\n    queryId={queryId}\n    sortOnClick={true}\n    paginator={true}\n    limit={10}\n    idColumn={false}\n    customCells={useMemo(\n      () =>\n        Object.fromEntries(\n          columns.map((column) => [column, {component: CustomCell}]),\n        ),\n      [...columns],\n    )}\n  />\n);\n\n// ...\nconst CustomCell = ({queryId, rowId, cellId}) => {\n  const cell = useResultCell(queryId, rowId, cellId);\n  return (\n    <span className={cellId}>{Number.isFinite(cell) ? round(cell) : cell}</span>\n  );\n};\n\nconst ResultGraph = ({queryId, dimensions, measures}) => {\n  const ref = useRef(null);\n  const [{width = 0, height = 0}, setDimensions] = useState({});\n  useEffect(() => {\n    const observer = new ResizeObserver(([{contentRect}]) =>\n      setDimensions(contentRect),\n    );\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, [ref]);\n  // ...\n\n  // ...\n  const [xAllLabels, yValueSets, yMax] = useGraphData(\n    queryId,\n    dimensions,\n    measures,\n  );\n  // ...\n\n  // ...\n  const [xToPixel, yToPixel, xLabels, yLabels, xRange] = useGraphSetup(\n    width,\n    height,\n    xAllLabels,\n    yMax,\n  );\n  // ...\n\n  // ...\n  if (width == 0 || height == 0) {\n    return <main ref={ref} />;\n  }\n  // ...\n\n  // ...\n  return (\n    <main ref={ref}>\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox={`0 0 ${width} ${height}`}\n      >\n        <path d={`M${xToPixel(0)} ${yToPixel(0)}H${xToPixel(xRange)}`} />\n\n        <>\n          {xLabels.map((xLabel, x) => {\n            const textX = xToPixel(x) - GRAPH_FONT / 2;\n            const textY = yToPixel(0) + GRAPH_PADDING;\n            return (\n              xLabel && (\n                <text\n                  transform={`translate(${textX} ${textY}) rotate(90)`}\n                  key={x}\n                >\n                  {xLabel}\n                </text>\n              )\n            );\n          })}\n        </>\n\n        <>\n          {yLabels.map((yLabel) => {\n            const textX = xToPixel(0) - GRAPH_PADDING;\n            const textY = yToPixel(yLabel) + GRAPH_FONT / 2;\n            return (\n              <text\n                transform={`translate(${textX} ${textY})`}\n                text-anchor=\"end\"\n                key={yLabel}\n              >\n                {yLabel}\n              </text>\n            );\n          })}\n        </>\n\n        {/* ... */}\n        {yValueSets.map((yValueSet, s) => (\n          <g className={measures[s]} key={s}>\n            <path\n              d={yValueSet\n                .map(\n                  (y, x) =>\n                    `${x == 0 ? 'M' : 'L'}${xToPixel(x)} ${yToPixel(y)}`,\n                )\n                .join('')}\n            />\n            {yValueSet.map((y, x) => (\n              <>\n                <circle cx={xToPixel(x)} cy={yToPixel(y)} r={GRAPH_PADDING} />\n                <text x={xToPixel(x)} y={yToPixel(y) - GRAPH_FONT}>\n                  {xAllLabels[x]} {measures[s]}: {round(y)}\n                </text>\n              </>\n            ))}\n          </g>\n        ))}\n      </svg>\n    </main>\n  );\n};\n\nconst useGraphData = (queryId, dimensions, measures) => {\n  const table = useResultTable(queryId);\n  const sortedRowIds = useResultSortedRowIds(queryId, measures[0] ?? undefined);\n  return useMemo(() => {\n    const yAll = [1];\n    const xAllLabels = [];\n    const yValueSets = measures.map(() => []);\n    sortedRowIds.forEach((rowId) => {\n      const row = table[rowId];\n      xAllLabels.push(\n        dimensions.map((dimensionColumn) => row[dimensionColumn]).join(', '),\n      );\n      measures.forEach((measureColumn, m) => {\n        yAll.push(row[measureColumn]);\n        yValueSets[m].push(row[measureColumn]);\n      });\n    });\n    return [xAllLabels, yValueSets, Math.max(...yAll)];\n  }, [table, sortedRowIds, measures, dimensions]);\n};\n\nconst useGraphSetup = (width, height, xAllLabels, yMax) =>\n  useMemo(() => {\n    const xOffset = height / 4;\n    const yOffset = width / 15;\n    const xWidth = width - yOffset - GRAPH_PADDING;\n    const yHeight = height - xOffset - GRAPH_PADDING;\n\n    const xRange = xAllLabels.length - 1;\n    const xLabels = xAllLabels.map((label, x) =>\n      x % Math.ceil((GRAPH_FONT * xRange) / xWidth) == 0 ? label : null,\n    );\n\n    const yMaxMagnitude = Math.pow(10, Math.floor(Math.log10(yMax)));\n    const yRange = Math.ceil(yMax / yMaxMagnitude) * yMaxMagnitude;\n    const yMajorSteps = Math.ceil(yMax / yMaxMagnitude);\n    const yMinorSteps = yMajorSteps <= 2 ? 5 : yMajorSteps <= 5 ? 2 : 1;\n    const yLabels = Array(yMinorSteps * yMajorSteps + 1)\n      .fill()\n      .map((_, i) => (i * yMaxMagnitude) / yMinorSteps);\n\n    return [\n      (x) => yOffset + (x * xWidth) / xRange,\n      (y) => GRAPH_PADDING + yHeight - (y * yHeight) / yRange,\n      xLabels,\n      yLabels,\n      xRange,\n      yRange,\n    ];\n  }, [width, height, xAllLabels, yMax]);\n\nconst Select = ({options, selected, onOptionsChange, multiple = true}) => {\n  const handleOptionsChange = useCallback(\n    ({target}) =>\n      onOptionsChange(\n        multiple\n          ? [...target.selectedOptions].map((option) => option.value)\n          : target.value,\n      ),\n    [onOptionsChange],\n  );\n  return (\n    <select\n      multiple={multiple}\n      size={options.length}\n      onChange={handleOptionsChange}\n    >\n      {options.map((option) => (\n        <option\n          value={option}\n          selected={selected.includes(option)}\n          className={option}\n        >\n          {option}\n        </option>\n      ))}\n    </select>\n  );\n};","css_pre_processor":"less","js_pre_processor":"typescript","js_external":"https://beta.tinybase.org/umd/react.production.min.js;https://beta.tinybase.org/umd/react-dom.production.min.js;https://beta.tinybase.org/umd/tinybase/index.js;https://beta.tinybase.org/umd/tinybase/ui-react/index.js;https://beta.tinybase.org/umd/tinybase/ui-react-dom/index.js;https://beta.tinybase.org/umd/tinybase/ui-react-inspector/index.js","editors":"012","tags":["tinybase"]}