{"title":"Drawing","description":"In this demo, we build a more complex drawing app, using many of the features of\nTinyBase together.","html":"","css":"@accentColor: #d81b60;\n@font-face {\n  font-family: Inter;\n  src: url(https://tinybase.org/fonts/inter.woff2) format(\"woff2\");\n}\n* {\n  box-sizing: border-box;\n  outline-color: @accentColor;\n}\n\nbody {\n  user-select: none;\n  display: grid;\n  grid-template-rows: auto 1fr;\n  grid-template-columns: 1fr 10rem;\n  font-family: Inter, sans-serif;\n  letter-spacing: -0.04rem;\n  font-size: 0.8rem;\n  margin: 0;\n  height: 100vh;\n\n  #toolbar {\n    z-index: 2;\n    grid-column: span 2;\n    background: #ddd;\n    display: flex;\n    align-items: center;\n    border-bottom: 1px solid #aaa;\n    > .button {\n      cursor: pointer;\n      line-height: 1rem;\n      white-space: nowrap;\n      border-right: 1px solid #aaa;\n      padding: 0.5rem;\n      &:hover {\n        background: #ccc;\n      }\n      &::before {\n        vertical-align: top;\n        width: 1rem;\n        height: 1rem;\n        display: inline-block;\n      }\n      &.undo::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><path fill=\"none\" d=\"M25 50a42 42 0 0 1 60 0\" /><path d=\"M14 41v20 h20z\" /></svg>');\n      }\n      &.redo::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><path fill=\"none\" d=\"M15 50a42 42 0 0 1 60 0\" /><path d=\"M86 41v20 h-20z\" /></svg>');\n      }\n      &.add::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"20\" y=\"20\" width=\"60\" height=\"60\" fill=\"white\"/><path d=\"M50 30v40M30 50h40\" /></svg>');\n      }\n      &.front::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"2\" y=\"2\" width=\"40\" height=\"40\" fill=\"grey\"/><rect x=\"58\" y=\"58\" width=\"40\" height=\"40\" fill=\"grey\"/><rect x=\"20\" y=\"20\" width=\"60\" height=\"60\" fill=\"white\"/></svg>');\n      }\n      &.forward::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"11\" y=\"11\" width=\"60\" height=\"60\" fill=\"grey\"/><rect x=\"29\" y=\"29\" width=\"60\" height=\"60\" fill=\"white\"/></svg>');\n      }\n      &.backward::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"11\" y=\"11\" width=\"60\" height=\"60\" fill=\"white\"/><rect x=\"29\" y=\"29\" width=\"60\" height=\"60\" fill=\"grey\"/></svg>');\n      }\n      &.back::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"20\" y=\"20\" width=\"60\" height=\"60\" fill=\"white\"/><rect x=\"2\" y=\"2\" width=\"40\" height=\"40\" fill=\"grey\"/><rect x=\"58\" y=\"58\" width=\"40\" height=\"40\" fill=\"grey\"/></svg>');\n      }\n      &.delete::before {\n        content: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1rem\" viewBox=\"0 0 100 100\" stroke-width=\"4\" stroke=\"black\"><rect x=\"20\" y=\"20\" width=\"60\" height=\"60\" fill=\"white\"/><path d=\"M30 30l40 40M30 70l40-40\" /></svg>');\n      }\n      &.disabled {\n        opacity: 0.5;\n        cursor: default;\n        &:hover {\n          background: none;\n        }\n      }\n    }\n  }\n\n  #sidebar {\n    z-index: 1;\n    background: #eee;\n    padding: 0.5rem;\n    border-left: 1px solid #aaa;\n    .cell {\n      height: 2rem;\n      text-align: right;\n      select,\n      input,\n      .spin {\n        font: inherit;\n        letter-spacing: -0.05rem;\n        margin-left: 5px;\n        width: 4.5rem;\n        height: 1.4rem;\n        display: inline-flex;\n        justify-content: space-between;\n        align-items: center;\n        .button {\n          cursor: pointer;\n          border: 1px solid #aaa;\n          font: inherit;\n          width: 1rem;\n          text-align: center;\n          &:hover {\n            background: #ccc;\n          }\n        }\n      }\n    }\n  }\n\n  #canvas {\n    position: relative;\n    z-index: 0;\n    .shape {\n      align-items: center;\n      background: white;\n      border: 1px solid black;\n      box-sizing: border-box;\n      display: flex;\n      justify-content: center;\n      position: absolute;\n      overflow: hidden;\n      white-space: nowrap;\n      z-index: 1;\n      &.ellipse {\n        border-radius: 50%;\n      }\n      &.selected {\n        cursor: move;\n      }\n      input,\n      span {\n        background: transparent;\n        border: none;\n        font: inherit;\n        width: 100%;\n        text-align: center;\n        margin: 0.5rem;\n        text-overflow: ellipsis;\n        overflow: hidden;\n      }\n    }\n    .grip {\n      background: white;\n      border: 1px solid @accentColor;\n      box-sizing: border-box;\n      height: 6px;\n      margin: -3px;\n      position: absolute;\n      width: 6px;\n      z-index: 2;\n    }\n  }\n}","js":"const {\n  createCheckpoints,\n  createLocalPersister,\n  createRelationships,\n  createStore,\n} = TinyBase;\nconst {\n  LinkedRowsView,\n  Provider,\n  useAddRowCallback,\n  useCell,\n  useCreateCheckpoints,\n  useCreatePersister,\n  useCreateRelationships,\n  useCreateStore,\n  useLinkedRowIds,\n  useLocalRowIds,\n  useRedoInformation,\n  useRemoteRowId,\n  useRow,\n  useRowListener,\n  useSetCellCallback,\n  useSetCheckpointCallback,\n  useSetPartialRowCallback,\n  useStore,\n  useUndoInformation,\n} = TinyBaseUiReact;\nconst {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} = React;\n\nconst useDraggableObject = (\n  getInitial,\n  onDrag,\n  onDragStart = null,\n  onDragStop = null,\n) => {\n  const [start, setStart] = useState();\n\n  const handleMouseDown = useCallback(\n    (event) => {\n      onDragStart?.();\n      setStart({\n        x: event.clientX,\n        y: event.clientY,\n        initial: getInitial(),\n      });\n      event.stopPropagation();\n    },\n    [getInitial, onDragStart],\n  );\n  const handleMouseMove = useCallback(\n    (event) => {\n      if (start != null) {\n        onDrag({\n          dx: event.clientX - start.x,\n          dy: event.clientY - start.y,\n          initial: start.initial,\n        });\n      }\n      event.stopPropagation();\n    },\n    [onDrag, start],\n  );\n  const handleMouseUp = useCallback(\n    (event) => {\n      setStart(null);\n      onDragStop?.();\n      event.stopPropagation();\n    },\n    [onDragStop],\n  );\n\n  const ref = useRef(null);\n  useLayoutEffect(() => {\n    const {current} = ref;\n    current.addEventListener('mousedown', handleMouseDown);\n    return () => current.removeEventListener('mousedown', handleMouseDown);\n  }, [ref, handleMouseDown]);\n  useEffect(() => {\n    if (start != null) {\n      addEventListener('mousemove', handleMouseMove);\n      addEventListener('mouseup', handleMouseUp);\n      return () => {\n        removeEventListener('mousemove', handleMouseMove);\n        removeEventListener('mouseup', handleMouseUp);\n      };\n    }\n  }, [start, handleMouseMove, handleMouseUp]);\n\n  return ref;\n};\n\nconst SHAPES = 'shapes';\nconst CANVAS_ID = '0';\nconst MIN_WIDTH = 50;\nconst MIN_HEIGHT = 30;\nconst TYPES = ['rectangle', 'ellipse'];\n\nconst constrainType = (store, tableId, rowId, cellId, type) => {\n  if (!TYPES.includes(type)) {\n    store.setCell(tableId, rowId, cellId, TYPES[0]);\n  }\n};\n\nconst constrainColor = (store, tableId, rowId, cellId, color) => {\n  if (!/^#[a-f\\d]{6}$/.test(color)) {\n    store.setCell(tableId, rowId, cellId, '#000000');\n  }\n};\n\nconst SelectedIdContext = createContext([null, () => {}]);\nconst useSelectedIdState = () => useContext(SelectedIdContext);\n\nconst App = () => {\n  const store = useCreateStore(() => {\n    const store = createStore().setTablesSchema({\n      [SHAPES]: {\n        x1: {type: 'number', default: 100},\n        y1: {type: 'number', default: 100},\n        x2: {type: 'number', default: 300},\n        y2: {type: 'number', default: 200},\n        text: {type: 'string', default: 'text'},\n        type: {type: 'string'},\n        backColor: {type: 'string', default: '#0077aa'},\n        textColor: {type: 'string', default: '#ffffff'},\n        nextId: {type: 'string'},\n      },\n    });\n    store.addCellListener(SHAPES, null, 'type', constrainType, true);\n    store.addCellListener(SHAPES, null, 'backColor', constrainColor, true);\n    store.addCellListener(SHAPES, null, 'textColor', constrainColor, true);\n    return store;\n  }, []);\n  // ...\n\n  // ...\n  const checkpoints = useCreateCheckpoints(store, createCheckpoints);\n\n  useCreatePersister(\n    store,\n    (store) => createLocalPersister(store, 'drawing/store'),\n    [],\n    async (persister) => {\n      await persister.startAutoLoad({\n        shapes: {\n          [CANVAS_ID]: {x1: 0, y1: 0, nextId: '1'},\n          1: {},\n        },\n      });\n      checkpoints.clear();\n      await persister.startAutoSave();\n    },\n    [checkpoints],\n  );\n\n  const relationships = useCreateRelationships(store, (store) =>\n    createRelationships(store).setRelationshipDefinition(\n      'order',\n      SHAPES,\n      SHAPES,\n      'nextId',\n    ),\n  );\n  // ...\n\n  // ...\n  return (\n    <Provider\n      store={store}\n      relationships={relationships}\n      checkpoints={checkpoints}\n    >\n      <SelectedIdContext.Provider value={useState()}>\n        <Toolbar />\n        <Canvas />\n        <Sidebar />\n      </SelectedIdContext.Provider>\n    </Provider>\n  );\n};\n\naddEventListener('load', () =>\n  ReactDOM.createRoot(document.body).render(<App />),\n);\n\nconst Toolbar = () => {\n  const [useSelectedId] = useSelectedIdState();\n  return (\n    <div id=\"toolbar\">\n      <UndoRedo />\n      <ShapeAdd />\n      {useSelectedId == null ? null : (\n        <>\n          <ShapeOrder />\n          <ShapeDelete />\n        </>\n      )}\n    </div>\n  );\n};\n\nconst UndoRedo = () => {\n  const [canUndo, handleUndo, , undoLabel] = useUndoInformation();\n  const [canRedo, handleRedo, , redoLabel] = useRedoInformation();\n\n  return (\n    <>\n      <div\n        className={`button undo${canUndo ? '' : ' disabled'}`}\n        {...(canUndo ? {onClick: handleUndo, title: `Undo ${undoLabel}`} : {})}\n      />\n      <div\n        className={`button redo${canRedo ? '' : ' disabled'}`}\n        {...(canRedo ? {onClick: handleRedo, title: `Redo ${redoLabel}`} : {})}\n      />\n    </>\n  );\n};\n\nconst ShapeAdd = () => {\n  const frontId = useFrontId();\n  const [, setSelectedId] = useSelectedIdState();\n  const setCheckpoint = useSetCheckpointCallback(() => 'add shape', []);\n  const onAddRow = useCallback(\n    (id, store) => {\n      store.setCell(SHAPES, frontId, 'nextId', id);\n      setSelectedId(id);\n      setCheckpoint();\n    },\n    [frontId, setSelectedId, setCheckpoint],\n  );\n  const handleClick = useAddRowCallback(\n    SHAPES,\n    () => ({}),\n    [],\n    null,\n    onAddRow,\n    [onAddRow],\n  );\n  return (\n    <div className=\"button add\" onClick={handleClick}>\n      Add shape\n    </div>\n  );\n};\n\nconst useBackId = () => useLinkedRowIds('order', CANVAS_ID)[1];\nconst useFrontId = () => useLinkedRowIds('order', CANVAS_ID).slice(-1)[0];\n\nconst ShapeOrder = () => {\n  const [selectedId] = useSelectedIdState();\n  const frontId = useFrontId();\n  const forwardId = useRemoteRowId('order', selectedId);\n  const [previousId] = useLocalRowIds('order', selectedId);\n  const [backwardId] = useLocalRowIds('order', previousId);\n  const backId = useBackId();\n  return [\n    ['front', 'To front', frontId, useOrderShape(frontId, 'to front')],\n    ['forward', 'Forward', frontId, useOrderShape(forwardId, 'forward')],\n    ['backward', 'Backward', backId, useOrderShape(backwardId, 'backward')],\n    ['back', 'To back', backId, useOrderShape(CANVAS_ID, 'to back')],\n  ].map(([className, label, disabledIfId, handleClick]) => {\n    const disabled = selectedId == null || selectedId == disabledIfId;\n    return (\n      <div\n        className={`button ${className} ${disabled ? ' disabled' : ''}`}\n        onClick={disabled ? null : handleClick}\n        key={className}\n      >\n        {label}\n      </div>\n    );\n  });\n};\n\nconst useOrderShape = (toId, label) => {\n  const store = useStore();\n  const [selectedId] = useSelectedIdState();\n  const [previousId] = useLocalRowIds('order', selectedId);\n  const nextId = useRemoteRowId('order', selectedId);\n  const nextNextId = useRemoteRowId('order', toId);\n  const setCheckpoint = useSetCheckpointCallback(() => `move ${label}`, []);\n  return useCallback(() => {\n    store.transaction(() => {\n      if (nextId != null) {\n        store.setCell(SHAPES, previousId, 'nextId', nextId);\n      } else {\n        store.delCell(SHAPES, previousId, 'nextId');\n      }\n      if (nextNextId != null) {\n        store.setCell(SHAPES, selectedId, 'nextId', nextNextId);\n      } else {\n        store.delCell(SHAPES, selectedId, 'nextId');\n      }\n      store.setCell(SHAPES, toId, 'nextId', selectedId);\n    });\n    setCheckpoint();\n  }, [selectedId, toId, store, previousId, nextId, nextNextId, setCheckpoint]);\n};\n\nconst ShapeDelete = () => {\n  const store = useStore();\n  const [selectedId, setSelectedId] = useSelectedIdState();\n  const [previousId] = useLocalRowIds('order', selectedId);\n  const nextId = useRemoteRowId('order', selectedId);\n  const setCheckpoint = useSetCheckpointCallback(() => 'delete', []);\n  const handleClick = useCallback(() => {\n    store.transaction(() => {\n      if (nextId == null) {\n        store.delCell(SHAPES, previousId, 'nextId');\n      } else {\n        store.setCell(SHAPES, previousId, 'nextId', nextId);\n      }\n      store.delRow(SHAPES, selectedId);\n    });\n    setCheckpoint();\n    setSelectedId();\n  }, [store, selectedId, setSelectedId, previousId, nextId, setCheckpoint]);\n  return (\n    <div className=\"button delete\" onClick={handleClick}>\n      Delete\n    </div>\n  );\n};\n\nconst Sidebar = () => {\n  const [selectedId] = useSelectedIdState();\n  return (\n    <div id=\"sidebar\">\n      {selectedId == null ? null : (\n        <>\n          <SidebarTypeCell />\n          <SidebarColorCell label=\"Text\" cellId=\"textColor\" />\n          <SidebarColorCell label=\"Back\" cellId=\"backColor\" />\n          <SidebarNumberCell label=\"Left\" cellId=\"x1\" />\n          <SidebarNumberCell label=\"Top\" cellId=\"y1\" />\n          <SidebarNumberCell label=\"Right\" cellId=\"x2\" />\n          <SidebarNumberCell label=\"Bottom\" cellId=\"y2\" />\n        </>\n      )}\n    </div>\n  );\n};\n\nconst SidebarCell = ({label, children}) => (\n  <div className=\"cell\">\n    {label}: {children}\n  </div>\n);\n\nconst SidebarTypeCell = () => {\n  const [selectedId] = useSelectedIdState();\n  const setCheckpoint = useSetCheckpointCallback(() => 'change of type', []);\n  return (\n    <SidebarCell label=\"Shape\">\n      <select\n        value={useCell(SHAPES, selectedId, 'type')}\n        onChange={useSetCellCallback(\n          SHAPES,\n          selectedId,\n          'type',\n          (e) => e.target.value,\n          [],\n          null,\n          setCheckpoint,\n        )}\n      >\n        {TYPES.map((type) => (\n          <option key={type}>{type}</option>\n        ))}\n      </select>\n    </SidebarCell>\n  );\n};\n\nconst SidebarColorCell = ({label, cellId}) => {\n  const [selectedId] = useSelectedIdState();\n  const setCheckpoint = useSetCheckpointCallback(\n    () => `change of '${label.toLowerCase()}' color`,\n    [label],\n  );\n  return (\n    <SidebarCell label={label}>\n      <input\n        type=\"color\"\n        value={useCell(SHAPES, selectedId, cellId)}\n        onChange={useSetCellCallback(\n          SHAPES,\n          selectedId,\n          cellId,\n          (e) => e.target.value,\n          [],\n          null,\n          setCheckpoint,\n        )}\n      />\n    </SidebarCell>\n  );\n};\n\nconst nudgeUp = (cell) => cell + 1;\nconst nudgeDown = (cell) => cell - 1;\n\nconst SidebarNumberCell = ({label, cellId}) => {\n  const [selectedId] = useSelectedIdState();\n  const setCheckpoint = useSetCheckpointCallback(\n    () => `nudge of '${label.toLowerCase()}' value`,\n    [label],\n  );\n  const handleDown = useSetCellCallback(\n    SHAPES,\n    selectedId,\n    cellId,\n    () => nudgeDown,\n    [nudgeDown],\n    null,\n    setCheckpoint,\n  );\n  const handleUp = useSetCellCallback(\n    SHAPES,\n    selectedId,\n    cellId,\n    () => nudgeUp,\n    [nudgeUp],\n    null,\n    setCheckpoint,\n  );\n\n  return (\n    <SidebarCell label={label}>\n      <div className=\"spin\">\n        <div className=\"button\" onClick={handleDown}>\n          -\n        </div>\n        {useCell(SHAPES, selectedId, cellId)}\n        <div className=\"button\" onClick={handleUp}>\n          +\n        </div>\n      </div>{' '}\n    </SidebarCell>\n  );\n};\n\nconst Canvas = () => {\n  const ref = useRef(null);\n  const store = useStore();\n\n  const [canvasDimensions, setCanvasDimensions] = useState([0, 0]);\n\n  const getShapeDimensions = useCallback(\n    (id, maxX, maxY) => {\n      const {x1, x2, y1, y2} = store.getRow(SHAPES, id);\n      const w = Math.max(x2 - x1, Math.min(MIN_WIDTH, maxX));\n      const h = Math.max(y2 - y1, Math.min(MIN_HEIGHT, maxY));\n      return {x1, x2, y1, y2, w, h};\n    },\n    [store],\n  );\n\n  useRowListener(\n    SHAPES,\n    null,\n    (store, _tableId, rowId, getCellChange) => {\n      const [maxX, maxY] = canvasDimensions;\n      if (maxX == 0 || maxY == 0) {\n        return;\n      }\n\n      const [x1Changed] = getCellChange(SHAPES, rowId, 'x1');\n      const [x2Changed] = getCellChange(SHAPES, rowId, 'x2');\n      const [y1Changed] = getCellChange(SHAPES, rowId, 'y1');\n      const [y2Changed] = getCellChange(SHAPES, rowId, 'y2');\n      if (\n        (x1Changed || x2Changed || y1Changed || y2Changed) &&\n        rowId != CANVAS_ID\n      ) {\n        const {x1, x2, y1, y2, w, h} = getShapeDimensions(rowId, maxX, maxY);\n        if (x1Changed && x1 != null) {\n          store.setCell(\n            SHAPES,\n            rowId,\n            'x1',\n            between(x1, 0, Math.min(x2, maxX) - w),\n          );\n        }\n        if (x2Changed && x2 != null) {\n          store.setCell(\n            SHAPES,\n            rowId,\n            'x2',\n            between(x2, Math.max(x1, 0) + w, maxX),\n          );\n        }\n        if (y1Changed && y1 != null) {\n          store.setCell(\n            SHAPES,\n            rowId,\n            'y1',\n            between(y1, 0, Math.min(y2, maxY) - h),\n          );\n        }\n        if (y2Changed && y2 != null) {\n          store.setCell(\n            SHAPES,\n            rowId,\n            'y2',\n            between(y2, Math.max(y1, 0) + h, maxY),\n          );\n        }\n      }\n    },\n    [...canvasDimensions, getShapeDimensions],\n    true,\n  );\n\n  const updateDimensions = useCallback(\n    (current) => {\n      const {clientWidth: maxX, clientHeight: maxY} = current;\n      setCanvasDimensions([maxX, maxY]);\n      store.forEachRow(SHAPES, (id) => {\n        if (id != CANVAS_ID) {\n          const {x2, y2, w, h} = getShapeDimensions(id, maxX, maxY);\n          if (x2 > maxX) {\n            store.setPartialRow(SHAPES, id, {\n              x1: Math.max(0, maxX - w),\n              x2: maxX,\n            });\n          }\n          if (y2 > maxY) {\n            store.setPartialRow(SHAPES, id, {\n              y1: Math.max(0, maxY - h),\n              y2: maxY,\n            });\n          }\n        }\n      });\n    },\n    [store, getShapeDimensions],\n  );\n\n  useEffect(() => {\n    const {current} = ref;\n    const observer = new ResizeObserver(() => updateDimensions(current));\n    observer.observe(current);\n    updateDimensions(current);\n    return () => observer.disconnect();\n  }, [ref, store, updateDimensions]);\n\n  const [, setSelectedId] = useSelectedIdState();\n  const getRowComponentProps = useCallback((id) => ({id}), []);\n  const handleMouseDown = useCallback(() => setSelectedId(), [setSelectedId]);\n  const backId = useBackId();\n  return (\n    <div id=\"canvas\" onMouseDown={handleMouseDown} ref={ref}>\n      {backId == null ? null : (\n        <LinkedRowsView\n          relationshipId=\"order\"\n          firstRowId={backId}\n          rowComponent={Shape}\n          getRowComponentProps={getRowComponentProps}\n        />\n      )}\n    </div>\n  );\n};\n\nconst between = (value, min, max) =>\n  value < min ? min : value > max ? max : value;\n\nconst Shape = ({id}) => {\n  const [selectedId, setSelectedId] = useSelectedIdState();\n  const selected = id == selectedId;\n  const {x1, y1, x2, y2, backColor, type} = useRow(SHAPES, id);\n\n  const store = useStore();\n  const getInitial = useCallback(() => store.getRow(SHAPES, id), [store, id]);\n\n  const handleDrag = useSetPartialRowCallback(\n    SHAPES,\n    id,\n    ({dx, dy, initial}) => ({\n      x1: initial.x1 + dx,\n      y1: initial.y1 + dy,\n      x2: initial.x2 + dx,\n      y2: initial.y2 + dy,\n    }),\n    [],\n  );\n  const handleDragStart = useCallback(\n    () => setSelectedId(id),\n    [setSelectedId, id],\n  );\n  const handleDragStop = useSetCheckpointCallback(() => 'drag', []);\n  const ref = useDraggableObject(\n    getInitial,\n    handleDrag,\n    handleDragStart,\n    handleDragStop,\n  );\n\n  const style = {\n    left: `${x1}px`,\n    top: `${y1}px`,\n    width: `${x2 - x1}px`,\n    height: `${y2 - y1}px`,\n    background: backColor,\n  };\n\n  return (\n    <>\n      <div\n        ref={ref}\n        className={`shape ${type}${selected ? ' selected' : ''}`}\n        style={style}\n      >\n        <ShapeText id={id} />\n      </div>\n      {selected ? <ShapeGrips id={id} /> : null}\n    </>\n  );\n};\n\nconst ShapeText = ({id}) => {\n  const {text, textColor} = useRow(SHAPES, id);\n  const ref = useRef();\n  const [editing, setEditing] = useState(false);\n  const setCheckpoint = useSetCheckpointCallback(() => 'edit text', []);\n  const handleDoubleClick = useCallback(() => setEditing(true), []);\n  const handleBlur = useCallback(() => {\n    setEditing(false);\n    setCheckpoint();\n  }, [setCheckpoint]);\n  const handleChange = useSetCellCallback(\n    SHAPES,\n    id,\n    'text',\n    (e) => e.target.value,\n    [],\n  );\n  const handleKeyDown = useCallback((e) => {\n    if (e.which == 13) {\n      e.target.blur();\n    }\n  }, []);\n\n  useEffect(() => {\n    if (editing) {\n      ref.current.focus();\n    }\n  }, [editing, ref]);\n\n  const style = {color: textColor};\n\n  return editing ? (\n    <input\n      ref={ref}\n      style={style}\n      value={text}\n      onChange={handleChange}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n    />\n  ) : (\n    <span style={style} onDoubleClick={handleDoubleClick}>\n      {text != '' ? text : '\\xa0'}\n    </span>\n  );\n};\n\nconst ShapeGrips = ({id}) => {\n  const {x1, y1, x2, y2} = useRow(SHAPES, id);\n  const xm = (x1 + x2) / 2;\n  const ym = (y1 + y2) / 2;\n  return (\n    <>\n      <Grip m={[1, 1, 0, 0]} id={id} x={x1} y={y1} d=\"nwse\" />\n      <Grip m={[0, 1, 0, 0]} id={id} x={xm} y={y1} d=\"ns\" />\n      <Grip m={[0, 1, 1, 0]} id={id} x={x2} y={y1} d=\"nesw\" />\n      <Grip m={[0, 0, 1, 0]} id={id} x={x2} y={ym} d=\"ew\" />\n      <Grip m={[0, 0, 1, 1]} id={id} x={x2} y={y2} d=\"nwse\" />\n      <Grip m={[0, 0, 0, 1]} id={id} x={xm} y={y2} d=\"ns\" />\n      <Grip m={[1, 0, 0, 1]} id={id} x={x1} y={y2} d=\"nesw\" />\n      <Grip m={[1, 0, 0, 0]} id={id} x={x1} y={ym} d=\"ew\" />\n    </>\n  );\n};\n\nconst Grip = ({m: [mx1, my1, mx2, my2], id, x, y, d}) => {\n  const store = useStore();\n  const getInitial = useCallback(() => store.getRow(SHAPES, id), [store, id]);\n\n  const handleDrag = useSetPartialRowCallback(\n    SHAPES,\n    id,\n    ({dx, dy, initial}) => ({\n      x1: initial.x1 + dx * mx1,\n      y1: initial.y1 + dy * my1,\n      x2: initial.x2 + dx * mx2,\n      y2: initial.y2 + dy * my2,\n    }),\n    [mx1, my1, mx2, my2],\n  );\n  const handleDragStop = useSetCheckpointCallback(() => 'resize', []);\n\n  return (\n    <div\n      ref={useDraggableObject(getInitial, handleDrag, null, handleDragStop)}\n      className=\"grip\"\n      style={{left: `${x}px`, top: `${y}px`, cursor: `${d}-resize`}}\n    />\n  );\n};","css_pre_processor":"less","js_pre_processor":"typescript","js_external":"https://beta.tinybase.org/umd/react.production.min.js;https://beta.tinybase.org/umd/react-dom.production.min.js;https://beta.tinybase.org/umd/tinybase.js;https://beta.tinybase.org/umd/ui-react.js","editors":"012","tags":["tinybase"]}