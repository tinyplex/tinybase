# Generating APIs

TinyBase can take a TablesSchema (which has either been explicitly set, or
inferred) and generate the code for type definitions and ORM-like
implementations to wrap the Store.

This is most likely to be used as part of a build script which takes a
TablesSchema input (or imported data) to generate a TypeScript definition
(`.d.ts`) file and a `.ts` implementation. These can then be linked into the
development and compilation of an application as a whole.

## Using The getStoreApi Method

This is performed from the Tools object - which is returned from the createTools
method - and via the getStoreApi method.

The method takes a parameter which serves as the 'name' for your wrapped, typed,
Store:

```js
const store = createStore().setTable('pets', {
  fido: {species: 'dog'},
  felix: {species: 'cat'},
  cujo: {species: 'dog'},
});

const tools = createTools(store);

const [dTs, ts] = tools.getStoreApi('shop');
```

In this case, the resulting two strings will need to be written to `shop.d.ts`
and `shop.ts` files respectively - TinyBase does not perform that step for you:

```js yolo
fs.writeFileSync('shop.d.ts', dTs, 'utf-8');
fs.writeFileSync('shop.ts', ts, 'utf-8');
```

## Prettified Code

The getPrettyStoreApi method is an asynchronous method that attempts to run a
locally installed `prettier` module to ensure the file is reasonably formatted:

```js
const [prettyDTs, prettyTs] = await tools.getPrettyStoreApi('shop');
fs.writeFileSync('shop.d.ts', prettyDTs, 'utf-8'); // !yolo
fs.writeFileSync('shop.ts', prettyTs, 'utf-8'); // !yolo
```

This will produce a file containing the types for your wrapped Store:

```ts yolo
//...
/**
 * Represents the 'pets' Table.
 */
export type PetsTable = {[rowId: Id]: PetsRow};

/**
 * Represents a Row when getting the content of the 'pets' Table.
 */
export type PetsRow = {species: string};
//...
```

The `.ts` implementation will contain the `createShop` entry point, and will
look something like this:

```ts yolo
//...
export const createShop: typeof createShopDecl = () => {
  // ...
  const store = createStore().setTablesSchema({
    pets: {
      species: {type: 'string', default: 'dog'},
    },
  });
  return {
    hasPetsTable: (): boolean => store.hasTable('pets'),
    getPetsTable: (): PetsTable => store.getTable('pets') as PetsTable,
    // ...
  };
};
```

(For the full set of methods and types generated by this method, inspect the
output directly.)

Whether pretty or not, the resulting two files can then be included in your main
application. Note that the implementation (`shop.ts`) imports types from the
definition (`shop.d.ts`) and requires the two files to be next to each other in
the file system.

If the Store has neither an explicit schema, nor can one be inferred, the two
strings will be empty, since no type information can be usefully generated for
the Store.

If you do not wish to handle the programmatic steps described above, and simply
want to take schemas stored in a file and generate these definitions directly,
see the Command Line guide in this section.

You can also read the brief Gathering Statistics guide.
